

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyleoclim.utils.correlation &mdash; Pyleoclim 0.5.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> Pyleoclim
          

          
          </a>

          
            
            
              <div class="version">
                0.5.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Pyleoclim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pyleoclim.utils.correlation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyleoclim.utils.correlation</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Tue Feb 25 06:01:55 2020</span>

<span class="sd">@author: deborahkhider</span>

<span class="sd">Contains all relevant functions for correlation analysis</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;corr_sig&#39;</span><span class="p">,</span>
    <span class="s1">&#39;fdr&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">pearsonr</span>
<span class="kn">from</span> <span class="nn">scipy.stats.mstats</span> <span class="kn">import</span> <span class="n">gmean</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">t</span> <span class="k">as</span> <span class="n">stu</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">gaussian_kde</span>
<span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span>
<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">preprocessing</span>


<div class="viewcode-block" id="corr_sig"><a class="viewcode-back" href="../../../utils/correlation/corr_sig.html#pyleoclim.utils.correlation.corr_sig">[docs]</a><span class="k">def</span> <span class="nf">corr_sig</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">nsim</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;isospectral&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Estimates the Pearson&#39;s correlation and associated significance between two non IID time series</span>
<span class="sd">    </span>
<span class="sd">    The significance of the correlation is assessed using one of the following methods:</span>
<span class="sd">        </span>
<span class="sd">    1) &#39;ttest&#39;: T-test adjusted for effective sample size.</span>
<span class="sd">    2) &#39;isopersistent&#39;: AR(1) modeling of x and y.</span>
<span class="sd">    3) &#39;isospectral&#39;: phase randomization of original inputs. (default)</span>
<span class="sd">    </span>
<span class="sd">    The T-test is a parametric test, hence computationally cheap but can only be performed in idyllic circumstances.</span>
<span class="sd">    The others are non-parametric, but their computational requirements scales with nsim.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    y1 : array</span>
<span class="sd">        vector of (real) numbers of same length as y2, no NaNs allowed</span>
<span class="sd">        </span>
<span class="sd">    y2 : array</span>
<span class="sd">        vector of (real) numbers of same length as y1, no NaNs allowed</span>
<span class="sd">        </span>
<span class="sd">    nsim : int</span>
<span class="sd">        the number of simulations [default: 1000]</span>
<span class="sd">        </span>
<span class="sd">    method : {&#39;ttest&#39;,&#39;isopersistent&#39;,&#39;isospectral&#39;}</span>
<span class="sd">        method for significance testing</span>
<span class="sd">        </span>
<span class="sd">    alpha : float</span>
<span class="sd">        significance level for critical value estimation [default: 0.05]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : dict </span>
<span class="sd">        Containing:</span>
<span class="sd">            </span>
<span class="sd">        - r : correlation between x and y</span>
<span class="sd">         </span>
<span class="sd">        - signif : true (1) if significant; false (0) otherwise</span>
<span class="sd">         </span>
<span class="sd">        - p : Fraction of time series with higher correlation coefficents than observed (approximates the p-value).</span>
<span class="sd">         Note that signif = True if and only if p &lt;= alpha.</span>
<span class="sd">         </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>

<span class="sd">    corr_ttest : Estimates the significance of correlations between 2 time series using the classical T-test adjusted for effective sample size.</span>
<span class="sd">    </span>
<span class="sd">    corr_isopersist : Computes correlation between two timeseries, and their significance using Ar(1) modeling.</span>
<span class="sd">    </span>
<span class="sd">    corr_isospec : Estimates the significance of the correlation using phase randomization</span>
<span class="sd">     </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">y2</span><span class="p">),</span> <span class="s1">&#39;The size of X and the size of Y should be the same!&#39;</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ttest&#39;</span><span class="p">:</span>
        <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">signif</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="n">corr_ttest</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;isopersistent&#39;</span><span class="p">:</span>
        <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">signif</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="n">corr_isopersist</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">nsim</span><span class="o">=</span><span class="n">nsim</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;isospectral&#39;</span><span class="p">:</span>
        <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">signif</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="n">corr_isospec</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">nsim</span><span class="o">=</span><span class="n">nsim</span><span class="p">)</span>

    <span class="n">res</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;r&#39;</span><span class="p">:</span><span class="n">r</span><span class="p">,</span><span class="s1">&#39;signif&#39;</span><span class="p">:</span><span class="n">signif</span><span class="p">,</span><span class="s1">&#39;p&#39;</span><span class="p">:</span><span class="n">p</span><span class="p">}</span>    
    
    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="fdr"><a class="viewcode-back" href="../../../utils/correlation/fdr.html#pyleoclim.utils.correlation.fdr">[docs]</a><span class="k">def</span> <span class="nf">fdr</span><span class="p">(</span><span class="n">pvals</span><span class="p">,</span> <span class="n">qlevel</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;original&#39;</span><span class="p">,</span> <span class="n">adj_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">adj_args</span><span class="o">=</span><span class="p">{}):</span>
    <span class="sd">&#39;&#39;&#39; Determine significance based on the FDR approach</span>
<span class="sd">    </span>
<span class="sd">    The false discovery rate is a method of conceptualizing the rate of type I errors in null hypothesis testing when conducting multiple comparisons. </span>
<span class="sd">    Translated from fdr.R by Dr. Chris Paciorek </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    pvals : list or array</span>
<span class="sd">        A vector of p-values on which to conduct the multiple testing.</span>

<span class="sd">    qlevel : float</span>
<span class="sd">        The proportion of false positives desired.</span>

<span class="sd">    method : {&#39;original&#39;, &#39;general&#39;}</span>
<span class="sd">        Method for performing the testing.</span>
<span class="sd">            - &#39;original&#39; follows Benjamini &amp; Hochberg (1995);</span>
<span class="sd">            - &#39;general&#39; is much more conservative, requiring no assumptions on the p-values (see Benjamini &amp; Yekutieli (2001)).</span>
<span class="sd">            &#39;original&#39; is recommended, and if desired, using &#39;adj_method=&quot;mean&quot;&#39; to increase power.</span>

<span class="sd">    adj_method: {&#39;mean&#39;, &#39;storey&#39;, &#39;two-stage&#39;}</span>
<span class="sd">        Method for increasing the power of the procedure by estimating the proportion of alternative p-values.</span>
<span class="sd">            - &#39;mean&#39;, the modified Storey estimator in Ventura et al. (2004)</span>
<span class="sd">            - &#39;storey&#39;, the method of Storey (2002)</span>
<span class="sd">            - &#39;two-stage&#39;, the iterative approach of Benjamini et al. (2001)</span>

<span class="sd">    adj_args : dict</span>
<span class="sd">        Arguments for adj_method; see prop_alt() for description,</span>
<span class="sd">        but note that for &quot;two-stage&quot;, qlevel and fdr_method are taken from the qlevel and method arguments for fdr()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    fdr_res : array or None</span>
<span class="sd">        A vector of the indices of the significant tests; None if no significant tests</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    - fdr.R by Dr. Chris Paciorek: https://www.stat.berkeley.edu/~paciorek/research/code/code.html</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pvals</span><span class="p">)</span>

    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">adj_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">adj_method</span> <span class="o">==</span> <span class="s1">&#39;two-stage&#39;</span><span class="p">:</span>
            <span class="n">qlevel</span> <span class="o">=</span> <span class="n">qlevel</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">qlevel</span><span class="p">)</span>  <span class="c1"># see Benjamini et al. (2001) for proof that this controls the FDR at level qlevel</span>
            <span class="n">adj_args</span><span class="p">[</span><span class="s1">&#39;qlevel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qlevel</span>
            <span class="n">adj_args</span><span class="p">[</span><span class="s1">&#39;fdr_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">method</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Adjusting cutoff using two-stage method, with method: </span><span class="si">{</span><span class="n">adj_args</span><span class="p">[</span><span class="s2">&quot;fdr_method&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">; qlevel: </span><span class="si">{</span><span class="n">adj_args</span><span class="p">[</span><span class="s2">&quot;qlevel&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">adj_method</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">adj_args</span> <span class="o">==</span> <span class="p">{}:</span>
                 <span class="c1"># default arguments for &quot;mean&quot; method of Ventura et al. (2004)</span>
                <span class="n">adj_args</span><span class="p">[</span><span class="s1">&#39;edf_lower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.8</span>
                <span class="n">adj_args</span><span class="p">[</span><span class="s1">&#39;num_steps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Adjusting cutoff using mean method, with edf_lower: </span><span class="si">{</span><span class="n">adj_args</span><span class="p">[</span><span class="s2">&quot;edf_lower&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">; num_steps: </span><span class="si">{</span><span class="n">adj_args</span><span class="p">[</span><span class="s2">&quot;num_steps&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">prop_alt</span><span class="p">(</span><span class="n">pvals</span><span class="p">,</span> <span class="n">adj_method</span><span class="p">,</span> <span class="n">adj_args</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># all hypotheses are estimated to be alternatives</span>
        <span class="n">fdr_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qlevel</span> <span class="o">=</span> <span class="n">qlevel</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># adjust for estimate of a; default is 0</span>
        <span class="n">fdr_res</span> <span class="o">=</span> <span class="n">fdr_master</span><span class="p">(</span><span class="n">pvals</span><span class="p">,</span> <span class="n">qlevel</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fdr_res</span></div>

<span class="c1">#-----------</span>
<span class="c1"># Utilities</span>
<span class="c1">#-----------</span>

<div class="viewcode-block" id="corr_ttest"><a class="viewcode-back" href="../../../utils/correlation/corr_ttest.html#pyleoclim.utils.correlation.corr_ttest">[docs]</a><span class="k">def</span> <span class="nf">corr_ttest</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Estimates the significance of correlations between 2 time series using</span>
<span class="sd">    the classical T-test adjusted for effective sample size.</span>
<span class="sd">    </span>
<span class="sd">    The degrees of freedom are adjusted following n_eff=n(1-g)/(1+g) where g is the lag-1 autocorrelation. </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    y1 : array</span>
<span class="sd">        vectors of (real) numbers with identical length, no NaNs allowed</span>
<span class="sd">        </span>
<span class="sd">    y2 : array</span>
<span class="sd">        vectors of (real) numbers with identical length, no NaNs allowed</span>
<span class="sd">        </span>
<span class="sd">    alpha : float</span>
<span class="sd">        significance level for critical value estimation [default: 0.05]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    r : float</span>
<span class="sd">         correlation between x and y</span>
<span class="sd">         </span>
<span class="sd">    signif : bool</span>
<span class="sd">        true (1) if significant; false (0) otherwise</span>
<span class="sd">        </span>
<span class="sd">    pval : float</span>
<span class="sd">        test p-value (the probability of the test statistic exceeding the observed one by chance alone)</span>
<span class="sd">        </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    corr_isopersist : Estimate Pearson&#39;s correlation and associated significance using AR(1)</span>
<span class="sd">    </span>
<span class="sd">    corr_isospec : Estimate Pearson&#39;s correlation and associated significance using phase randomization</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">pearsonr</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">g1</span> <span class="o">=</span> <span class="n">sm_ar1_fit</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span>
    <span class="n">g2</span> <span class="o">=</span> <span class="n">sm_ar1_fit</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span>

    <span class="n">Ney1</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">g1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">g1</span><span class="p">)</span>
    <span class="n">Ney2</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">g2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">g2</span><span class="p">)</span>

    <span class="n">Ne</span> <span class="o">=</span> <span class="n">gmean</span><span class="p">([</span><span class="n">Ney1</span><span class="o">+</span><span class="n">Ney2</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">Ne</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;Too few effective d.o.f. to apply this method!&#39;</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">Ne</span> <span class="o">-</span> <span class="mi">2</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">df</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

    <span class="n">pval</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">stu</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">df</span><span class="p">)</span>

    <span class="n">signif</span> <span class="o">=</span> <span class="n">pval</span> <span class="o">&lt;=</span> <span class="n">alpha</span>

    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">signif</span><span class="p">,</span> <span class="n">pval</span></div>

<div class="viewcode-block" id="corr_isopersist"><a class="viewcode-back" href="../../../utils/correlation/corr_isopersist.html#pyleoclim.utils.correlation.corr_isopersist">[docs]</a><span class="k">def</span> <span class="nf">corr_isopersist</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">nsim</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Computes the Pearson&#39;s correlation between two timeseries, and their significance using Ar(1) modeling.</span>
<span class="sd">    </span>
<span class="sd">    The significance is gauged via a non-parametric (Monte Carlo) simulation of</span>
<span class="sd">    correlations with nsim AR(1) processes with identical persistence</span>
<span class="sd">    properties as x and y ; the measure of which is the lag-1 autocorrelation (g).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    y1 : array</span>
<span class="sd">        vectors of (real) numbers with identical length, no NaNs allowed</span>
<span class="sd">        </span>
<span class="sd">    y2 : array</span>
<span class="sd">        vectors of (real) numbers with identical length, no NaNs allowed</span>
<span class="sd">        </span>
<span class="sd">    alpha : float</span>
<span class="sd">        significance level for critical value estimation [default: 0.05]</span>
<span class="sd">        </span>
<span class="sd">    nsim : int</span>
<span class="sd">        number of simulations [default: 1000]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    r : float</span>
<span class="sd">        correlation between x and y</span>
<span class="sd">        </span>
<span class="sd">    signif : bool</span>
<span class="sd">        true (1) if significant; false (0) otherwise</span>
<span class="sd">        </span>
<span class="sd">    pval : float</span>
<span class="sd">        test p-value (the probability of the test statstic exceeding the observed one by chance alone)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The probability of obtaining a test statistic at least as extreme as the one actually observed,</span>
<span class="sd">    assuming that the null hypothesis is true.</span>
<span class="sd">    The test is 1 tailed on |r|: Ho = { |r| = 0 }, Ha = { |r| &gt; 0 }</span>
<span class="sd">    The test is rejected (signif = 1) if pval &lt;= alpha, otherwise signif=0;</span>
<span class="sd">    (Some Rights Reserved) Hepta Technologies, 2009</span>
<span class="sd">    v1.0 USC, Aug 10 2012, based on corr_signif.</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    corr_ttest: Estimates Pearson&#39;s correlation and associated significance using a t-test.</span>
<span class="sd">    </span>
<span class="sd">    corr_isospec : Estimates Pearson&#39;s correlation and associated significance using </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">pearsonr</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="n">y1_red</span><span class="p">,</span> <span class="n">g1</span> <span class="o">=</span> <span class="n">isopersistent_rn</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">nsim</span><span class="p">)</span>
    <span class="n">y2_red</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">isopersistent_rn</span><span class="p">(</span><span class="n">y2</span><span class="p">,</span> <span class="n">nsim</span><span class="p">)</span>

    <span class="n">rs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nsim</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nsim</span><span class="p">):</span>
        <span class="n">rs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pearsonr</span><span class="p">(</span><span class="n">y1_red</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">y2_red</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">rsa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span>

    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">ra</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rsa</span><span class="p">)]),</span> <span class="mi">200</span><span class="p">)</span>
    <span class="n">kde</span> <span class="o">=</span> <span class="n">gaussian_kde</span><span class="p">(</span><span class="n">rsa</span><span class="p">)</span>
    <span class="n">prob</span> <span class="o">=</span> <span class="n">kde</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ra</span> <span class="o">-</span> <span class="n">xi</span><span class="p">)</span>
    <span class="c1">#  min_diff = np.min(diff)</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>

    <span class="n">pval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">prob</span><span class="p">[</span><span class="n">pos</span><span class="p">:],</span> <span class="n">xi</span><span class="p">[</span><span class="n">pos</span><span class="p">:])</span>

    <span class="n">rcrit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">rsa</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">))</span>
    <span class="n">signif</span> <span class="o">=</span> <span class="n">ra</span> <span class="o">&gt;=</span> <span class="n">rcrit</span>

    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">signif</span><span class="p">,</span> <span class="n">pval</span></div>

<div class="viewcode-block" id="isopersistent_rn"><a class="viewcode-back" href="../../../utils/correlation/isopersistent_rn.html#pyleoclim.utils.correlation.isopersistent_rn">[docs]</a><span class="k">def</span> <span class="nf">isopersistent_rn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Generates p realization of a red noise [i.e. AR(1)] process</span>
<span class="sd">    with same persistence properties as X (Mean and variance are also preserved).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    X : array</span>
<span class="sd">        vector of (real) numbers as a time series, no NaNs allowed</span>
<span class="sd">    p : int</span>
<span class="sd">        number of simulations</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    red : numpy array</span>
<span class="sd">        n rows by p columns matrix of an AR1 process, where n is the size of X</span>
<span class="sd">    g :float</span>
<span class="sd">        lag-1 autocorrelation coefficient</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    (Some Rights Reserved) Hepta Technologies, 2008</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">sm_ar1_fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="c1">#  red = red_noise(N, M, g)</span>
    <span class="n">red</span> <span class="o">=</span> <span class="n">sm_ar1_sim</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">red</span><span class="p">,</span> <span class="n">g</span></div>

<div class="viewcode-block" id="sm_ar1_fit"><a class="viewcode-back" href="../../../utils/correlation/sm_ar1_fit.html#pyleoclim.utils.correlation.sm_ar1_fit">[docs]</a><span class="k">def</span> <span class="nf">sm_ar1_fit</span><span class="p">(</span><span class="n">ys</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the lag-1 autocorrelation from ar1 fit using statsmodels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        vector of (real) numbers as a time series</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    g :float</span>
<span class="sd">        lag-1 autocorrelation coefficient</span>
<span class="sd">    &#39;&#39;&#39;</span>


    <span class="n">ar1_mod</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">tsa</span><span class="o">.</span><span class="n">AR</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;drop&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">maxlag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">ar1_mod</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">g</span></div>

<div class="viewcode-block" id="sm_ar1_sim"><a class="viewcode-back" href="../../../utils/correlation/sm_ar1_sim.html#pyleoclim.utils.correlation.sm_ar1_sim">[docs]</a><span class="k">def</span> <span class="nf">sm_ar1_sim</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Produce p realizations of an AR1 process of length n with lag-1 autocorrelation g using statsmodels</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    n : int</span>
<span class="sd">        row dimensions</span>
<span class="sd">    p : int</span>
<span class="sd">        column dimensions</span>

<span class="sd">    g : float</span>
<span class="sd">        lag-1 autocorrelation coefficient</span>
<span class="sd">        </span>
<span class="sd">    sig : float</span>
<span class="sd">        the standard deviation of the original time series</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    red : numpy matrix</span>
<span class="sd">        n rows by p columns matrix of an AR1 process</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># specify model parameters (statsmodel wants lag0 coefficents as unity)</span>
    <span class="n">ar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">g</span><span class="p">]</span>  <span class="c1"># AR model parameter</span>
    <span class="n">ma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span> <span class="c1"># MA model parameters</span>
    <span class="n">sig_n</span> <span class="o">=</span> <span class="n">sig</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">g</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># theoretical noise variance for red to achieve the same variance as X</span>

    <span class="n">red</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="c1"># declare array</span>

    <span class="c1"># simulate AR(1) model for each column</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="n">red</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">tsa</span><span class="o">.</span><span class="n">arma_generate_sample</span><span class="p">(</span><span class="n">ar</span><span class="o">=</span><span class="n">ar</span><span class="p">,</span> <span class="n">ma</span><span class="o">=</span><span class="n">ma</span><span class="p">,</span> <span class="n">nsample</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">burnin</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sig_n</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">red</span></div>

<div class="viewcode-block" id="red_noise"><a class="viewcode-back" href="../../../utils/correlation/red_noise.html#pyleoclim.utils.correlation.red_noise">[docs]</a><span class="k">def</span> <span class="nf">red_noise</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Produce M realizations of an AR1 process of length N with lag-1 autocorrelation g</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    N : int</span>
<span class="sd">        row dimensions</span>
<span class="sd">        </span>
<span class="sd">    M : int</span>
<span class="sd">        column dimensions</span>
<span class="sd">        </span>
<span class="sd">    g : float</span>
<span class="sd">        lag-1 autocorrelation coefficient</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    red : numpy array</span>
<span class="sd">        N rows by M columns matrix of an AR1 process</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    (Some Rights Reserved) Hepta Technologies, 2008</span>
<span class="sd">    J.E.G., GaTech, Oct 20th 2008</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">red</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">))</span>
    <span class="n">red</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">red</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">g</span> <span class="o">*</span> <span class="n">red</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">red</span></div>

<div class="viewcode-block" id="corr_isospec"><a class="viewcode-back" href="../../../utils/correlation/corr_isospec.html#pyleoclim.utils.correlation.corr_isospec">[docs]</a><span class="k">def</span> <span class="nf">corr_isospec</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">nsim</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Estimates the significance of the correlation using phase randomization</span>

<span class="sd">    Estimates the significance of correlations between non IID</span>
<span class="sd">    time series by phase randomization of original inputs.</span>
<span class="sd">    This function creates &#39;nsim&#39; random time series that have the same power</span>
<span class="sd">    spectrum as the original time series but random phases.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    y1 : array</span>
<span class="sd">        vectors of (real) numbers with identical length, no NaNs allowed</span>
<span class="sd">        </span>
<span class="sd">    y2 : array</span>
<span class="sd">        vectors of (real) numbers with identical length, no NaNs allowed</span>
<span class="sd">        </span>
<span class="sd">    alpha : float</span>
<span class="sd">        significance level for critical value estimation [default: 0.05]</span>
<span class="sd">        </span>
<span class="sd">    nsim : int</span>
<span class="sd">        number of simulations [default: 1000]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    r : float</span>
<span class="sd">        correlation between y1 and y2</span>
<span class="sd">        </span>
<span class="sd">    signif : bool</span>
<span class="sd">        true (1) if significant; false (0) otherwise</span>
<span class="sd">        </span>
<span class="sd">    F : float</span>
<span class="sd">        Fraction of time series with higher correlation coefficents than observed (approximates the p-value).</span>

<span class="sd">    References</span>
<span class="sd">    ---------</span>

<span class="sd">    - Ebisuzaki, W, 1997: A method to estimate the statistical</span>
<span class="sd">    significance of a correlation when the data are serially correlated.</span>
<span class="sd">    J. of Climate, 10, 2147-2153.</span>
<span class="sd">    </span>
<span class="sd">    - Prichard, D., Theiler, J. Generating Surrogate Data for Time Series</span>
<span class="sd">    with Several Simultaneously Measured Variables (1994)</span>
<span class="sd">    Physical Review Letters, Vol 73, Number 7</span>
<span class="sd">    (Some Rights Reserved) USC Climate Dynamics Lab, 2012.</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    corr_ttest : Estimates Pearson&#39;s correlation and associated significance using a t-test</span>
<span class="sd">    </span>
<span class="sd">    corr_isopersist : Estimates Pearson&#39;s correlation and associated significance using AR(1) simulations</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">pearsonr</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># generate phase-randomized samples using the Theiler &amp; Prichard method</span>
    <span class="n">Y1surr</span> <span class="o">=</span> <span class="n">phaseran</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">nsim</span><span class="p">)</span>
    <span class="n">Y2surr</span> <span class="o">=</span> <span class="n">phaseran</span><span class="p">(</span><span class="n">y2</span><span class="p">,</span> <span class="n">nsim</span><span class="p">)</span>

    <span class="c1"># compute correlations</span>
    <span class="n">Y1s</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">Y1surr</span><span class="p">)</span>
    <span class="n">Y2s</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">Y2surr</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Y1s</span><span class="p">),</span> <span class="n">Y2s</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rSim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

    <span class="c1"># compute fraction of values higher than observed</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rSim</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">/</span> <span class="n">nsim</span>

    <span class="c1"># establish significance</span>
    <span class="n">signif</span> <span class="o">=</span> <span class="n">F</span> <span class="o">&lt;</span> <span class="n">alpha</span>  <span class="c1"># significant or not?</span>

    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">signif</span><span class="p">,</span> <span class="n">F</span></div>

<div class="viewcode-block" id="phaseran"><a class="viewcode-back" href="../../../utils/correlation/phaseran.html#pyleoclim.utils.correlation.phaseran">[docs]</a><span class="k">def</span> <span class="nf">phaseran</span><span class="p">(</span><span class="n">recblk</span><span class="p">,</span> <span class="n">nsurr</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Simultaneous phase randomization of a set of time series</span>
<span class="sd">    </span>
<span class="sd">    It creates blocks of surrogate data with the same second order properties as the original</span>
<span class="sd">    time series dataset by transforming the oriinal data into the frequency domain, randomizing the</span>
<span class="sd">    phases simultaneoulsy across the time series and converting the data back into the time domain. </span>
<span class="sd">    </span>
<span class="sd">    Written by Carlos Gias for MATLAB</span>

<span class="sd">    http://www.mathworks.nl/matlabcentral/fileexchange/32621-phase-randomization/content/phaseran.m</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    recblk : numpy array</span>
<span class="sd">        2D array , Row: time sample. Column: recording.</span>
<span class="sd">        An odd number of time samples (height) is expected.</span>
<span class="sd">        If that is not the case, recblock is reduced by 1 sample before the surrogate data is created.</span>
<span class="sd">        The class must be double and it must be nonsparse.</span>
<span class="sd">    </span>
<span class="sd">    nsurr : int</span>
<span class="sd">        is the number of image block surrogates that you want to generate.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    surrblk : numpy array</span>
<span class="sd">        3D multidimensional array image block with the surrogate datasets along the third dimension</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    - Prichard, D., Theiler, J. Generating Surrogate Data for Time Series with Several Simultaneously Measured Variables (1994)</span>
<span class="sd">    Physical Review Letters, Vol 73, Number 7</span>
<span class="sd">    </span>
<span class="sd">    - Carlos Gias (2020). Phase randomization, MATLAB Central File Exchange</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Get parameters</span>
    <span class="n">nfrms</span> <span class="o">=</span> <span class="n">recblk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">nfrms</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">nfrms</span> <span class="o">=</span> <span class="n">nfrms</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">recblk</span> <span class="o">=</span> <span class="n">recblk</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nfrms</span><span class="p">]</span>

    <span class="n">len_ser</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">nfrms</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">interv1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">len_ser</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">interv2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">len_ser</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nfrms</span><span class="p">)</span>

    <span class="c1"># Fourier transform of the original dataset</span>
    <span class="n">fft_recblk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">recblk</span><span class="p">)</span>

    <span class="n">surrblk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nfrms</span><span class="p">,</span> <span class="n">nsurr</span><span class="p">))</span>

    <span class="c1">#  for k in tqdm(np.arange(nsurr)):</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nsurr</span><span class="p">):</span>
        <span class="n">ph_rnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">len_ser</span><span class="p">)</span>

        <span class="c1"># Create the random phases for all the time series</span>
        <span class="n">ph_interv1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">ph_rnd</span><span class="p">)</span>
        <span class="n">ph_interv2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">ph_interv1</span><span class="p">))</span>

        <span class="c1"># Randomize all the time series simultaneously</span>
        <span class="n">fft_recblk_surr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">fft_recblk</span><span class="p">)</span>
        <span class="n">fft_recblk_surr</span><span class="p">[</span><span class="n">interv1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fft_recblk</span><span class="p">[</span><span class="n">interv1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ph_interv1</span>
        <span class="n">fft_recblk_surr</span><span class="p">[</span><span class="n">interv2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fft_recblk</span><span class="p">[</span><span class="n">interv2</span><span class="p">]</span> <span class="o">*</span> <span class="n">ph_interv2</span>

        <span class="c1"># Inverse transform</span>
        <span class="n">surrblk</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">fft_recblk_surr</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">surrblk</span></div>

<span class="sd">&#39;&#39;&#39; The FDR procedures translated from fdr.R by Dr. Chris Paciorek (https://www.stat.berkeley.edu/~paciorek/research/code/code.html)</span>
<span class="sd">&#39;&#39;&#39;</span>
<div class="viewcode-block" id="fdr_basic"><a class="viewcode-back" href="../../../utils/correlation/fdr_basic.html#pyleoclim.utils.correlation.fdr_basic">[docs]</a><span class="k">def</span> <span class="nf">fdr_basic</span><span class="p">(</span><span class="n">pvals</span><span class="p">,</span><span class="n">qlevel</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; The basic FDR of Benjamini &amp; Hochberg (1995).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    pvals : list or array</span>
<span class="sd">        A vector of p-values on which to conduct the multiple testing.</span>

<span class="sd">    qlevel : float</span>
<span class="sd">        The proportion of false positives desired.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    fdr_res : array or None</span>
<span class="sd">        A vector of the indices of the significant tests; None if no significant tests</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    - Benjamini, Yoav; Hochberg, Yosef (1995). &quot;Controlling the false discovery rate: a practical and powerful approach to multiple testing&quot;. Journal of the Royal Statistical Society, Series B. 57 (1): 289300. MR 1325392</span>
<span class="sd">    </span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pvals</span><span class="p">)</span>
    <span class="n">sorted_pvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">pvals</span><span class="p">)</span>
    <span class="n">sort_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">pvals</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">sorted_pvals</span> <span class="o">&lt;=</span> <span class="n">qlevel</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>
    <span class="n">num_reject</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_reject</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_reject</span><span class="p">)</span>
        <span class="n">fdr_res</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sort_index</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fdr_res</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">fdr_res</span></div>

<div class="viewcode-block" id="fdr_master"><a class="viewcode-back" href="../../../utils/correlation/fdr_master.html#pyleoclim.utils.correlation.fdr_master">[docs]</a><span class="k">def</span> <span class="nf">fdr_master</span><span class="p">(</span><span class="n">pvals</span><span class="p">,</span> <span class="n">qlevel</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;original&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Perform various versions of the FDR procedure</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    pvals : list or array</span>
<span class="sd">        A vector of p-values on which to conduct the multiple testing.</span>

<span class="sd">    qlevel : float</span>
<span class="sd">        The proportion of false positives desired.</span>

<span class="sd">    method : {&#39;original&#39;, &#39;general&#39;}</span>
<span class="sd">        Method for performing the testing.</span>
<span class="sd">        - &#39;original&#39; follows Benjamini &amp; Hochberg (1995);</span>
<span class="sd">        - &#39;general&#39; is much more conservative, requiring no assumptions on the p-values (see Benjamini &amp; Yekutieli (2001)).</span>
<span class="sd">        We recommend using &#39;original&#39;, and if desired, using &#39;adj_method=&quot;mean&quot;&#39; to increase power.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    fdr_res : array or None</span>
<span class="sd">        A vector of the indices of the significant tests; None if no significant tests</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    - Benjamini, Yoav; Hochberg, Yosef (1995). &quot;Controlling the false discovery rate: a practical and powerful approach to multiple testing&quot;. Journal of the Royal Statistical Society, Series B. 57 (1): 289300. MR 1325392</span>
<span class="sd">    </span>
<span class="sd">    - Benjamini, Yoav; Yekutieli, Daniel (2001). &quot;The control of the false discovery rate in multiple testing under dependency&quot;. Annals of Statistics. 29 (4): 11651188. doi:10.1214/aos/1013699998 </span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;general&#39;</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pvals</span><span class="p">)</span>
        <span class="n">qlevel</span> <span class="o">=</span> <span class="n">qlevel</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">fdr_res</span> <span class="o">=</span> <span class="n">fdr_basic</span><span class="p">(</span><span class="n">pvals</span><span class="p">,</span> <span class="n">qlevel</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fdr_res</span></div>

<div class="viewcode-block" id="storey"><a class="viewcode-back" href="../../../utils/correlation/storey.html#pyleoclim.utils.correlation.storey">[docs]</a><span class="k">def</span> <span class="nf">storey</span><span class="p">(</span><span class="n">edf_quantile</span><span class="p">,</span> <span class="n">pvals</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; The basic Storey (2002) estimator of a, the proportion of alternative hypotheses.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    edf_quantile : float</span>
<span class="sd">        The quantile of the empirical distribution function at which to estimate a.</span>

<span class="sd">    pvals : list or array</span>
<span class="sd">        A vector of p-values on which to estimate a</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    a : int</span>
<span class="sd">        estimate of a, the number of alternative hypotheses</span>
<span class="sd">        </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    - Storey, J.D., 2002, A direct approach to False Discovery Rates. Journal of the Royal Statistical Society, Series B, 64, 3, 479-498</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">edf_quantile</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">edf_quantile</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Wrong edf_quantile: </span><span class="si">{</span><span class="n">edf_quantile</span><span class="si">}</span><span class="s1">; must be within (0, 1)!&#39;</span><span class="p">)</span>

    <span class="n">pvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pvals</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pvals</span><span class="o">&lt;=</span><span class="n">edf_quantile</span><span class="p">)</span> <span class="o">-</span> <span class="n">edf_quantile</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">edf_quantile</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># set to 0 if a is negative</span>
    <span class="k">return</span> <span class="n">a</span></div>

<div class="viewcode-block" id="prop_alt"><a class="viewcode-back" href="../../../utils/correlation/prop_alt.html#pyleoclim.utils.correlation.prop_alt">[docs]</a><span class="k">def</span> <span class="nf">prop_alt</span><span class="p">(</span><span class="n">pvals</span><span class="p">,</span> <span class="n">adj_method</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">adj_args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;edf_lower&#39;</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">,</span> <span class="s1">&#39;num_steps&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">}):</span>
    <span class="sd">&#39;&#39;&#39; Calculate an estimate of a, the proportion of alternative hypotheses, using one of several methods</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    pvals : list or array</span>
<span class="sd">        A vector of p-values on which to estimate a</span>


<span class="sd">    adj_method: {&#39;mean&#39;, &#39;storey&#39;, &#39;two-stage&#39;}</span>
<span class="sd">        Method for increasing the power of the procedure by estimating the proportion of alternative p-values.</span>
<span class="sd">        - &#39;mean&#39;, the modified Storey estimator that we suggest in Ventura et al. (2004)</span>
<span class="sd">        - &#39;storey&#39;, the method of Storey (2002)</span>
<span class="sd">        - &#39;two-stage&#39;, the iterative approach of Benjamini et al. (2001)</span>

<span class="sd">    adj_args : dict</span>
<span class="sd">        - for &quot;mean&quot;, specify &quot;edf_lower&quot;, the smallest quantile at which to estimate a, and &quot;num_steps&quot;, the number of quantiles to use</span>
<span class="sd">          the approach uses the average of the Storey (2002) estimator for the num_steps quantiles starting at &quot;edf_lower&quot; and finishing just less than 1</span>
<span class="sd">        - for &quot;storey&quot;, specify &quot;edf_quantile&quot;, the quantile at which to calculate the estimator</span>
<span class="sd">        - for &quot;two-stage&quot;, the method uses a standard FDR approach to estimate which p-values are significant</span>
<span class="sd">          this number is the estimate of a; therefore the method requires specification of qlevel,</span>
<span class="sd">          the proportion of false positives and &quot;fdr_method&quot; (&#39;original&#39; or &#39;general&#39;), the FDR method to be used.</span>
<span class="sd">          We do not recommend &#39;general&#39; as this is very conservative and will underestimate a.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    a : int</span>
<span class="sd">        estimate of a, the number of alternative hypotheses</span>
<span class="sd">    </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    - Storey, J.D. (2002). A direct approach to False Discovery Rates. Journal of the Royal Statistical Society, Series B, 64, 3, 479-498</span>
<span class="sd">    </span>
<span class="sd">    - Benjamini, Yoav; Yekutieli, Daniel (2001). &quot;The control of the false discovery rate in multiple testing under dependency&quot;. Annals of Statistics. 29 (4): 11651188. doi:10.1214/aos/1013699998 </span>
<span class="sd">    </span>
<span class="sd">    - Ventura, V., Paciorek, C., Risbey, J.S. (2004). Controlling the proportion of falsely rejected hypotheses when conducting multiple tests with climatological data. Journal of climate, 17, 4343-4356</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pvals</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">adj_method</span> <span class="o">==</span> <span class="s1">&#39;two-stage&#39;</span><span class="p">:</span>
        <span class="n">fdr_res</span> <span class="o">=</span> <span class="n">fdr_master</span><span class="p">(</span><span class="n">pvals</span><span class="p">,</span> <span class="n">adj_method</span><span class="p">[</span><span class="s1">&#39;qlevel&#39;</span><span class="p">],</span> <span class="n">adj_args</span><span class="p">[</span><span class="s1">&#39;fdr_method&#39;</span><span class="p">])</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fdr_res</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="k">elif</span> <span class="n">adj_method</span> <span class="o">==</span> <span class="s1">&#39;storey&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;edf_quantile&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adj_args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`edf_quantile` must be specified in `adj_args`!&#39;</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">storey</span><span class="p">(</span><span class="n">adj_args</span><span class="p">[</span><span class="s1">&#39;edf_quantile&#39;</span><span class="p">],</span> <span class="n">pvals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="k">elif</span> <span class="n">adj_method</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">adj_args</span><span class="p">[</span><span class="s1">&#39;edf_lower&#39;</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">adj_args</span><span class="p">[</span><span class="s1">&#39;edf_lower&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Wrong edf_lower: </span><span class="si">{</span><span class="n">adj_args</span><span class="p">[</span><span class="s2">&quot;edf_lower&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">; must be within (0, 1)!&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">adj_args</span><span class="p">[</span><span class="s1">&#39;num_steps&#39;</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">adj_args</span><span class="p">[</span><span class="s1">&#39;num_steps&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Wrong num_steps: </span><span class="si">{</span><span class="n">adj_args</span><span class="p">[</span><span class="s2">&quot;num_steps&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">; must be an integer &gt;= 1&#39;</span><span class="p">)</span>

        <span class="n">stepsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">adj_args</span><span class="p">[</span><span class="s1">&#39;edf_lower&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="n">adj_args</span><span class="p">[</span><span class="s1">&#39;num_steps&#39;</span><span class="p">]</span>

        <span class="n">edf_quantiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">adj_args</span><span class="p">[</span><span class="s1">&#39;edf_lower&#39;</span><span class="p">],</span> <span class="n">adj_args</span><span class="p">[</span><span class="s1">&#39;edf_lower&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">stepsize</span><span class="o">*</span><span class="p">(</span><span class="n">adj_args</span><span class="p">[</span><span class="s1">&#39;num_steps&#39;</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">adj_args</span><span class="p">[</span><span class="s1">&#39;num_steps&#39;</span><span class="p">])</span>
        <span class="n">a_vec</span> <span class="o">=</span> <span class="p">[</span><span class="n">storey</span><span class="p">(</span><span class="n">edf_q</span><span class="p">,</span> <span class="n">pvals</span><span class="p">)</span> <span class="k">for</span> <span class="n">edf_q</span> <span class="ow">in</span> <span class="n">edf_quantiles</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a_vec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Wrong method: </span><span class="si">{method}</span><span class="s1">!&#39;</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2017-2020, Deborah Khider, Feng Zhu, Julien Emile-Geay

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>