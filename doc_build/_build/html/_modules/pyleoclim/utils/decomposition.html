

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyleoclim.utils.decomposition &mdash; Pyleoclim 0.6.2beta documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/rtd_sphinx_search.min.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/js/rtd_sphinx_search.min.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> Pyleoclim
          

          
            
            <img src="../../../_static/pyleoclim_insigna_full_white.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.6.2beta
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Working with Pyleoclim</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing Pyleoclim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../core/ui.html">The Pyleoclim User Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
</ul>
<p class="caption"><span class="caption-text">Advanced functionalities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../utils/introduction.html">Pyleoclim Utilities (pyleoclim.utils)</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting Involved</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../citation.html">Citing Pyleoclim</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Pyleoclim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pyleoclim.utils.decomposition</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyleoclim.utils.decomposition</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Tue Feb 25 06:29:36 2020</span>

<span class="sd">@author: deborahkhider</span>
<span class="sd">Contains eigendecomposition methods:</span>
<span class="sd">Principal Component Analysis, Singular Spectrum Analysis, Multi-channel SSA</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;mcpca&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pca&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ssa&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mssa&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">.tsutils</span> <span class="kn">import</span> <span class="n">standardize</span>
<span class="kn">from</span> <span class="nn">.tsmodel</span> <span class="kn">import</span> <span class="n">ar1_sim</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eigh</span><span class="p">,</span> <span class="n">toeplitz</span>
<span class="kn">from</span> <span class="nn">nitime</span> <span class="kn">import</span> <span class="n">algorithms</span> <span class="k">as</span> <span class="n">alg</span>
<span class="kn">from</span> <span class="nn">statsmodels.multivariate.pca</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="c1">#------</span>
<span class="c1"># Main functions</span>
<span class="c1">#------</span>

<span class="k">def</span> <span class="nf">mcpca</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">nMC</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="o">**</span><span class="n">pca_kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Monte-Carlo Principal Component Analysis </span>
<span class="sd">    </span>
<span class="sd">    Carries out Principal Component Analysis  (most unfortunately named EOF analysis in the meteorology</span>
<span class="sd">    and climate literature) on a data matrix ys.  </span>
<span class="sd">    If NaNs are present, they will be infilled via the EM algorithm.</span>
<span class="sd">    </span>
<span class="sd">    The significance of eigenvalues is gauged against those of AR(1) surrogates fit to the data.</span>
<span class="sd">              </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ys : 2D numpy array (nt, nrec)</span>
<span class="sd">        nt   = number of time samples (assumed identical for all records)</span>
<span class="sd">        nrec = number of records (aka variables, channels, etc)</span>
<span class="sd">        </span>
<span class="sd">    nMC : int </span>
<span class="sd">        the number of Monte-Carlo simulations</span>
<span class="sd">    </span>
<span class="sd">    pca_kwargs : tuple </span>
<span class="sd">        keyword arguments for the PCA method</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : dict containing:</span>
<span class="sd">        </span>
<span class="sd">        - eigvals : eigenvalues (nrec,)</span>

<span class="sd">        - eigvals95 : eigenvalues of the AR(1) ensemble (nrec, nMC)</span>

<span class="sd">        - pcs : PC series of all components (nt, rec)</span>

<span class="sd">        - eofs : EOFs of all components (nrec, nrec)</span>
<span class="sd">    </span>
<span class="sd">    References:</span>
<span class="sd">    ----------    </span>
<span class="sd">    Deininger, M., McDermott, F., Mudelsee, M. et al. (2017): Coherency of late Holocene </span>
<span class="sd">    European speleothem δ18O records linked to North Atlantic Ocean circulation. </span>
<span class="sd">    Climate Dynamics, 49, 595–618. https://doi.org/10.1007/s00382-016-3360-8</span>

<span class="sd">    Written by Jun Hu (Rice University).</span>
<span class="sd">    Adapted for pyleoclim by Julien Emile-Geay (USC)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">nt</span><span class="p">,</span> <span class="n">nrec</span> <span class="o">=</span> <span class="n">ys</span><span class="o">.</span><span class="n">shape</span>
    
    <span class="n">pc_mc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nt</span><span class="p">,</span><span class="n">nrec</span><span class="p">))</span> <span class="c1"># principal components</span>
    <span class="n">eof_mc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nrec</span><span class="p">,</span><span class="n">nrec</span><span class="p">))</span>  <span class="c1">#eof (spatial loadings)</span>
    <span class="c1">#eigenvalue matrices</span>
    <span class="n">eigvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nrec</span><span class="p">))</span>
    <span class="n">eig_ar1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nrec</span><span class="p">,</span><span class="n">nMC</span><span class="p">))</span>

    <span class="c1"># apply PCA algorithm to the data matrix     </span>
    <span class="n">pc</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span><span class="n">ncomp</span><span class="o">=</span><span class="n">nrec</span><span class="p">,</span> <span class="o">**</span><span class="n">pca_kwargs</span><span class="p">)</span> <span class="c1"># TODO : implement EM infilling with missing = ‘fill-em’ </span>
    <span class="n">eigvals</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">eigenvals</span>
    
    <span class="c1"># generate surrogate matrix</span>
    <span class="n">y_ar1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">nt</span><span class="p">,</span><span class="n">nrec</span><span class="p">,</span><span class="n">nMC</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrec</span><span class="p">):</span>
        <span class="n">yi</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ys</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># generate nMC AR(1) surrogates</span>
        <span class="n">y_ar1</span><span class="p">[:,</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">ar1_sim</span><span class="p">(</span><span class="n">yi</span><span class="p">,</span> <span class="n">nMC</span><span class="p">)</span>
        <span class="c1"># assign PC and EOF matrices</span>
        <span class="k">if</span> <span class="n">pc</span><span class="o">.</span><span class="n">loadings</span><span class="p">[:,</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">eof_mc</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>  <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">loadings</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
            <span class="n">pc_mc</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>   <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">factors</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>   <span class="c1"># flip sign (arbitrary)</span>
            <span class="n">eof_mc</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>  <span class="o">=</span> <span class="o">-</span><span class="n">pc</span><span class="o">.</span><span class="n">loadings</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> 
            <span class="n">pc_mc</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>   <span class="o">=</span> <span class="o">-</span><span class="n">pc</span><span class="o">.</span><span class="n">factors</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
            
    <span class="c1"># loop over Monte Carlo iterations     </span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nMC</span><span class="p">):</span>    
        <span class="n">pc_ar1</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">y_ar1</span><span class="p">[:,:,</span><span class="n">m</span><span class="p">],</span><span class="n">ncomp</span><span class="o">=</span><span class="n">nrec</span><span class="p">,</span><span class="o">**</span><span class="n">pca_kwargs</span><span class="p">)</span>
        <span class="n">eig_ar1</span><span class="p">[:,</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc_ar1</span><span class="o">.</span><span class="n">eigenvals</span>
 
    <span class="n">eig95</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">eig_ar1</span><span class="p">,</span> <span class="mi">95</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                
    <span class="c1"># assign result</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;eigvals&#39;</span><span class="p">:</span> <span class="n">eigvals</span><span class="p">,</span> <span class="s1">&#39;eigvals95&#39;</span><span class="p">:</span> <span class="n">eig95</span><span class="p">,</span> <span class="s1">&#39;pcs&#39;</span><span class="p">:</span> <span class="n">pc_mc</span><span class="p">,</span> <span class="s1">&#39;eofs&#39;</span><span class="p">:</span> <span class="n">eof_mc</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">res</span>



<div class="viewcode-block" id="pca"><a class="viewcode-back" href="../../../utils/decomposition/pca.html#pyleoclim.utils.decomposition.pca">[docs]</a><span class="k">def</span> <span class="nf">pca</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span><span class="n">n_components</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">whiten</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">iterated_power</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span><span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Principal Component Analysis (Empirical Orthogonal Functions)</span>

<span class="sd">    Decomposition of a signal or data set in terms of orthogonal basis functions.</span>

<span class="sd">    From scikit-learn: https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        timeseries</span>

<span class="sd">    n_components : int,None,or str</span>
<span class="sd">         [default: None]</span>
<span class="sd">        Number of components to keep. if n_components is not set all components are kept:</span>
<span class="sd">        If n_components == &#39;mle&#39; and svd_solver == &#39;full&#39;, Minka’s MLE is used to guess the dimension. Use of n_components == &#39;mle&#39; will interpret svd_solver == &#39;auto&#39; as svd_solver == &#39;full&#39;.</span>
<span class="sd">        If 0 &lt; n_components &lt; 1 and svd_solver == &#39;full&#39;, select the number of components such that the amount of variance that needs to be explained is greater than the percentage specified by n_components.</span>
<span class="sd">        If svd_solver == &#39;arpack&#39;, the number of components must be strictly less than the minimum of n_features and n_samples.</span>

<span class="sd">    copy : bool,optional</span>
<span class="sd">        [default: True]</span>
<span class="sd">        If False, data passed to fit are overwritten and running fit(X).transform(X) will not yield the expected results, use fit_transform(X) instead.</span>

<span class="sd">    whiten : bool,optional</span>
<span class="sd">        [default: False]</span>
<span class="sd">        When True (False by default) the components_ vectors are multiplied by the square root of n_samples and then divided by the singular values to ensure uncorrelated outputs with unit component-wise variances.</span>

<span class="sd">    svd_solver : str {‘auto’, ‘full’, ‘arpack’, ‘randomized’}</span>
<span class="sd">        If auto :</span>
<span class="sd">            The solver is selected by a default policy based on X.shape and n_components: if the input data is larger than 500x500 and the number of components to extract is lower than 80% of the smallest dimension of the data, then the more efficient ‘randomized’ method is enabled.</span>
<span class="sd">            Otherwise the exact full SVD is computed and optionally truncated afterwards.</span>

<span class="sd">        If full :</span>
<span class="sd">            run exact full SVD calling the standard LAPACK solver via scipy.linalg.svd and select the components by postprocessing</span>

<span class="sd">        If arpack :</span>
<span class="sd">            run SVD truncated to n_components calling ARPACK solver via scipy.sparse.linalg.svds. It requires strictly 0 &lt; n_components &lt; min(X.shape)</span>

<span class="sd">        If randomized :</span>
<span class="sd">            run randomized SVD by the method of Halko et al.</span>

<span class="sd">    tol : float &gt;= 0 ,optional</span>
<span class="sd">        [default: 0]</span>
<span class="sd">        Tolerance for singular values computed by svd_solver == ‘arpack’.</span>

<span class="sd">    iterated_power : int &gt;= 0, or string {&#39;auto&#39;}</span>
<span class="sd">        [default: &#39;auto&#39;]</span>
<span class="sd">        Number of iterations for the power method computed by svd_solver == ‘randomized’.</span>

<span class="sd">    random_state : int, RandomState instance, or None, optional</span>
<span class="sd">        [default: None]</span>
<span class="sd">        If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator;</span>
<span class="sd">        If None, the random number generator is the RandomState instance used by np.random.</span>
<span class="sd">        Used when svd_solver == ‘arpack’ or ‘randomized’.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    dict</span>
<span class="sd">        Sklearn PCA object dictionary of all attributes and values.</span>

<span class="sd">        -components_array, shape (n_components, n_features)</span>
<span class="sd">            Principal axes in feature space, representing the directions of maximum variance in the data. The components are sorted by explained_variance_.</span>

<span class="sd">        -explained_variance_array, shape (n_components,)</span>
<span class="sd">            The amount of variance explained by each of the selected components.</span>
<span class="sd">            Equal to n_components largest eigenvalues of the covariance matrix of X.</span>
<span class="sd">            New in version 0.18.</span>

<span class="sd">        -explained_variance_ratio_array, shape (n_components,)</span>
<span class="sd">            Percentage of variance explained by each of the selected components.</span>
<span class="sd">            If n_components is not set then all components are stored and the sum of the ratios is equal to 1.0.</span>

<span class="sd">        -singular_values_array, shape (n_components,)</span>
<span class="sd">            The singular values corresponding to each of the selected components. The singular values are equal to the 2-norms of the n_components variables in the lower-dimensional space.</span>
<span class="sd">            New in version 0.19.</span>

<span class="sd">        -mean_array, shape (n_features,)</span>
<span class="sd">            Per-feature empirical mean, estimated from the training set.</span>
<span class="sd">            Equal to X.mean(axis=0).</span>

<span class="sd">        -n_components_int</span>
<span class="sd">            The estimated number of components. When n_components is set to ‘mle’ or a number between 0 and 1 (with svd_solver == ‘full’) this number is estimated from input data. Otherwise it equals the parameter n_components, or the lesser value of n_features and n_samples if n_components is None.</span>

<span class="sd">        -n_features_int</span>
<span class="sd">            Number of features in the training data.</span>

<span class="sd">        -n_samples_int</span>
<span class="sd">            Number of samples in the training data.</span>

<span class="sd">        -noise_variance_float</span>
<span class="sd">            The estimated noise covariance following the Probabilistic PCA model from Tipping and Bishop 1999. See “Pattern Recognition and Machine Learning” by C. Bishop, 12.2.1 p. 574 or http://www.miketipping.com/papers/met-mppca.pdf. It is required to compute the estimated data covariance and score samples.</span>
<span class="sd">            Equal to the average of (min(n_features, n_samples) - n_components) smallest eigenvalues of the covariance matrix of X.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ys</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;matrix may not have null values.&#39;</span><span class="p">)</span>
    <span class="n">pca</span><span class="o">=</span><span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span><span class="n">whiten</span><span class="o">=</span><span class="n">whiten</span><span class="p">,</span><span class="n">svd_solver</span><span class="o">=</span><span class="n">svd_solver</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span><span class="n">iterated_power</span><span class="o">=</span><span class="n">iterated_power</span><span class="p">,</span><span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span><span class="o">.</span><span class="vm">__dict__</span></div>


<div class="viewcode-block" id="mssa"><a class="viewcode-back" href="../../../utils/decomposition/mssa.html#pyleoclim.utils.decomposition.mssa">[docs]</a><span class="k">def</span> <span class="nf">mssa</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nMC</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="mf">0.3</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Multi-channel singular spectrum analysis analysis</span>

<span class="sd">    Multivariate generalization of SSA [2], using the original algorithm of [1].</span>
<span class="sd">    Each variable is called a channel, hence the name.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">          multiple time series (dimension: length of time series x total number of time series)</span>

<span class="sd">    M : int</span>
<span class="sd">       window size (embedding dimension, default: 10% of the length of the series)</span>

<span class="sd">    nMC : int</span>
<span class="sd">       Number of iteration in the Monte-Carlo process [default=0, no Monte Carlo process]</span>

<span class="sd">    f : float</span>
<span class="sd">       fraction (0&lt;f&lt;=1) of good data points for identifying significant PCs [f = 0.3]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : dict</span>
<span class="sd">        Containing:</span>

<span class="sd">        - eigvals : array of eigenvalue spectrum</span>

<span class="sd">        - eigvals05 : The 5% percentile of eigenvalues</span>

<span class="sd">        - eigvals95 : The 95% percentile of eigenvalues</span>

<span class="sd">        - PC : matrix of principal components (2D array)</span>

<span class="sd">        - RC : matrix of RCs (nrec,N,nrec*M) (2D array)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1]_ Vautard, R., and M. Ghil (1989), Singular spectrum analysis in nonlinear</span>
<span class="sd">    dynamics, with applications to paleoclimatic time series, Physica D, 35,</span>
<span class="sd">    395–424.</span>

<span class="sd">    [2]_ Jiang, N., J. D. Neelin, and M. Ghil (1995), Quasi-quadrennial and</span>
<span class="sd">    quasi-biennial variability in the equatorial Pacific, Clim. Dyn., 12, 101-112.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>

<span class="sd">    pyleoclim.utils.decomposition.ssa : Singular Spectrum Analysis (single channel)</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">nrec</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">M</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span> <span class="o">-</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nrec</span> <span class="o">*</span> <span class="n">M</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">irec</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nrec</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
            <span class="n">Y</span><span class="p">[:,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">irec</span> <span class="o">*</span> <span class="n">M</span><span class="p">]</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[</span><span class="n">m</span><span class="p">:</span><span class="n">N</span> <span class="o">-</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">irec</span><span class="p">]</span>

    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Y</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">D</span><span class="p">,</span> <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

    <span class="n">sort_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
    <span class="n">eigvals</span> <span class="o">=</span> <span class="n">sort_tmp</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sortarg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">D</span><span class="p">)</span>

    <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">eigvecs</span><span class="p">[:,</span> <span class="n">sortarg</span><span class="p">]</span>

    <span class="c1"># test the signifiance using Monte-Carlo</span>
    <span class="n">Ym</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span> <span class="o">-</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nrec</span> <span class="o">*</span> <span class="n">M</span><span class="p">))</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nrec</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">nMC</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">irec</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nrec</span><span class="p">):</span>
        <span class="n">noise</span><span class="p">[</span><span class="n">irec</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">irec</span><span class="p">]</span>
    <span class="n">eigvals_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nrec</span> <span class="o">*</span> <span class="n">M</span><span class="p">,</span> <span class="n">nMC</span><span class="p">))</span>
    <span class="c1"># estimate coefficents of ar1 processes, and then generate ar1 time series (noise)</span>
    <span class="c1"># TODO : update to use ar1_sim(), as in ssa() </span>
    <span class="k">for</span> <span class="n">irec</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nrec</span><span class="p">):</span>
        <span class="n">Xs</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[:,</span> <span class="n">irec</span><span class="p">]</span>
        <span class="n">coefs_est</span><span class="p">,</span> <span class="n">var_est</span> <span class="o">=</span> <span class="n">alg</span><span class="o">.</span><span class="n">AR_est_YW</span><span class="p">(</span><span class="n">Xs</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Xs</span><span class="p">)],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sigma_est</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_est</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">jt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
            <span class="n">noise</span><span class="p">[</span><span class="n">irec</span><span class="p">,</span> <span class="n">jt</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">coefs_est</span> <span class="o">*</span> <span class="n">noise</span><span class="p">[</span><span class="n">irec</span><span class="p">,</span> <span class="n">jt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">sigma_est</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nMC</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nMC</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">irec</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nrec</span><span class="p">):</span>
            <span class="n">noise</span><span class="p">[</span><span class="n">irec</span><span class="p">,</span> <span class="p">:,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">noise</span><span class="p">[</span><span class="n">irec</span><span class="p">,</span> <span class="p">:,</span> <span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">noise</span><span class="p">[</span><span class="n">irec</span><span class="p">,</span> <span class="p">:,</span> <span class="n">m</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">noise</span><span class="p">[</span><span class="n">irec</span><span class="p">,</span> <span class="p">:,</span> <span class="n">m</span><span class="p">],</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
                <span class="n">Ym</span><span class="p">[:,</span> <span class="n">im</span> <span class="o">+</span> <span class="n">irec</span> <span class="o">*</span> <span class="n">M</span><span class="p">]</span> <span class="o">=</span> <span class="n">noise</span><span class="p">[</span><span class="n">irec</span><span class="p">,</span> <span class="n">im</span><span class="p">:</span><span class="n">N</span> <span class="o">-</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">im</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>
        <span class="n">Cn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Ym</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">Ym</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># eigvals_R[:,m] = np.diag(np.dot(np.dot(eigvecs,Cn),np.transpose(eigvecs)))</span>
        <span class="n">eigvals_R</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">eigvecs</span><span class="p">),</span> <span class="n">Cn</span><span class="p">),</span> <span class="n">eigvecs</span><span class="p">))</span>

    <span class="n">eigvals95</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">eigvals_R</span><span class="p">,</span> <span class="mi">95</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">eigvals05</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">eigvals_R</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


    <span class="c1"># determine principal component time series</span>
    <span class="n">PC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span> <span class="o">-</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nrec</span> <span class="o">*</span> <span class="n">M</span><span class="p">))</span>
    <span class="n">PC</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nrec</span> <span class="o">*</span> <span class="n">M</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1">#   modify for nan</span>
            <span class="n">prod</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">eigvecs</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span>
            <span class="n">ngood</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">prod</span><span class="p">))</span>
            <span class="c1">#   must have at least m*f good points</span>
            <span class="k">if</span> <span class="n">ngood</span> <span class="o">&gt;=</span> <span class="n">M</span> <span class="o">*</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">PC</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">prod</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">prod</span><span class="p">)])</span>  <span class="c1"># the columns of this matrix are Ak(t), k=1 to M (T-PCs)</span>

    <span class="c1"># compute reconstructed timeseries</span>
    <span class="n">Np</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">RC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nrec</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">nrec</span> <span class="o">*</span> <span class="n">M</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nrec</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">PC</span><span class="p">[:,</span> <span class="n">im</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">eigvecs</span><span class="p">[</span><span class="mi">0</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">M</span><span class="p">:</span><span class="n">M</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">M</span><span class="p">,</span> <span class="n">im</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">RC</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">im</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">offset</span><span class="o">=-</span><span class="p">(</span><span class="n">Np</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">n</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;eigvals&#39;</span><span class="p">:</span> <span class="n">eigvals</span><span class="p">,</span> <span class="s1">&#39;eigvecs&#39;</span><span class="p">:</span> <span class="n">eigvecs</span><span class="p">,</span> <span class="s1">&#39;q05&#39;</span><span class="p">:</span> <span class="n">eigvals05</span><span class="p">,</span> <span class="s1">&#39;q95&#39;</span><span class="p">:</span> <span class="n">eigvals95</span><span class="p">,</span> <span class="s1">&#39;PC&#39;</span><span class="p">:</span> <span class="n">PC</span><span class="p">,</span> <span class="s1">&#39;RC&#39;</span><span class="p">:</span> <span class="n">RC</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="ssa"><a class="viewcode-back" href="../../../utils/decomposition/ssa.html#pyleoclim.utils.decomposition.ssa">[docs]</a><span class="k">def</span> <span class="nf">ssa</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nMC</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">trunc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">var_thresh</span> <span class="o">=</span> <span class="mi">80</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Singular spectrum analysis</span>

<span class="sd">    Nonparametric eigendecomposition of timeseries into orthogonal oscillations.</span>
<span class="sd">    This implementation  uses the method of [1], with applications presented in [2].</span>
<span class="sd">    Optionally (nMC&gt;0), the significance of eigenvalues is assessed by Monte-Carlo simulations of an AR(1) model fit to X, using [3].</span>
<span class="sd">    The method expects regular spacing, but is tolerant to missing values, up to a fraction 0&lt;f&lt;1 (see [4]).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    y : array of length N</span>
<span class="sd">          time series (evenly-spaced, possibly with up to f*N NaNs)</span>

<span class="sd">    M : int</span>
<span class="sd">       window size (default: 10% of N)</span>

<span class="sd">    nMC : int</span>
<span class="sd">        Number of iterations in the Monte-Carlo simulation (default nMC=0, bypasses Monte Carlo SSA)</span>
<span class="sd">        Currently only supported for evenly-spaced, gap-free data.</span>

<span class="sd">    f : float</span>
<span class="sd">        maximum allowable fraction of missing values. (Default is 0.5)</span>

<span class="sd">    trunc : str</span>
<span class="sd">        if present, truncates the expansion to a level K &lt; M owing to one of 3 criteria:</span>
<span class="sd">            (1) &#39;kaiser&#39;: variant of the Kaiser-Guttman rule, retaining eigenvalues larger than the median</span>
<span class="sd">            (2) &#39;mc-ssa&#39;: Monte-Carlo SSA (use modes above the 95% threshold)</span>
<span class="sd">            (3) &#39;var&#39;: first K modes that explain at least var_thresh % of the variance.</span>
<span class="sd">        Default is None, which bypasses truncation (K = M)</span>
<span class="sd">        </span>
<span class="sd">    var_thresh : float</span>
<span class="sd">        variance threshold for reconstruction (only impactful if trunc is set to &#39;var&#39;)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    res : dict</span>
<span class="sd">        Containing:</span>

<span class="sd">        - eigvals : (M, ) array of eigenvalue spectrum</span>

<span class="sd">        - eigvecs : Matrix of temporal eigenvectors</span>

<span class="sd">        - PC : (N - M + 1, M) array of principal components</span>

<span class="sd">        - RCmat : (N,  M) array of reconstructed components</span>
<span class="sd">        </span>
<span class="sd">        - RCseries : (N,) reconstructed series</span>

<span class="sd">        - pctvar: (M, ) array of the fraction of variance (%) associated with each mode</span>

<span class="sd">        - eigvals_q : (M, ) array contaitning the 5% and 95% quantiles of the Monte-Carlo eigenvalue spectrum [ if nMC &gt;0 ]</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1]_ Vautard, R., and M. Ghil (1989), Singular spectrum analysis in nonlinear</span>
<span class="sd">    dynamics, with applications to paleoclimatic time series, Physica D, 35,</span>
<span class="sd">    395–424.</span>

<span class="sd">    [2]_ Ghil, M., R. M. Allen, M. D. Dettinger, K. Ide, D. Kondrashov, M. E. Mann,</span>
<span class="sd">    A. Robertson, A. Saunders, Y. Tian, F. Varadi, and P. Yiou (2002),</span>
<span class="sd">    Advanced spectral methods for climatic time series, Rev. Geophys., 40(1),</span>
<span class="sd">    1003–1052, doi:10.1029/2000RG000092.</span>

<span class="sd">    [3]_ Allen, M. R., and L. A. Smith (1996), Monte Carlo SSA: Detecting irregular</span>
<span class="sd">    oscillations in the presence of coloured noise, J. Clim., 9, 3373–3404.</span>

<span class="sd">    [4]_ Schoellhamer, D. H. (2001), Singular spectrum analysis for time series with</span>
<span class="sd">    missing data, Geophysical Research Letters, 28(16), 3187–3190, doi:10.1029/2000GL012698.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>

<span class="sd">    pyleoclim.utils.decomposition.mssa : Multi-channel SSA</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">ys</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">standardize</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">M</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span> 
        <span class="n">prod</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">ys</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">N</span><span class="p">]</span>
        <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">prod</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">prod</span><span class="p">)])</span> <span class="o">/</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">prod</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>


    <span class="n">C</span> <span class="o">=</span> <span class="n">toeplitz</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">M</span><span class="p">])</span>  <span class="c1">#form correlation matrix</span>

    <span class="n">D</span><span class="p">,</span> <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="c1"># solve eigendecomposition</span>

    <span class="n">sort_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
    <span class="n">eigvals</span> <span class="o">=</span> <span class="n">sort_tmp</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sortarg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">D</span><span class="p">)</span>
    <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">eigvecs</span><span class="p">[:,</span> <span class="n">sortarg</span><span class="p">]</span>

    <span class="c1"># determine principal component time series</span>
    <span class="n">PC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span> <span class="o">-</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="p">))</span>
    <span class="n">PC</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1">#   modify for nan</span>
            <span class="n">prod</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">M</span><span class="p">]</span> <span class="o">*</span> <span class="n">eigvecs</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span>
            <span class="n">ngood</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">prod</span><span class="p">))</span>
            <span class="c1">#   must have at least m*f good points</span>
            <span class="k">if</span> <span class="n">ngood</span> <span class="o">&gt;=</span> <span class="n">M</span> <span class="o">*</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">PC</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                    <span class="n">prod</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">prod</span><span class="p">)])</span> <span class="o">*</span> <span class="n">M</span> <span class="o">/</span> <span class="n">ngood</span>  <span class="c1"># the columns of this matrix are Ak(t), k=1 to M (T-PCs)</span>

    <span class="n">pctvar</span> <span class="o">=</span> <span class="n">eigvals</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eigvals</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span> <span class="c1"># percent variance</span>

    <span class="k">if</span> <span class="n">nMC</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># If Monte-Carlo SSA is requested.</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">ar1_sim</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">nMC</span><span class="p">)</span>  <span class="c1"># generate MC AR(1) surrogates of y</span>
        <span class="n">eigvals_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span><span class="n">nMC</span><span class="p">))</span> <span class="c1"># define eigenvalue matrix</span>
        <span class="n">lgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nMC</span><span class="p">):</span>
            <span class="n">xn</span><span class="p">,</span> <span class="n">_</span> <span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">standardize</span><span class="p">(</span><span class="n">noise</span><span class="p">[:,</span> <span class="n">m</span><span class="p">])</span> <span class="c1"># center and standardize</span>
            <span class="n">Gn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">xn</span><span class="p">,</span> <span class="n">xn</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">)</span>
            <span class="n">Gn</span> <span class="o">=</span> <span class="n">Gn</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lgs</span><span class="p">))</span>
            <span class="n">Cn</span> <span class="o">=</span> <span class="n">toeplitz</span><span class="p">(</span><span class="n">Gn</span><span class="p">[</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">M</span><span class="p">])</span>
            <span class="n">eigvals_R</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">eigvecs</span><span class="p">),</span> <span class="n">Cn</span><span class="p">),</span> <span class="n">eigvecs</span><span class="p">))</span>

        <span class="n">eigvals_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">M</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">eigvals_q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">eigvals_R</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">eigvals_q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">eigvals_R</span><span class="p">,</span> <span class="mi">95</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mode_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">eigvals</span><span class="o">&gt;=</span><span class="n">eigvals_q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># modes to retain</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">eigvals_q</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">trunc</span> <span class="o">==</span> <span class="s1">&#39;mcssa&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nMC</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;nMC must be larger than 0 to enable MC-SSA truncation&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">trunc</span> <span class="o">==</span> <span class="s1">&#39;kaiser&#39;</span><span class="p">:</span>
        <span class="n">mval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">eigvals</span><span class="p">)</span> <span class="c1"># median eigenvalues</span>
        <span class="n">mode_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">eigvals</span><span class="o">&gt;=</span><span class="n">mval</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">trunc</span> <span class="o">==</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span>
        <span class="n">mode_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">pctvar</span><span class="p">)</span><span class="o">&gt;=</span><span class="n">var_thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mode_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

    <span class="c1"># compute reconstructed timeseries</span>
    <span class="n">Np</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">RCmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">xdum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">PC</span><span class="p">[:,</span> <span class="n">im</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">eigvecs</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">M</span><span class="p">,</span> <span class="n">im</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">xdum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">xdum</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">RCmat</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">im</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">xdum</span><span class="p">,</span> <span class="n">offset</span><span class="o">=-</span><span class="p">(</span><span class="n">Np</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">n</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">xdum</span>            

    <span class="c1">#RCmat = RCmat + np.tile(mu, reps=[N, M])  # restore the mean and variance</span>
    
    <span class="n">RCseries</span> <span class="o">=</span> <span class="n">scale</span><span class="o">*</span><span class="n">RCmat</span><span class="p">[:,</span><span class="n">mode_idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">mu</span>

    <span class="c1"># export results</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;eigvals&#39;</span><span class="p">:</span> <span class="n">eigvals</span><span class="p">,</span> <span class="s1">&#39;eigvecs&#39;</span><span class="p">:</span> <span class="n">eigvecs</span><span class="p">,</span> <span class="s1">&#39;PC&#39;</span><span class="p">:</span> <span class="n">PC</span><span class="p">,</span> <span class="s1">&#39;RCseries&#39;</span><span class="p">:</span> <span class="n">RCseries</span><span class="p">,</span> <span class="s1">&#39;RCmat&#39;</span><span class="p">:</span> <span class="n">RCmat</span><span class="p">,</span> <span class="s1">&#39;pctvar&#39;</span><span class="p">:</span> <span class="n">pctvar</span><span class="p">,</span> <span class="s1">&#39;eigvals_q&#39;</span><span class="p">:</span> <span class="n">eigvals_q</span><span class="p">,</span> <span class="s1">&#39;mode_idx&#39;</span><span class="p">:</span> <span class="n">mode_idx</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2017-2021, Deborah Khider, Feng Zhu, Julien Emile-Geay, Alexander James

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>