

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyleoclim.utils.wavelet &mdash; Pyleoclim 0.5.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> Pyleoclim
          

          
          </a>

          
            
            
              <div class="version">
                0.5.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Working with Pyleoclim</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing Pyleoclim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../core/ui.html">Using the Pyleoclim UI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
</ul>
<p class="caption"><span class="caption-text">Advanced functionalities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../utils/introduction.html">Pyleoclim Utilities (pyleoclim.utils)</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting Involved</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../citation.html">Citing Pyleoclim</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Pyleoclim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pyleoclim.utils.wavelet</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyleoclim.utils.wavelet</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Tue Feb 25 08:14:31 2020</span>

<span class="sd">@author: deborahkhider</span>

<span class="sd">Functions concerning wavelet analysis</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;cwt&#39;</span><span class="p">,</span>
    <span class="s1">&#39;wwz&#39;</span><span class="p">,</span>
    <span class="s1">&#39;xwc&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="kn">from</span> <span class="nn">pathos.multiprocessing</span> <span class="kn">import</span> <span class="n">ProcessingPool</span> <span class="k">as</span> <span class="n">Pool</span>
<span class="kn">import</span> <span class="nn">numba</span> <span class="k">as</span> <span class="nn">nb</span>
<span class="kn">from</span> <span class="nn">numba.core.errors</span> <span class="kn">import</span> <span class="n">NumbaPerformanceWarning</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">scipy.fftpack</span> <span class="k">as</span> <span class="nn">fft</span>
<span class="kn">import</span> <span class="nn">pywt</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>

<span class="c1">#from .tsmodel import ar1_sim</span>
<span class="kn">from</span> <span class="nn">.tsutils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">clean_ts</span><span class="p">,</span>
    <span class="n">preprocess</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">NumbaPerformanceWarning</span><span class="p">)</span>

<span class="c1">#---------------</span>
<span class="c1">#Wrapper functions</span>
<span class="c1">#---------------</span>

<span class="c1">#----------------</span>
<span class="c1">#Main Functions</span>
<span class="c1">#----------------</span>

<div class="viewcode-block" id="AliasFilter"><a class="viewcode-back" href="../../../utils/wavelet/AliasFilter.html#pyleoclim.utils.wavelet.AliasFilter">[docs]</a><span class="k">class</span> <span class="nc">AliasFilter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Performing anti-alias filter on a psd </span>
<span class="sd">    </span>
<span class="sd">    experimental: Use at your own risk</span>
<span class="sd">    </span>
<span class="sd">    @author: fzhu</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">alias_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">pwr</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">f_limit</span><span class="p">,</span> <span class="n">avgs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; anti_alias filter</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        freq : array</span>
<span class="sd">            vector of frequencies in power spectrum</span>
<span class="sd">        pwr : array</span>
<span class="sd">            vector of spectral power corresponding to frequencies &quot;freq&quot;</span>
<span class="sd">        fs : float</span>
<span class="sd">            sampling frequency</span>
<span class="sd">        fc : float</span>
<span class="sd">            corner frequency for 1/f^2 steepening of power spectrum</span>
<span class="sd">        f_limit : float</span>
<span class="sd">            lower frequency limit for estimating misfit of model-plus-alias spectrum vs. measured power</span>
<span class="sd">        avgs : int</span>
<span class="sd">            flag for whether spectrum is derived from instantaneous point measurements (avgs&lt;&gt;1)</span>
<span class="sd">            OR from measurements averaged over each sampling interval (avgs==1)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        alpha : float</span>
<span class="sd">            best-fit exponent of power-law model</span>
<span class="sd">        filtered_pwr : array</span>
<span class="sd">            vector of alias-filtered spectral power</span>
<span class="sd">        model_pwr : array</span>
<span class="sd">            vector of modeled spectral power</span>
<span class="sd">        aliased_pwr : array</span>
<span class="sd">            vector of modeled spectral power, plus aliases</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>

<span class="sd">        Kirchner, J. W. Aliasing in 1/f(alpha) noise spectra: origins, consequences, and remedies.</span>
<span class="sd">        Phys Rev E Stat Nonlin Soft Matter Phys 71, 66110 (2005).</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">log_pwr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pwr</span><span class="p">)</span>
        <span class="n">freq_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">freq</span> <span class="o">&gt;</span> <span class="n">f_limit</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span>  <span class="c1"># convert True &amp; False to 1 &amp; 0</span>

        <span class="n">alpha_upper_bound</span> <span class="o">=</span> <span class="mi">5</span>

        <span class="k">if</span> <span class="n">avgs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">alpha_lower_bound</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.9</span>  <span class="c1"># if measurements are time-averaged</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha_lower_bound</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.9</span>  <span class="c1"># if measurements are point samples</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misfit</span><span class="p">,</span> <span class="n">alpha_lower_bound</span><span class="p">,</span> <span class="n">alpha_upper_bound</span><span class="p">,</span>
                                   <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">log_pwr</span><span class="p">,</span> <span class="n">freq_mask</span><span class="p">,</span> <span class="n">avgs</span><span class="p">),</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>

        <span class="n">model_pwr</span><span class="p">,</span> <span class="n">aliased_pwr</span><span class="p">,</span> <span class="n">RMSE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">log_pwr</span><span class="p">,</span> <span class="n">freq_mask</span><span class="p">,</span> <span class="n">avgs</span><span class="p">)</span>
        <span class="n">filtered_pwr</span> <span class="o">=</span> <span class="n">pwr</span> <span class="o">*</span> <span class="n">model_pwr</span> <span class="o">/</span> <span class="n">aliased_pwr</span>

        <span class="k">return</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">filtered_pwr</span><span class="p">,</span> <span class="n">model_pwr</span><span class="p">,</span> <span class="n">aliased_pwr</span>

    <span class="k">def</span> <span class="nf">misfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">log_pwr</span><span class="p">,</span> <span class="n">freq_mask</span><span class="p">,</span> <span class="n">avgs</span><span class="p">):</span>
        <span class="n">model</span><span class="p">,</span> <span class="n">aliased_pwr</span><span class="p">,</span> <span class="n">RMSE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">log_pwr</span><span class="p">,</span> <span class="n">freq_mask</span><span class="p">,</span> <span class="n">avgs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">RMSE</span>

    <span class="k">def</span> <span class="nf">alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">log_pwr</span><span class="p">,</span> <span class="n">freq_mask</span><span class="p">,</span> <span class="n">avgs</span><span class="p">):</span>
        <span class="n">model_pwr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">avgs</span><span class="p">)</span>
        <span class="n">aliased_pwr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">model_pwr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">avgs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">aliased_pwr</span> <span class="o">=</span> <span class="n">aliased_pwr</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">freq</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
            <span class="n">alias_minus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">k</span><span class="o">*</span><span class="n">fs</span><span class="o">-</span><span class="n">freq</span><span class="p">,</span> <span class="n">avgs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">avgs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">alias_minus</span> <span class="o">=</span> <span class="n">alias_minus</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">((</span><span class="n">k</span><span class="o">*</span><span class="n">fs</span><span class="o">-</span><span class="n">freq</span><span class="p">)</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="n">aliased_pwr</span> <span class="o">=</span> <span class="n">aliased_pwr</span> <span class="o">+</span> <span class="n">alias_minus</span>

            <span class="n">alias_plus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">k</span><span class="o">*</span><span class="n">fs</span><span class="o">+</span><span class="n">freq</span><span class="p">,</span> <span class="n">avgs</span><span class="p">)</span>  <span class="c1"># notice the + in (k*fs+freq)</span>
            <span class="k">if</span> <span class="n">avgs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">alias_plus</span> <span class="o">=</span> <span class="n">alias_plus</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">((</span><span class="n">k</span><span class="o">*</span><span class="n">fs</span><span class="o">+</span><span class="n">freq</span><span class="p">)</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="n">aliased_pwr</span> <span class="o">=</span> <span class="n">aliased_pwr</span> <span class="o">+</span> <span class="n">alias_plus</span>

        <span class="k">if</span> <span class="n">avgs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">+</span> <span class="mi">3</span>
            <span class="n">const</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">const</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">beta</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span>

        <span class="n">zo_minus</span> <span class="o">=</span> <span class="p">(</span><span class="mi">11</span><span class="o">*</span><span class="n">fs</span><span class="o">-</span><span class="n">freq</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span><span class="p">)</span>
        <span class="n">dz_minus</span> <span class="o">=</span> <span class="n">zo_minus</span> <span class="o">/</span> <span class="mi">20</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">):</span>
            <span class="n">aliased_pwr</span> <span class="o">=</span> <span class="n">aliased_pwr</span> <span class="o">+</span> <span class="n">const</span> <span class="o">/</span> <span class="p">((</span><span class="n">j</span><span class="o">*</span><span class="n">dz_minus</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">beta</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">fc</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">dz_minus</span>

        <span class="n">zo_plus</span> <span class="o">=</span> <span class="p">(</span><span class="mi">11</span><span class="o">*</span><span class="n">fs</span><span class="o">+</span><span class="n">freq</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span><span class="p">)</span>
        <span class="n">dz_plus</span> <span class="o">=</span> <span class="n">zo_plus</span> <span class="o">/</span> <span class="mi">20</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">):</span>
            <span class="n">aliased_pwr</span> <span class="o">=</span> <span class="n">aliased_pwr</span> <span class="o">+</span> <span class="n">const</span> <span class="o">/</span> <span class="p">((</span><span class="n">j</span><span class="o">*</span><span class="n">dz_plus</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">beta</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">fc</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">dz_plus</span>

        <span class="n">log_aliased</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">aliased_pwr</span><span class="p">)</span>

        <span class="n">prefactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">log_pwr</span> <span class="o">-</span> <span class="n">log_aliased</span><span class="p">)</span> <span class="o">*</span> <span class="n">freq_mask</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">freq_mask</span><span class="p">)</span>

        <span class="n">log_aliased</span> <span class="o">=</span> <span class="n">log_aliased</span> <span class="o">+</span> <span class="n">prefactor</span>
        <span class="n">aliased_pwr</span> <span class="o">=</span> <span class="n">aliased_pwr</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">prefactor</span><span class="p">)</span>
        <span class="n">model_pwr</span> <span class="o">=</span> <span class="n">model_pwr</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">prefactor</span><span class="p">)</span>

        <span class="n">RMSE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">log_aliased</span><span class="o">-</span><span class="n">log_pwr</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">log_aliased</span><span class="o">-</span><span class="n">log_pwr</span><span class="p">)</span><span class="o">*</span><span class="n">freq_mask</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">freq_mask</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">model_pwr</span><span class="p">,</span> <span class="n">aliased_pwr</span><span class="p">,</span> <span class="n">RMSE</span>

    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">avgs</span><span class="p">):</span>
        <span class="n">spectr</span> <span class="o">=</span> <span class="n">freq</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">freq</span><span class="o">/</span><span class="n">fc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spectr</span></div>
    
<div class="viewcode-block" id="cwt"><a class="viewcode-back" href="../../../utils/wavelet/cwt.html#pyleoclim.utils.wavelet.cwt">[docs]</a><span class="k">def</span> <span class="nf">cwt</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span><span class="n">ts</span><span class="p">,</span><span class="n">scales</span><span class="p">,</span><span class="n">wavelet</span><span class="o">=</span><span class="s1">&#39;morl&#39;</span><span class="p">,</span><span class="n">sampling_period</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;conv&#39;</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Continous wavelet transform for evenly spaced data</span>
<span class="sd">    </span>
<span class="sd">    pywavelet documentation: https://pywavelets.readthedocs.io/en/latest/ref/cwt.html</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ys : array</span>
<span class="sd">        signal</span>
<span class="sd">    ts : array</span>
<span class="sd">        time </span>
<span class="sd">    scales : array (float)</span>
<span class="sd">        different wavelet scales to use</span>
<span class="sd">    wavelet : str</span>
<span class="sd">        types of wavelet options in function documentation link. The default is &#39;morl&#39; for a morlet wavelet.</span>
<span class="sd">    sampling_period : float, optional</span>
<span class="sd">        sampling period for frequencies output. The default is 1.0.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        cwt computation  method. &#39;conv&#39;,&#39;fft&#39;. or &#39;auto&#39; The default is &#39;conv&#39;.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        axis over which to compute cwt. The default is -1, the last axis.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : dictionary</span>
<span class="sd">        &#39;freq&#39; - array(float) </span>
<span class="sd">            frequencies</span>
<span class="sd">        &#39;time&#39; - array(float)</span>
<span class="sd">        &#39;amplitude&#39; - array(float)</span>
<span class="sd">        &#39;coi&#39; - array(float)</span>
<span class="sd">            cone of inference</span>

<span class="sd">    &#39;&#39;&#39;</span>    
    <span class="n">coeff</span><span class="p">,</span><span class="n">freq</span><span class="o">=</span><span class="n">pywt</span><span class="o">.</span><span class="n">cwt</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">ys</span><span class="p">,</span><span class="n">scales</span><span class="o">=</span><span class="n">scales</span><span class="p">,</span><span class="n">wavelet</span><span class="o">=</span><span class="n">wavelet</span><span class="p">,</span><span class="n">sampling_period</span><span class="o">=</span><span class="n">sampling_period</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">amplitude</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">wavelet</span><span class="o">==</span><span class="s1">&#39;morl&#39;</span> <span class="ow">or</span> <span class="n">wavelet</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;cmor&#39;</span><span class="p">:</span>
        <span class="n">coi</span><span class="o">=</span><span class="n">make_coi</span><span class="p">(</span><span class="n">tau</span><span class="o">=</span><span class="n">ts</span><span class="p">,</span><span class="n">Neff</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coi</span><span class="o">=</span><span class="n">make_coi</span><span class="p">(</span><span class="n">tau</span><span class="o">=</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">Results</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Results&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;amplitude&#39;</span><span class="p">,</span><span class="s1">&#39;coi&#39;</span><span class="p">,</span> <span class="s1">&#39;freq&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;coeff&#39;</span><span class="p">])</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">Results</span><span class="p">(</span><span class="n">amplitude</span><span class="o">=</span><span class="n">amplitude</span><span class="p">,</span> <span class="n">coi</span><span class="o">=</span><span class="n">coi</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">ts</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="n">coeff</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="assertPositiveInt"><a class="viewcode-back" href="../../../utils/wavelet/assertPositiveInt.html#pyleoclim.utils.wavelet.assertPositiveInt">[docs]</a><span class="k">def</span> <span class="nf">assertPositiveInt</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Assert that the arguments are all positive integers.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    args</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span> <span class="o">&gt;=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="wwz_basic"><a class="viewcode-back" href="../../../utils/wavelet/wwz_basic.html#pyleoclim.utils.wavelet.wwz_basic">[docs]</a><span class="k">def</span> <span class="nf">wwz_basic</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the weighted wavelet amplitude (WWA).</span>

<span class="sd">    Original method from Foster. Not multiprocessing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series</span>
<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>
<span class="sd">    c : float</span>
<span class="sd">        the decay constant</span>
<span class="sd">    Neff : int</span>
<span class="sd">        the threshold of the number of effective degree of freedom</span>
<span class="sd">    nproc :int</span>
<span class="sd">        fake argument, just for convenience</span>
<span class="sd">    detrend : string</span>
<span class="sd">        None - the original time series is assumed to have no trend;</span>
<span class="sd">        &#39;linear&#39; - a linear least-squares fit to `ys` is subtracted;</span>
<span class="sd">        &#39;constant&#39; - the mean of `ys` is subtracted</span>
<span class="sd">        &#39;savitzy-golay&#39; - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">        Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series</span>
<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.</span>
<span class="sd">    gaussianize : bool</span>
<span class="sd">        If True, gaussianizes the timeseries</span>
<span class="sd">    standardize : bool</span>
<span class="sd">        If True, standardizes the timeseries</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    wwa : array</span>
<span class="sd">        the weighted wavelet amplitude</span>
<span class="sd">    phase : array</span>
<span class="sd">        the weighted wavelet phase</span>
<span class="sd">    Neffs : array</span>
<span class="sd">        the matrix of effective number of points in the time-scale coordinates</span>
<span class="sd">    coeff : array</span>
<span class="sd">        the wavelet transform coefficients (a0, a1, a2)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    Foster, G. Wavelets for period analysis of unevenly sampled time series. The Astronomical Journal 112, 1709 (1996).</span>
<span class="sd">    Witt, A. &amp; Schumann, A. Y. Holocene climate variability on millennial scales recorded in Greenland ice cores.</span>
<span class="sd">    Nonlinear Processes in Geophysics 12, 345â€“352 (2005).</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.wwz_nproc : Returns the weighted wavelet amplitude using the original method from Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_basic : Return the weighted wavelet amplitude (WWA) modified by Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_nproc : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_numba : Return the weighted wavelet amplitude (WWA) modified by Kirchner using Numba package.</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_f2py : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Uses Fortran. Fastest method but requires a compiler. </span>

<span class="sd">    pyleoclim.utils.filter.savitzky_golay : Smooth (and optionally differentiate) data with a Savitzky-Golay filter.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="n">nproc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;wwz_basic() only supports nproc=1&quot;</span>
    <span class="n">assertPositiveInt</span><span class="p">(</span><span class="n">Neff</span><span class="p">)</span>

    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="n">pd_ys</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span> <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">)</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="n">make_omega</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

    <span class="n">Neffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">ywave_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">ywave_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">ywave_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nf</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">dz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">sum_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">Neffs</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_w</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># local number of effective dof</span>

            <span class="k">if</span> <span class="n">Neffs</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Neff</span><span class="p">:</span>
                <span class="n">ywave_1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># the coefficients cannot be estimated reliably when Neff_loc &lt;= Neff</span>
                <span class="n">ywave_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">ywave_3</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">phi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>
                <span class="n">phi3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>

                <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi2</span><span class="o">*</span><span class="n">phi2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
                <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi3</span><span class="o">*</span><span class="n">phi3</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
                <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
                <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi3</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
                <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi2</span><span class="o">*</span><span class="n">phi3</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>

                <span class="n">S_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

                <span class="n">weighted_phi1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">pd_ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
                <span class="n">weighted_phi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi2</span><span class="o">*</span><span class="n">pd_ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
                <span class="n">weighted_phi3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi3</span><span class="o">*</span><span class="n">pd_ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>

                <span class="n">ywave_1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi1</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi2</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi3</span>
                <span class="n">ywave_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi1</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi2</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi3</span>
                <span class="n">ywave_3</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi1</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi2</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi3</span>

    <span class="n">wwa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ywave_2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">ywave_3</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">ywave_3</span><span class="p">,</span> <span class="n">ywave_2</span><span class="p">)</span>
    <span class="c1">#  coeff = ywave_2 + ywave_3*1j</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">ywave_1</span><span class="p">,</span> <span class="n">ywave_2</span><span class="p">,</span> <span class="n">ywave_3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wwa</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">coeff</span></div>

<div class="viewcode-block" id="wwz_nproc"><a class="viewcode-back" href="../../../utils/wavelet/wwz_nproc.html#pyleoclim.utils.wavelet.wwz_nproc">[docs]</a><span class="k">def</span> <span class="nf">wwz_nproc</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>  <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the weighted wavelet amplitude (WWA).</span>

<span class="sd">    Original method from Foster. Supports multiprocessing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series</span>
<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>
<span class="sd">    c : float</span>
<span class="sd">        the decay constant</span>
<span class="sd">    Neff : int</span>
<span class="sd">        the threshold of the number of effective degree of freedom</span>
<span class="sd">    nproc : int</span>
<span class="sd">        the number of processes for multiprocessing</span>
<span class="sd">    detrend : string</span>
<span class="sd">        None - the original time series is assumed to have no trend;</span>
<span class="sd">        &#39;linear&#39; - a linear least-squares fit to `ys` is subtracted;</span>
<span class="sd">        &#39;constant&#39; - the mean of `ys` is subtracted</span>
<span class="sd">        &#39;savitzy-golay&#39; - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">        Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series</span>
<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.</span>
<span class="sd">    gaussianize : bool</span>
<span class="sd">        If True, gaussianizes the timeseries</span>
<span class="sd">    standardize : bool</span>
<span class="sd">        If True, standardizes the timeseries</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    wwa : array</span>
<span class="sd">        the weighted wavelet amplitude</span>
<span class="sd">    phase : array</span>
<span class="sd">        the weighted wavelet phase</span>
<span class="sd">    Neffs : array</span>
<span class="sd">        the matrix of effective number of points in the time-scale coordinates</span>
<span class="sd">    coeff : array</span>
<span class="sd">        the wavelet transform coefficients (a0, a1, a2)</span>
<span class="sd">        </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.wwz_basic : Returns the weighted wavelet amplitude using the original method from Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_basic : Return the weighted wavelet amplitude (WWA) modified by Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_nproc : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_numba : Return the weighted wavelet amplitude (WWA) modified by Kirchner using Numba package.</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_f2py : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Uses Fortran. Fastest method but requires a compiler. </span>

<span class="sd">    pyleoclim.utils.filter.savitzky_golay : Smooth (and optionally differentiate) data with a Savitzky-Golay filter.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="n">nproc</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;wwz_nproc() should use nproc &gt;= 2, if want serial run, please use wwz_basic()&quot;</span>
    <span class="n">assertPositiveInt</span><span class="p">(</span><span class="n">Neff</span><span class="p">)</span>

    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="n">pd_ys</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span> <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">)</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="n">make_omega</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

    <span class="n">Neffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">ywave_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">ywave_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">ywave_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">wwa_1g</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">omega</span><span class="p">):</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">omega</span> <span class="o">*</span> <span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">dz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">sum_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">Neff_loc</span> <span class="o">=</span> <span class="n">sum_w</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">Neff_loc</span> <span class="o">&lt;=</span> <span class="n">Neff</span><span class="p">:</span>
            <span class="n">ywave_2_1g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">ywave_3_1g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">phi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>
            <span class="n">phi3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>

            <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi2</span><span class="o">*</span><span class="n">phi2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
            <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi3</span><span class="o">*</span><span class="n">phi3</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
            <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
            <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi3</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
            <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi2</span><span class="o">*</span><span class="n">phi3</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>

            <span class="n">S_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

            <span class="n">weighted_phi1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">pd_ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
            <span class="n">weighted_phi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi2</span><span class="o">*</span><span class="n">pd_ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
            <span class="n">weighted_phi3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi3</span><span class="o">*</span><span class="n">pd_ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>

            <span class="n">ywave_1_1g</span> <span class="o">=</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi1</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi2</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi3</span>
            <span class="n">ywave_2_1g</span> <span class="o">=</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi1</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi2</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi3</span>
            <span class="n">ywave_3_1g</span> <span class="o">=</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi1</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi2</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi3</span>

        <span class="k">return</span> <span class="n">Neff_loc</span><span class="p">,</span> <span class="n">ywave_1_1g</span><span class="p">,</span> <span class="n">ywave_2_1g</span><span class="p">,</span> <span class="n">ywave_3_1g</span>

    <span class="n">tf_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span>
    <span class="n">list_of_grids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">flat</span> <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">tf_mesh</span><span class="p">)))</span>
    <span class="n">tau_grids</span><span class="p">,</span> <span class="n">omega_grids</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">list_of_grids</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">nproc</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">wwa_1g</span><span class="p">,</span> <span class="n">tau_grids</span><span class="p">,</span> <span class="n">omega_grids</span><span class="p">)</span>
        <span class="n">res_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="n">Neffs</span> <span class="o">=</span> <span class="n">res_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">ywave_1</span> <span class="o">=</span> <span class="n">res_array</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">ywave_2</span> <span class="o">=</span> <span class="n">res_array</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">ywave_3</span> <span class="o">=</span> <span class="n">res_array</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>

    <span class="n">wwa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ywave_2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">ywave_3</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">ywave_3</span><span class="p">,</span> <span class="n">ywave_2</span><span class="p">)</span>
    <span class="c1">#  coeff = ywave_2 + ywave_3*1j</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">ywave_1</span><span class="p">,</span> <span class="n">ywave_2</span><span class="p">,</span> <span class="n">ywave_3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wwa</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">coeff</span></div>

<div class="viewcode-block" id="kirchner_basic"><a class="viewcode-back" href="../../../utils/wavelet/kirchner_basic.html#pyleoclim.utils.wavelet.kirchner_basic">[docs]</a><span class="k">def</span> <span class="nf">kirchner_basic</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the weighted wavelet amplitude (WWA) modified by Kirchner.</span>

<span class="sd">    Method modified by Kirchner. No multiprocessing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series</span>
<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>
<span class="sd">    c : float</span>
<span class="sd">        the decay constant</span>
<span class="sd">    Neff : int</span>
<span class="sd">        the threshold of the number of effective degree of freedom</span>
<span class="sd">    nproc : int</span>
<span class="sd">        fake argument for convenience, for parameter consistency between functions, does not need to be specified</span>
<span class="sd">    detrend : string</span>
<span class="sd">        None - the original time series is assumed to have no trend;</span>
<span class="sd">        &#39;linear&#39; - a linear least-squares fit to `ys` is subtracted;</span>
<span class="sd">        &#39;constant&#39; - the mean of `ys` is subtracted</span>
<span class="sd">        &#39;savitzy-golay&#39; - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">        Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series</span>
<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.</span>
<span class="sd">    gaussianize : bool</span>
<span class="sd">        If True, gaussianizes the timeseries</span>
<span class="sd">    standardize : bool</span>
<span class="sd">        If True, standardizes the timeseries</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    wwa : array</span>
<span class="sd">        the weighted wavelet amplitude</span>
<span class="sd">    phase : array</span>
<span class="sd">        the weighted wavelet phase</span>
<span class="sd">    Neffs : array</span>
<span class="sd">        the matrix of effective number of points in the time-scale coordinates</span>
<span class="sd">    coeff : array</span>
<span class="sd">        the wavelet transform coefficients (a0, a1, a2)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    Foster, G. Wavelets for period analysis of unevenly sampled time series. The Astronomical Journal 112, 1709 (1996).</span>
<span class="sd">    Witt, A. &amp; Schumann, A. Y. Holocene climate variability on millennial scales recorded in Greenland ice cores.</span>
<span class="sd">    Nonlinear Processes in Geophysics 12, 345â€“352 (2005).</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.wwz_basic : Returns the weighted wavelet amplitude using the original method from Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.wwz_nproc : Returns the weighted wavelet amplitude using the original method from Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_nproc : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_numba : Return the weighted wavelet amplitude (WWA) modified by Kirchner using Numba package.</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_f2py : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Uses Fortran. Fastest method but requires a compiler. </span>

<span class="sd">    pyleoclim.utils.filter.savitzky_golay : Smooth (and optionally differentiate) data with a Savitzky-Golay filter.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="n">nproc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;wwz_basic() only supports nproc=1&quot;</span>
    <span class="n">assertPositiveInt</span><span class="p">(</span><span class="n">Neff</span><span class="p">)</span>

    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">nts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="n">pd_ys</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span> <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">)</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="n">make_omega</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

    <span class="n">Neffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nf</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">dz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">sum_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">Neffs</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_w</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># local number of effective dof</span>

            <span class="k">if</span> <span class="n">Neffs</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Neff</span><span class="p">:</span>
                <span class="n">a0</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># the coefficients cannot be estimated reliably when Neff_loc &lt;= Neff</span>
                <span class="n">a1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">a2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">w_prod</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">xs</span><span class="o">*</span><span class="n">ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>

                <span class="n">sin_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">ts</span><span class="p">)</span>
                <span class="n">cos_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">ts</span><span class="p">)</span>
                <span class="n">one_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nts</span><span class="p">)</span>

                <span class="n">sin_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
                <span class="n">cos_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_basis</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
                <span class="n">sin_cos</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">cos_basis</span><span class="p">)</span>
                <span class="n">sin_sin</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">sin_basis</span><span class="p">)</span>
                <span class="n">cos_cos</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_basis</span><span class="p">,</span> <span class="n">cos_basis</span><span class="p">)</span>

                <span class="n">numerator</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">sin_cos</span> <span class="o">-</span> <span class="n">sin_one</span> <span class="o">*</span> <span class="n">cos_one</span><span class="p">)</span>
                <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos_cos</span> <span class="o">-</span> <span class="n">cos_one</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">sin_sin</span> <span class="o">-</span> <span class="n">sin_one</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">time_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span> <span class="n">denominator</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>  <span class="c1"># Eq. (S5)</span>

                <span class="n">sin_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">time_shift</span><span class="p">))</span>
                <span class="n">cos_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">time_shift</span><span class="p">))</span>
                <span class="n">sin_tau_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">time_shift</span> <span class="o">-</span> <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="n">cos_tau_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">time_shift</span> <span class="o">-</span> <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

                <span class="n">ys_cos_shift</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">cos_shift</span><span class="p">)</span>
                <span class="n">ys_sin_shift</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">sin_shift</span><span class="p">)</span>
                <span class="n">ys_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
                <span class="n">cos_shift_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_shift</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
                <span class="n">sin_shift_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_shift</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>

                <span class="n">A</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">ys_cos_shift</span><span class="o">-</span><span class="n">ys_one</span><span class="o">*</span><span class="n">cos_shift_one</span><span class="p">)</span>
                <span class="n">B</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">ys_sin_shift</span><span class="o">-</span><span class="n">ys_one</span><span class="o">*</span><span class="n">sin_shift_one</span><span class="p">)</span>

                <span class="n">a0</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ys_one</span>
                <span class="n">a1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_tau_center</span><span class="o">*</span><span class="n">A</span> <span class="o">-</span> <span class="n">sin_tau_center</span><span class="o">*</span><span class="n">B</span>  <span class="c1"># Eq. (S6)</span>
                <span class="n">a2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_tau_center</span><span class="o">*</span><span class="n">A</span> <span class="o">+</span> <span class="n">cos_tau_center</span><span class="o">*</span><span class="n">B</span>  <span class="c1"># Eq. (S7)</span>

    <span class="n">wwa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
    <span class="c1">#  coeff = a1 + a2*1j</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wwa</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">coeff</span></div>

<div class="viewcode-block" id="kirchner_nproc"><a class="viewcode-back" href="../../../utils/wavelet/kirchner_nproc.html#pyleoclim.utils.wavelet.kirchner_nproc">[docs]</a><span class="k">def</span> <span class="nf">kirchner_nproc</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the weighted wavelet amplitude (WWA) modified by Kirchner.</span>

<span class="sd">    Method modified by kirchner. Supports multiprocessing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series</span>
<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>
<span class="sd">    c : float</span>
<span class="sd">        the decay constant</span>
<span class="sd">    Neff : int</span>
<span class="sd">        the threshold of the number of effective degree of freedom</span>
<span class="sd">    nproc : int</span>
<span class="sd">        the number of processes for multiprocessing</span>
<span class="sd">    detrend : string</span>
<span class="sd">        None - the original time series is assumed to have no trend;</span>
<span class="sd">        &#39;linear&#39; - a linear least-squares fit to `ys` is subtracted;</span>
<span class="sd">        &#39;constant&#39; - the mean of `ys` is subtracted</span>
<span class="sd">        &#39;savitzy-golay&#39; - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">        Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series</span>
<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.</span>
<span class="sd">    gaussianize : bool</span>
<span class="sd">        If True, gaussianizes the timeseries</span>
<span class="sd">    standardize : bool</span>
<span class="sd">        If True, standardizes the timeseries</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    wwa (array): the weighted wavelet amplitude</span>
<span class="sd">    phase (array): the weighted wavelet phase</span>
<span class="sd">    Neffs (array): the matrix of effective number of points in the time-scale coordinates</span>
<span class="sd">    coeff (array): the wavelet transform coefficients (a0, a1, a2)</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.wwz_basic : Returns the weighted wavelet amplitude using the original method from Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.wwz_nproc : Returns the weighted wavelet amplitude using the original method from Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_basic : Return the weighted wavelet amplitude (WWA) modified by Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_numba : Return the weighted wavelet amplitude (WWA) modified by Kirchner using Numba package.</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_f2py : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Uses Fortran. Fastest method but requires a compiler. </span>

<span class="sd">    pyleoclim.utils.filter.savitzky_golay : Smooth (and optionally differentiate) data with a Savitzky-Golay filter.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="n">nproc</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;wwz_nproc() should use nproc &gt;= 2, if want serial run, please use wwz_basic()&quot;</span>
    <span class="n">assertPositiveInt</span><span class="p">(</span><span class="n">Neff</span><span class="p">)</span>

    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">nts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="n">pd_ys</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span> <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">)</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="n">make_omega</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

    <span class="n">Neffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">wwa_1g</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">omega</span><span class="p">):</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">omega</span> <span class="o">*</span> <span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">dz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">sum_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">Neff_loc</span> <span class="o">=</span> <span class="n">sum_w</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">Neff_loc</span> <span class="o">&lt;=</span> <span class="n">Neff</span><span class="p">:</span>
            <span class="n">a0_1g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># the coefficients cannot be estimated reliably when Neff_loc &lt;= Neff</span>
            <span class="n">a1_1g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># the coefficients cannot be estimated reliably when Neff_loc &lt;= Neff</span>
            <span class="n">a2_1g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">w_prod</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">xs</span><span class="o">*</span><span class="n">ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>

            <span class="n">sin_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">ts</span><span class="p">)</span>
            <span class="n">cos_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">ts</span><span class="p">)</span>
            <span class="n">one_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nts</span><span class="p">)</span>

            <span class="n">sin_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
            <span class="n">cos_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_basis</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
            <span class="n">sin_cos</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">cos_basis</span><span class="p">)</span>
            <span class="n">sin_sin</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">sin_basis</span><span class="p">)</span>
            <span class="n">cos_cos</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_basis</span><span class="p">,</span> <span class="n">cos_basis</span><span class="p">)</span>

            <span class="n">numerator</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">sin_cos</span> <span class="o">-</span> <span class="n">sin_one</span><span class="o">*</span><span class="n">cos_one</span><span class="p">)</span>
            <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos_cos</span> <span class="o">-</span> <span class="n">cos_one</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">sin_sin</span> <span class="o">-</span> <span class="n">sin_one</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">time_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span> <span class="n">denominator</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="p">)</span>  <span class="c1"># Eq. (S5)</span>

            <span class="n">sin_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">time_shift</span><span class="p">))</span>
            <span class="n">cos_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">time_shift</span><span class="p">))</span>
            <span class="n">sin_tau_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="n">time_shift</span> <span class="o">-</span> <span class="n">tau</span><span class="p">))</span>
            <span class="n">cos_tau_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="n">time_shift</span> <span class="o">-</span> <span class="n">tau</span><span class="p">))</span>

            <span class="n">ys_cos_shift</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">cos_shift</span><span class="p">)</span>
            <span class="n">ys_sin_shift</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">sin_shift</span><span class="p">)</span>
            <span class="n">ys_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
            <span class="n">cos_shift_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_shift</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
            <span class="n">sin_shift_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_shift</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>

            <span class="n">A</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">ys_cos_shift</span> <span class="o">-</span> <span class="n">ys_one</span><span class="o">*</span><span class="n">cos_shift_one</span><span class="p">)</span>
            <span class="n">B</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">ys_sin_shift</span> <span class="o">-</span> <span class="n">ys_one</span><span class="o">*</span><span class="n">sin_shift_one</span><span class="p">)</span>

            <span class="n">a0_1g</span> <span class="o">=</span> <span class="n">ys_one</span>
            <span class="n">a1_1g</span> <span class="o">=</span> <span class="n">cos_tau_center</span><span class="o">*</span><span class="n">A</span> <span class="o">-</span> <span class="n">sin_tau_center</span><span class="o">*</span><span class="n">B</span>  <span class="c1"># Eq. (S6)</span>
            <span class="n">a2_1g</span> <span class="o">=</span> <span class="n">sin_tau_center</span><span class="o">*</span><span class="n">A</span> <span class="o">+</span> <span class="n">cos_tau_center</span><span class="o">*</span><span class="n">B</span>  <span class="c1"># Eq. (S7)</span>

        <span class="k">return</span> <span class="n">Neff_loc</span><span class="p">,</span> <span class="n">a0_1g</span><span class="p">,</span> <span class="n">a1_1g</span><span class="p">,</span> <span class="n">a2_1g</span>

    <span class="n">tf_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span>
    <span class="n">list_of_grids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">flat</span> <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">tf_mesh</span><span class="p">)))</span>
    <span class="n">tau_grids</span><span class="p">,</span> <span class="n">omega_grids</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">list_of_grids</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">nproc</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">wwa_1g</span><span class="p">,</span> <span class="n">tau_grids</span><span class="p">,</span> <span class="n">omega_grids</span><span class="p">)</span>
        <span class="n">res_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="n">Neffs</span> <span class="o">=</span> <span class="n">res_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">a0</span> <span class="o">=</span> <span class="n">res_array</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">res_array</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">res_array</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>

    <span class="n">wwa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
    <span class="c1">#  coeff = a1 + a2*1j</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wwa</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">coeff</span></div>

<div class="viewcode-block" id="kirchner_numba"><a class="viewcode-back" href="../../../utils/wavelet/kirchner_numba.html#pyleoclim.utils.wavelet.kirchner_numba">[docs]</a><span class="k">def</span> <span class="nf">kirchner_numba</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the weighted wavelet amplitude (WWA) modified by Kirchner.</span>

<span class="sd">    Using numba.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series</span>
<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>
<span class="sd">    c : float</span>
<span class="sd">        the decay constant</span>
<span class="sd">    Neff : int</span>
<span class="sd">        the threshold of the number of effective degree of freedom</span>
<span class="sd">    nproc : int</span>
<span class="sd">        fake argument, just for convenience</span>
<span class="sd">    detrend : string</span>
<span class="sd">        None - the original time series is assumed to have no trend;</span>
<span class="sd">        &#39;linear&#39; - a linear least-squares fit to `ys` is subtracted;</span>
<span class="sd">        &#39;constant&#39; - the mean of `ys` is subtracted</span>
<span class="sd">        &#39;savitzy-golay&#39; - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">        Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series</span>
<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.</span>
<span class="sd">    gaussianize : bool</span>
<span class="sd">        If True, gaussianizes the timeseries</span>
<span class="sd">    standardize : bool</span>
<span class="sd">        If True, standardizes the timeseries</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    wwa : array</span>
<span class="sd">        the weighted wavelet amplitude</span>
<span class="sd">    phase : array</span>
<span class="sd">        the weighted wavelet phase</span>
<span class="sd">    Neffs : array</span>
<span class="sd">        the matrix of effective number of points in the time-scale coordinates</span>
<span class="sd">    coeff : array</span>
<span class="sd">        the wavelet transform coefficients (a0, a1, a2)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    Foster, G. Wavelets for period analysis of unevenly sampled time series. The Astronomical Journal 112, 1709 (1996).</span>
<span class="sd">    Witt, A. &amp; Schumann, A. Y. Holocene climate variability on millennial scales recorded in Greenland ice cores.</span>
<span class="sd">    Nonlinear Processes in Geophysics 12, 345â€“352 (2005).</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.wwz_basic : Returns the weighted wavelet amplitude using the original method from Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.wwz_nproc : Returns the weighted wavelet amplitude using the original method from Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_basic : Return the weighted wavelet amplitude (WWA) modified by Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_nproc : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_f2py : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Uses Fortran. Fastest method but requires a compiler. </span>

<span class="sd">    pyleoclim.utils.filter.savitzky_golay : Smooth (and optionally differentiate) data with a Savitzky-Golay filter.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">assertPositiveInt</span><span class="p">(</span><span class="n">Neff</span><span class="p">)</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">nts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="n">pd_ys</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span> <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">)</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="n">make_omega</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

    <span class="n">Neffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>

    <span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">loop_over</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span> <span class="n">nt</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">wwa_1g</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">omega</span><span class="p">):</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">omega</span> <span class="o">*</span> <span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">dz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">sum_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">Neff_loc</span> <span class="o">=</span> <span class="n">sum_w</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">Neff_loc</span> <span class="o">&lt;=</span> <span class="n">Neff</span><span class="p">:</span>
                <span class="n">a0_1g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># the coefficients cannot be estimated reliably when Neff_loc &lt;= Neff</span>
                <span class="n">a1_1g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># the coefficients cannot be estimated reliably when Neff_loc &lt;= Neff</span>
                <span class="n">a2_1g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">w_prod</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">xs</span><span class="o">*</span><span class="n">ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>

                <span class="n">sin_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">ts</span><span class="p">)</span>
                <span class="n">cos_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">ts</span><span class="p">)</span>
                <span class="n">one_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nts</span><span class="p">)</span>

                <span class="n">sin_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
                <span class="n">cos_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_basis</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
                <span class="n">sin_cos</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">cos_basis</span><span class="p">)</span>
                <span class="n">sin_sin</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">sin_basis</span><span class="p">)</span>
                <span class="n">cos_cos</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_basis</span><span class="p">,</span> <span class="n">cos_basis</span><span class="p">)</span>

                <span class="n">numerator</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">sin_cos</span> <span class="o">-</span> <span class="n">sin_one</span><span class="o">*</span><span class="n">cos_one</span><span class="p">)</span>
                <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos_cos</span> <span class="o">-</span> <span class="n">cos_one</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">sin_sin</span> <span class="o">-</span> <span class="n">sin_one</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">time_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span> <span class="n">denominator</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="p">)</span>  <span class="c1"># Eq. (S5)</span>

                <span class="n">sin_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">time_shift</span><span class="p">))</span>
                <span class="n">cos_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">time_shift</span><span class="p">))</span>
                <span class="n">sin_tau_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="n">time_shift</span> <span class="o">-</span> <span class="n">tau</span><span class="p">))</span>
                <span class="n">cos_tau_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="n">time_shift</span> <span class="o">-</span> <span class="n">tau</span><span class="p">))</span>

                <span class="n">ys_cos_shift</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">cos_shift</span><span class="p">)</span>
                <span class="n">ys_sin_shift</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">sin_shift</span><span class="p">)</span>
                <span class="n">ys_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
                <span class="n">cos_shift_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_shift</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
                <span class="n">sin_shift_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_shift</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>

                <span class="n">A</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">ys_cos_shift</span> <span class="o">-</span> <span class="n">ys_one</span><span class="o">*</span><span class="n">cos_shift_one</span><span class="p">)</span>
                <span class="n">B</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">ys_sin_shift</span> <span class="o">-</span> <span class="n">ys_one</span><span class="o">*</span><span class="n">sin_shift_one</span><span class="p">)</span>

                <span class="n">a0_1g</span> <span class="o">=</span> <span class="n">ys_one</span>
                <span class="n">a1_1g</span> <span class="o">=</span> <span class="n">cos_tau_center</span><span class="o">*</span><span class="n">A</span> <span class="o">-</span> <span class="n">sin_tau_center</span><span class="o">*</span><span class="n">B</span>  <span class="c1"># Eq. (S6)</span>
                <span class="n">a2_1g</span> <span class="o">=</span> <span class="n">sin_tau_center</span><span class="o">*</span><span class="n">A</span> <span class="o">+</span> <span class="n">cos_tau_center</span><span class="o">*</span><span class="n">B</span>  <span class="c1"># Eq. (S7)</span>

            <span class="k">return</span> <span class="n">Neff_loc</span><span class="p">,</span> <span class="n">a0_1g</span><span class="p">,</span> <span class="n">a1_1g</span><span class="p">,</span> <span class="n">a2_1g</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nb</span><span class="o">.</span><span class="n">prange</span><span class="p">(</span><span class="n">nf</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">nb</span><span class="o">.</span><span class="n">prange</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
                <span class="n">Neffs</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">a0</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">a1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">a2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">wwa_1g</span><span class="p">(</span><span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span>

    <span class="n">Neffs</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">loop_over</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span> <span class="n">nt</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>

    <span class="n">wwa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
    <span class="c1">#  coeff = a1 + a2*1j</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wwa</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">coeff</span></div>

<div class="viewcode-block" id="kirchner_f2py"><a class="viewcode-back" href="../../../utils/wavelet/kirchner_f2py.html#pyleoclim.utils.wavelet.kirchner_f2py">[docs]</a><span class="k">def</span> <span class="nf">kirchner_f2py</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Returns the weighted wavelet amplitude (WWA) modified by Kirchner.</span>

<span class="sd">    Fastest method. Calls Fortran libraries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series</span>
<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>
<span class="sd">    c : float</span>
<span class="sd">        the decay constant</span>
<span class="sd">    Neff : int</span>
<span class="sd">        the threshold of the number of effective degree of freedom</span>
<span class="sd">    nproc : int</span>
<span class="sd">        fake argument, just for convenience</span>
<span class="sd">    detrend : string</span>
<span class="sd">        None - the original time series is assumed to have no trend;</span>
<span class="sd">        &#39;linear&#39; - a linear least-squares fit to `ys` is subtracted;</span>
<span class="sd">        &#39;constant&#39; - the mean of `ys` is subtracted</span>
<span class="sd">        &#39;savitzy-golay&#39; - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">        Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series</span>
<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.</span>
<span class="sd">    gaussianize : bool</span>
<span class="sd">        If True, gaussianizes the timeseries</span>
<span class="sd">    standardize : bool</span>
<span class="sd">        If True, standardizes the timeseries</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    wwa : array</span>
<span class="sd">        the weighted wavelet amplitude</span>
<span class="sd">    phase : array</span>
<span class="sd">        the weighted wavelet phase</span>
<span class="sd">    Neffs : array</span>
<span class="sd">        the matrix of effective number of points in the time-scale coordinates</span>
<span class="sd">    coeff : array</span>
<span class="sd">        the wavelet transform coefficients (a0, a1, a2)</span>
<span class="sd">        </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.wwz_basic : Returns the weighted wavelet amplitude using the original method from Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.wwz_nproc : Returns the weighted wavelet amplitude using the original method from Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_basic : Return the weighted wavelet amplitude (WWA) modified by Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_nproc : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_numba : Return the weighted wavelet amplitude (WWA) modified by Kirchner using Numba package.</span>

<span class="sd">    pyleoclim.utils.filter.savitzky_golay : Smooth (and optionally differentiate) data with a Savitzky-Golay filter.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">f2py_wwz</span> <span class="k">as</span> <span class="n">f2py</span>
    <span class="n">assertPositiveInt</span><span class="p">(</span><span class="n">Neff</span><span class="p">,</span> <span class="n">nproc</span><span class="p">)</span>

    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">nts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="n">pd_ys</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span> <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">)</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="n">make_omega</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

    <span class="n">Neffs</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">f2py</span><span class="o">.</span><span class="n">f2py_wwz</span><span class="o">.</span><span class="n">wwa</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Neff</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">pd_ys</span><span class="p">,</span> <span class="n">nproc</span><span class="p">,</span> <span class="n">nts</span><span class="p">,</span> <span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">)</span>

    <span class="n">undef</span> <span class="o">=</span> <span class="o">-</span><span class="mf">99999.</span>
    <span class="n">a0</span><span class="p">[</span><span class="n">a0</span> <span class="o">==</span> <span class="n">undef</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">a1</span><span class="p">[</span><span class="n">a1</span> <span class="o">==</span> <span class="n">undef</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">a2</span><span class="p">[</span><span class="n">a2</span> <span class="o">==</span> <span class="n">undef</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">wwa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>

    <span class="c1">#  coeff = a1 + a2*1j</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wwa</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">coeff</span></div>

<div class="viewcode-block" id="make_coi"><a class="viewcode-back" href="../../../utils/wavelet/make_coi.html#pyleoclim.utils.wavelet.make_coi">[docs]</a><span class="k">def</span> <span class="nf">make_coi</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the cone of influence.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>
<span class="sd">    Neff : int</span>
<span class="sd">        the threshold of the number of effective samples</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">        coi : array</span>
<span class="sd">            cone of influence</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    wave_signif() in http://paos.colorado.edu/research/wavelets/wave_python/waveletFunctions.py</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Neff</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Neff</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>

    <span class="n">fourier_factor</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="n">Neff</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">Neff</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">coi_const</span> <span class="o">=</span> <span class="n">fourier_factor</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>
    <span class="n">nt_half</span> <span class="o">=</span> <span class="p">(</span><span class="n">nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.00001</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nt_half</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">nt</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="n">coi</span> <span class="o">=</span> <span class="n">coi_const</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">C</span>

    <span class="k">return</span> <span class="n">coi</span></div>

<div class="viewcode-block" id="make_omega"><a class="viewcode-back" href="../../../utils/wavelet/make_omega.html#pyleoclim.utils.wavelet.make_omega">[docs]</a><span class="k">def</span> <span class="nf">make_omega</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the angular frequency based on the time axis and given frequency vector</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series</span>
<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>


<span class="sd">    omega : array</span>
<span class="sd">        the angular frequency vector</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># for the frequency band larger than f_Nyquist, the wwa will be marked as NaNs</span>
    <span class="n">f_Nyquist</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
    <span class="n">freq_with_nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
    <span class="n">freq_with_nan</span><span class="p">[</span><span class="n">freq</span> <span class="o">&gt;</span> <span class="n">f_Nyquist</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">freq_with_nan</span>

    <span class="k">return</span> <span class="n">omega</span></div>

<div class="viewcode-block" id="wwa2psd"><a class="viewcode-back" href="../../../utils/wavelet/wwa2psd.html#pyleoclim.utils.wavelet.wwa2psd">[docs]</a><span class="k">def</span> <span class="nf">wwa2psd</span><span class="p">(</span><span class="n">wwa</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">anti_alias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">avgs</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return the power spectral density (PSD) using the weighted wavelet amplitude (WWA).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    wwa : array</span>
<span class="sd">        the weighted wavelet amplitude.</span>
<span class="sd">    ts : array</span>
<span class="sd">        the time points, should be pre-truncated so that the span is exactly what is used for wwz</span>
<span class="sd">    Neffs : array</span>
<span class="sd">        the matrix of effective number of points in the time-scale coordinates obtained from wwz from wwz</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency from wwz</span>
<span class="sd">    Neff : int</span>
<span class="sd">        the threshold of the number of effective samples</span>
<span class="sd">    anti_alias : bool</span>
<span class="sd">        whether to apply anti-alias filter</span>
<span class="sd">    avgs : int</span>
<span class="sd">        flag for whether spectrum is derived from instantaneous point measurements (avgs&lt;&gt;1) OR from measurements averaged over each sampling interval (avgs==1)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    psd : array</span>
<span class="sd">        power spectral density</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    Kirchner&#39;s C code for weighted psd calculation</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">af</span> <span class="o">=</span> <span class="n">AliasFilter</span><span class="p">()</span>

    <span class="c1"># weighted psd calculation start</span>
    <span class="n">power</span> <span class="o">=</span> <span class="n">wwa</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">*</span> <span class="n">Neffs</span>

    <span class="n">Neff_diff</span> <span class="o">=</span> <span class="n">Neffs</span> <span class="o">-</span> <span class="n">Neff</span>
    <span class="n">Neff_diff</span><span class="p">[</span><span class="n">Neff_diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">sum_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">power</span> <span class="o">*</span> <span class="n">Neff_diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">sum_eff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">Neff_diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">psd</span> <span class="o">=</span> <span class="n">sum_power</span> <span class="o">/</span> <span class="n">sum_eff</span>
    <span class="c1"># weighted psd calculation end</span>

    <span class="k">if</span> <span class="n">anti_alias</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;freq is required for alias filter!&quot;</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
        <span class="n">f_sampling</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">dt</span>
        <span class="n">psd_copy</span> <span class="o">=</span> <span class="n">psd</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">freq_copy</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">filtered_pwr</span><span class="p">,</span> <span class="n">model_pwer</span><span class="p">,</span> <span class="n">aliased_pwr</span> <span class="o">=</span> <span class="n">af</span><span class="o">.</span><span class="n">alias_filter</span><span class="p">(</span>
            <span class="n">freq_copy</span><span class="p">,</span> <span class="n">psd_copy</span><span class="p">,</span> <span class="n">f_sampling</span><span class="p">,</span> <span class="n">f_sampling</span><span class="o">*</span><span class="mf">1e3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">avgs</span><span class="p">)</span>

        <span class="n">psd</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">filtered_pwr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">psd</span></div>

<div class="viewcode-block" id="wwz"><a class="viewcode-back" href="../../../utils/wavelet/wwz.html#pyleoclim.utils.wavelet.wwz">[docs]</a><span class="k">def</span> <span class="nf">wwz</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq_method</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">freq_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">Neff_coi</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">nMC</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">len_bd</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">bc_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Weighted wavelet amplitude (WWA) for unevenly-spaced data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series, NaNs will be deleted automatically</span>
<span class="sd">    ts : array</span>
<span class="sd">        the time points, if `ys` contains any NaNs, some of the time points will be deleted accordingly</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    freq_method : str</span>
<span class="sd">        when freq=None, freq will be ganerated according to freq_method</span>
<span class="sd">    freq_kwargs : str</span>
<span class="sd">        used when freq=None for certain methods</span>
<span class="sd">    c : float</span>
<span class="sd">        the decay constant, the default value 1/(8*np.pi**2) is good for most of the cases</span>
<span class="sd">    Neff : int</span>
<span class="sd">        effective number of points</span>
<span class="sd">    nMC : int</span>
<span class="sd">        the number of Monte-Carlo simulations</span>
<span class="sd">    nproc : int</span>
<span class="sd">        the number of processes for multiprocessing</span>
<span class="sd">    detrend : string</span>
<span class="sd">        None - the original time series is assumed to have no trend;</span>
<span class="sd">        &#39;linear&#39; - a linear least-squares fit to `ys` is subtracted;</span>
<span class="sd">        &#39;constant&#39; - the mean of `ys` is subtracted</span>
<span class="sd">        &#39;savitzy-golay&#39; - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">        Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series</span>
<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.</span>
<span class="sd">    method : string</span>
<span class="sd">        &#39;Foster&#39; - the original WWZ method;</span>
<span class="sd">        &#39;Kirchner&#39; - the method Kirchner adapted from Foster;</span>
<span class="sd">        &#39;Kirchner_f2py&#39; - the method Kirchner adapted from Foster with f2py</span>
<span class="sd">        &#39;Kirchner_numba&#39; - Kirchner&#39;s algorithm with Numba support for acceleration (default)</span>
<span class="sd">    len_bd : int</span>
<span class="sd">        the number of the ghost grids want to creat on each boundary</span>
<span class="sd">    bc_mode : string</span>
<span class="sd">        {&#39;constant&#39;, &#39;edge&#39;, &#39;linear_ramp&#39;, &#39;maximum&#39;, &#39;mean&#39;, &#39;median&#39;, &#39;minimum&#39;, &#39;reflect&#39; , &#39;symmetric&#39;, &#39;wrap&#39;}</span>
<span class="sd">        For more details, see np.lib.pad()</span>
<span class="sd">    reflect_type : string</span>
<span class="sd">         {â€˜evenâ€™, â€˜oddâ€™}, optional</span>
<span class="sd">         Used in â€˜reflectâ€™, and â€˜symmetricâ€™. The â€˜evenâ€™ style is the default with an unaltered reflection around the edge value.</span>
<span class="sd">         For the â€˜oddâ€™ style, the extented part of the array is created by subtracting the reflected values from two times the edge value.</span>
<span class="sd">         For more details, see np.lib.pad()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    wwa : array</span>
<span class="sd">        the weighted wavelet amplitude.</span>
<span class="sd">    AR1_q : array</span>
<span class="sd">        AR1 simulations</span>
<span class="sd">    coi : array</span>
<span class="sd">        cone of influence</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>
<span class="sd">    Neffs : array</span>
<span class="sd">        the matrix of effective number of points in the time-scale coordinates</span>
<span class="sd">    coeff : array</span>
<span class="sd">        the wavelet transform coefficents</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.wwz_basic : Returns the weighted wavelet amplitude using the original method from Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.wwz_nproc : Returns the weighted wavelet amplitude using the original method from Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_basic : Return the weighted wavelet amplitude (WWA) modified by Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_nproc : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_numba : Return the weighted wavelet amplitude (WWA) modified by Kirchner using Numba package.</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_f2py : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Uses Fortran. Fastest method but requires a compiler. </span>

<span class="sd">    pyleoclim.utils.filter.savitzky_golay : Smooth (and optionally differentiate) data with a Savitzky-Golay filter.    </span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.make_freq_vector : Make frequency vector</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nMC</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nMC</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;nMC should be larger than or equal to 0.&quot;</span>

    <span class="n">ys_cut</span><span class="p">,</span> <span class="n">ts_cut</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">prepare_wwz</span><span class="p">(</span>
        <span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">freq_method</span><span class="o">=</span><span class="n">freq_method</span><span class="p">,</span> <span class="n">freq_kwargs</span><span class="o">=</span><span class="n">freq_kwargs</span><span class="p">,</span>
        <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span> <span class="n">len_bd</span><span class="o">=</span><span class="n">len_bd</span><span class="p">,</span>
        <span class="n">bc_mode</span><span class="o">=</span><span class="n">bc_mode</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="n">reflect_type</span>
    <span class="p">)</span>

    <span class="n">wwz_func</span> <span class="o">=</span> <span class="n">get_wwz_func</span><span class="p">(</span><span class="n">nproc</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
    <span class="n">wwa</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">wwz_func</span><span class="p">(</span><span class="n">ys_cut</span><span class="p">,</span> <span class="n">ts_cut</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">Neff</span><span class="o">=</span><span class="n">Neff</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="n">nproc</span><span class="p">,</span>
                                        <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span>
                                        <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">)</span>

    <span class="c1"># Monte-Carlo simulations of AR1 process</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="c1">#  wwa_red = np.ndarray(shape=(nMC, nt, nf))</span>
    <span class="c1">#  AR1_q = np.ndarray(shape=(nt, nf))</span>

    <span class="c1">#  if nMC &gt;= 1:</span>
        <span class="c1">#  for i in tqdm(range(nMC), desc=&#39;Monte-Carlo simulations&#39;):</span>
            <span class="c1">#  r = ar1_sim(ys_cut, np.size(ts_cut), 1, ts=ts_cut)</span>
            <span class="c1">#  wwa_red[i, :, :], _, _, _ = wwz_func(r, ts_cut, freq, tau, c=c, Neff=Neff, nproc=nproc,</span>
                                                 <span class="c1">#  detrend=detrend, sg_kwargs=sg_kwargs,</span>
                                                 <span class="c1">#  gaussianize=gaussianize, standardize=standardize)</span>

        <span class="c1">#  for j in range(nt):</span>
            <span class="c1">#  for k in range(nf):</span>
                <span class="c1">#  AR1_q[j, k] = mquantiles(wwa_red[:, j, k], 0.95)</span>

    <span class="c1">#  else:</span>
        <span class="c1">#  AR1_q = None</span>
    <span class="n">wwa_red</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">AR1_q</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># calculate the cone of influence</span>
    <span class="n">coi</span> <span class="o">=</span> <span class="n">make_coi</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">Neff</span><span class="o">=</span><span class="n">Neff_coi</span><span class="p">)</span>

    <span class="n">Results</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Results&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;amplitude&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="s1">&#39;AR1_q&#39;</span><span class="p">,</span> <span class="s1">&#39;coi&#39;</span><span class="p">,</span> <span class="s1">&#39;freq&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;Neffs&#39;</span><span class="p">,</span> <span class="s1">&#39;coeff&#39;</span><span class="p">])</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">Results</span><span class="p">(</span><span class="n">amplitude</span><span class="o">=</span><span class="n">wwa</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="n">phase</span><span class="p">,</span> <span class="n">AR1_q</span><span class="o">=</span><span class="n">AR1_q</span><span class="p">,</span> <span class="n">coi</span><span class="o">=</span><span class="n">coi</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span> <span class="n">Neffs</span><span class="o">=</span><span class="n">Neffs</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="n">coeff</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="xwc"><a class="viewcode-back" href="../../../utils/wavelet/xwc.html#pyleoclim.utils.wavelet.xwc">[docs]</a><span class="k">def</span> <span class="nf">xwc</span><span class="p">(</span><span class="n">ys1</span><span class="p">,</span> <span class="n">ts1</span><span class="p">,</span> <span class="n">ys2</span><span class="p">,</span> <span class="n">ts2</span><span class="p">,</span> <span class="n">smooth_factor</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
        <span class="n">tau</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq_method</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">freq_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nMC</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
        <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the cross-wavelet coherence of two time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys1 : array</span>
<span class="sd">        first of two time series</span>
<span class="sd">    ys2 : array</span>
<span class="sd">        second of the two time series</span>
<span class="sd">    ts1 : array</span>
<span class="sd">        time axis of first time series</span>
<span class="sd">    ts2 : array</span>
<span class="sd">        time axis of the second time series</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    c : float</span>
<span class="sd">        the decay constant, the default value 1/(8*np.pi**2) is good for most of the cases</span>
<span class="sd">    Neff : int</span>
<span class="sd">        effective number of points</span>
<span class="sd">    nproc : int</span>
<span class="sd">        the number of processes for multiprocessing</span>
<span class="sd">    nMC : int</span>
<span class="sd">        the number of Monte-Carlo simulations</span>
<span class="sd">    detrend : string</span>
<span class="sd">        None - the original time series is assumed to have no trend;</span>
<span class="sd">        &#39;linear&#39; - a linear least-squares fit to `ys` is subtracted;</span>
<span class="sd">        &#39;constant&#39; - the mean of `ys` is subtracted</span>
<span class="sd">        &#39;savitzy-golay&#39; - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">        Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series</span>
<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.</span>
<span class="sd">    gaussianize : bool</span>
<span class="sd">        If True, gaussianizes the timeseries</span>
<span class="sd">    standardize : bool</span>
<span class="sd">        If True, standardizes the timeseries</span>
<span class="sd">    method : string</span>
<span class="sd">        &#39;Foster&#39; - the original WWZ method;</span>
<span class="sd">        &#39;Kirchner&#39; - the method Kirchner adapted from Foster;</span>
<span class="sd">        &#39;Kirchner_f2py&#39; - the method Kirchner adapted from Foster with f2py</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    res : dict</span>
<span class="sd">        contains the cross wavelet coherence, cross-wavelet phase,</span>
<span class="sd">        vector of frequency, evenly-spaced time points, AR1 sims, cone of influence</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.wwz_basic : Returns the weighted wavelet amplitude using the original method from Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.wwz_nproc : Returns the weighted wavelet amplitude using the original method from Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_basic : Return the weighted wavelet amplitude (WWA) modified by Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_nproc : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_numba : Return the weighted wavelet amplitude (WWA) modified by Kirchner using Numba package.</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_f2py : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Uses Fortran. Fastest method but requires a compiler. </span>

<span class="sd">    pyleoclim.utils.filter.savitzky_golay : Smooth (and optionally differentiate) data with a Savitzky-Golay filter.    </span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.make_freq_vector : Make frequency vector</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nMC</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nMC</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;nMC should be larger than or eaqual to 0.&quot;</span>

    <span class="k">if</span> <span class="n">tau</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lb1</span><span class="p">,</span> <span class="n">ub1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts1</span><span class="p">)</span>
        <span class="n">lb2</span><span class="p">,</span> <span class="n">ub2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts2</span><span class="p">)</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">lb1</span><span class="p">,</span> <span class="n">lb2</span><span class="p">])</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">ub1</span><span class="p">,</span> <span class="n">ub2</span><span class="p">])</span>

        <span class="n">inside</span> <span class="o">=</span> <span class="n">ts1</span><span class="p">[(</span><span class="n">ts1</span><span class="o">&gt;=</span><span class="n">lb</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ts1</span><span class="o">&lt;=</span><span class="n">ub</span><span class="p">)]</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">inside</span><span class="p">)</span><span class="o">//</span><span class="mi">10</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Setting tau=</span><span class="si">{</span><span class="n">tau</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="s1">...</span><span class="si">{</span><span class="n">tau</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span><span class="si">}</span><span class="s1">, ntau=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq_kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">freq_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">freq_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">make_freq_vector</span><span class="p">(</span><span class="n">ts1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">freq_method</span><span class="p">,</span> <span class="o">**</span><span class="n">freq_kwargs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Setting freq=</span><span class="si">{</span><span class="n">freq</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="s1">...</span><span class="si">{</span><span class="n">freq</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span><span class="si">}</span><span class="s1">, nfreq=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">ys1_cut</span><span class="p">,</span> <span class="n">ts1_cut</span><span class="p">,</span> <span class="n">freq1</span><span class="p">,</span> <span class="n">tau1</span> <span class="o">=</span> <span class="n">prepare_wwz</span><span class="p">(</span><span class="n">ys1</span><span class="p">,</span> <span class="n">ts1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">ys2_cut</span><span class="p">,</span> <span class="n">ts2_cut</span><span class="p">,</span> <span class="n">freq2</span><span class="p">,</span> <span class="n">tau2</span> <span class="o">=</span> <span class="n">prepare_wwz</span><span class="p">(</span><span class="n">ys2</span><span class="p">,</span> <span class="n">ts2</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tau1</span> <span class="o">!=</span> <span class="n">tau2</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inconsistent `tau`, recalculating...&#39;</span><span class="p">)</span>
        <span class="n">tau_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau2</span><span class="p">)])</span>
        <span class="n">tau_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau2</span><span class="p">)])</span>
        <span class="n">ntau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau2</span><span class="p">)])</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tau_min</span><span class="p">,</span> <span class="n">tau_max</span><span class="p">,</span> <span class="n">ntau</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">tau1</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">freq1</span> <span class="o">!=</span> <span class="n">freq2</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inconsistent `freq`, recalculating...&#39;</span><span class="p">)</span>
        <span class="n">freq_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">freq1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">freq2</span><span class="p">)])</span>
        <span class="n">freq_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">freq1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">freq2</span><span class="p">)])</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq2</span><span class="p">)])</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">freq_min</span><span class="p">,</span> <span class="n">freq_max</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq1</span>

    <span class="k">if</span> <span class="n">freq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># delete 0 frequency if present</span>

    <span class="n">res_wwz1</span> <span class="o">=</span> <span class="n">wwz</span><span class="p">(</span><span class="n">ys1_cut</span><span class="p">,</span> <span class="n">ts1_cut</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">Neff</span><span class="o">=</span><span class="n">Neff</span><span class="p">,</span> <span class="n">nMC</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                   <span class="n">nproc</span><span class="o">=</span><span class="n">nproc</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span>
                   <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
    <span class="n">res_wwz2</span> <span class="o">=</span> <span class="n">wwz</span><span class="p">(</span><span class="n">ys2_cut</span><span class="p">,</span> <span class="n">ts2_cut</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">Neff</span><span class="o">=</span><span class="n">Neff</span><span class="p">,</span> <span class="n">nMC</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                   <span class="n">nproc</span><span class="o">=</span><span class="n">nproc</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span>
                   <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

    <span class="n">wt_coeff1</span> <span class="o">=</span> <span class="n">res_wwz1</span><span class="o">.</span><span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">res_wwz1</span><span class="o">.</span><span class="n">coeff</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
    <span class="n">wt_coeff2</span> <span class="o">=</span> <span class="n">res_wwz2</span><span class="o">.</span><span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">res_wwz2</span><span class="o">.</span><span class="n">coeff</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>

    <span class="n">xw_coherence</span><span class="p">,</span> <span class="n">xw_phase</span> <span class="o">=</span> <span class="n">wavelet_coherence</span><span class="p">(</span><span class="n">wt_coeff1</span><span class="p">,</span> <span class="n">wt_coeff2</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">smooth_factor</span><span class="o">=</span><span class="n">smooth_factor</span><span class="p">)</span>
    <span class="n">xwt</span><span class="p">,</span> <span class="n">xw_amplitude</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cross_wt</span><span class="p">(</span><span class="n">wt_coeff1</span><span class="p">,</span> <span class="n">wt_coeff2</span><span class="p">)</span>

    <span class="c1"># Monte-Carlo simulations of AR1 process</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="c1">#  coherence_red = np.ndarray(shape=(nMC, nt, nf))</span>
    <span class="c1">#  AR1_q = np.ndarray(shape=(nt, nf))</span>
    <span class="n">coherence_red</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">AR1_q</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#  if nMC &gt;= 1:</span>

        <span class="c1">#  for i in tqdm(range(nMC), desc=&#39;Monte-Carlo simulations&#39;):</span>
            <span class="c1">#  r1 = ar1_sim(ys1_cut, np.size(ts1_cut), 1, ts=ts1_cut)</span>
            <span class="c1">#  r2 = ar1_sim(ys2_cut, np.size(ts2_cut), 1, ts=ts2_cut)</span>
            <span class="c1">#  res_wwz_r1 = wwz(r1, ts1_cut, tau=tau, freq=freq, c=c, Neff=Neff, nMC=0, nproc=nproc,</span>
                                                     <span class="c1">#  detrend=detrend, sg_kwargs=sg_kwrags,</span>
                                                     <span class="c1">#  gaussianize=gaussianize, standardize=standardize)</span>
            <span class="c1">#  res_wwz_r2 = wwz(r2, ts2_cut, tau=tau, freq=freq, c=c, Neff=Neff, nMC=0, nproc=nproc,</span>
                                                     <span class="c1">#  detrend=detrend, sg_kwargs=sg_kwargs,</span>
                                                     <span class="c1">#  gaussianize=gaussianize, standardize=standardize)</span>

            <span class="c1">#  wt_coeffr1 = res_wwz_r1.coeff[1] - res_wwz_r2.coeff[2]*1j</span>
            <span class="c1">#  wt_coeffr2 = res_wwz_r1.coeff[1] - res_wwz_r2.coeff[2]*1j</span>
            <span class="c1">#  coherence_red[i, :, :], phase_red = wavelet_coherence(wt_coeffr1, wt_coeffr2, freq, tau, smooth_factor=smooth_factor)</span>

        <span class="c1">#  for j in range(nt):</span>
            <span class="c1">#  for k in range(nf):</span>
                <span class="c1">#  AR1_q[j, k] = mquantiles(coherence_red[:, j, k], 0.95)</span>

    <span class="c1">#  else:</span>
        <span class="c1">#  AR1_q = None</span>

    <span class="n">coi</span> <span class="o">=</span> <span class="n">make_coi</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">Neff</span><span class="o">=</span><span class="n">Neff</span><span class="p">)</span>
    <span class="n">Results</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Results&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;xw_coherence&#39;</span><span class="p">,</span> <span class="s1">&#39;xw_amplitude&#39;</span><span class="p">,</span> <span class="s1">&#39;xw_phase&#39;</span><span class="p">,</span> <span class="s1">&#39;xwt&#39;</span><span class="p">,</span> <span class="s1">&#39;freq&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;AR1_q&#39;</span><span class="p">,</span> <span class="s1">&#39;coi&#39;</span><span class="p">])</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">Results</span><span class="p">(</span><span class="n">xw_coherence</span><span class="o">=</span><span class="n">xw_coherence</span><span class="p">,</span> <span class="n">xw_amplitude</span><span class="o">=</span><span class="n">xw_amplitude</span><span class="p">,</span> <span class="n">xw_phase</span><span class="o">=</span><span class="n">xw_phase</span><span class="p">,</span> <span class="n">xwt</span><span class="o">=</span><span class="n">xwt</span><span class="p">,</span>
                  <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span> <span class="n">AR1_q</span><span class="o">=</span><span class="n">AR1_q</span><span class="p">,</span> <span class="n">coi</span><span class="o">=</span><span class="n">coi</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>
<div class="viewcode-block" id="freq_vector_lomb_scargle"><a class="viewcode-back" href="../../../utils/wavelet/freq_vector_lomb_scargle.html#pyleoclim.utils.wavelet.freq_vector_lomb_scargle">[docs]</a><span class="k">def</span> <span class="nf">freq_vector_lomb_scargle</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ofac</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">hifac</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the frequency vector based on the REDFIT recommendation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>
<span class="sd">    dt : float</span>
<span class="sd">        The resolution of the data. If None, uses the median resolution. Defaults to None. </span>
<span class="sd">    nf : int</span>
<span class="sd">        Number of frequency points. </span>
<span class="sd">        If None, calculated as the difference between the highest and lowest frequencies (set by hifac and ofac) divided by resolution. Defaults to None</span>
<span class="sd">    ofac : float</span>
<span class="sd">        Oversampling rate that influences the resolution of the frequency axis,</span>
<span class="sd">                 when equals to 1, it means no oversamling (should be &gt;= 1).</span>
<span class="sd">                 The default value 4 is usually a good value.</span>
<span class="sd">    hifac : float</span>
<span class="sd">        fhi/fnyq (should be &lt;= 1), where fhi is the highest frequency that</span>
<span class="sd">        can be analyzed by the Lomb-Scargle algorithm and fnyq is the Nyquist frequency.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    freq : array</span>
<span class="sd">        the frequency vector</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    Trauth, M. H. MATLABÂ® Recipes for Earth Sciences. (Springer, 2015). pp 181.</span>


<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.freq_vector_welch : Return the frequency vector based on the Welch&#39;s method.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_nfft : Return the frequency vector based on NFFT</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_scale : Return the frequency vector based on scales</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_log : Return the frequency vector based on logspace </span>

<span class="sd">    pyleoclim.utils.wavelet.make_freq_vector : Make frequency vector</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="n">ofac</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">hifac</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;`ofac` should be &gt;= 1, and `hifac` should be &lt;= 1&quot;</span>
    
    <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
    <span class="n">flo</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span><span class="o">*</span><span class="n">ofac</span><span class="p">)</span>
    <span class="n">fhi</span> <span class="o">=</span> <span class="n">hifac</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">flo</span>
        <span class="n">nf</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">fhi</span> <span class="o">-</span> <span class="n">flo</span><span class="p">)</span> <span class="o">/</span> <span class="n">df</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">flo</span><span class="p">,</span> <span class="n">fhi</span><span class="p">,</span> <span class="n">nf</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">freq</span></div>

<div class="viewcode-block" id="freq_vector_welch"><a class="viewcode-back" href="../../../utils/wavelet/freq_vector_welch.html#pyleoclim.utils.wavelet.freq_vector_welch">[docs]</a><span class="k">def</span> <span class="nf">freq_vector_welch</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the frequency vector based on the Welch&#39;s method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    freq : array</span>
<span class="sd">        the frequency vector</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    https://github.com/scipy/scipy/blob/v0.14.0/scipy/signal/Spectral.py</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.freq_vector_lomb_scargle : Return the frequency vector based on the REDFIT </span>
<span class="sd">        recommendation.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_nfft : Return the frequency vector based on NFFT</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_scale : Return the frequency vector based on scales</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_log : Return the frequency vector based on logspace </span>

<span class="sd">    pyleoclim.utils.wavelet.make_freq_vector : Make frequency vector</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dt</span>
    <span class="k">if</span> <span class="n">nt</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_freq</span> <span class="o">=</span> <span class="n">nt</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_freq</span> <span class="o">=</span> <span class="p">(</span><span class="n">nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_freq</span><span class="p">)</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">/</span> <span class="n">nt</span>

    <span class="k">return</span> <span class="n">freq</span></div>

<div class="viewcode-block" id="freq_vector_nfft"><a class="viewcode-back" href="../../../utils/wavelet/freq_vector_nfft.html#pyleoclim.utils.wavelet.freq_vector_nfft">[docs]</a><span class="k">def</span> <span class="nf">freq_vector_nfft</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the frequency vector based on NFFT</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    freq : array</span>
<span class="sd">        the frequency vector</span>
<span class="sd">        </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.freq_vector_lomb_scargle : Return the frequency vector based on the REDFIT </span>
<span class="sd">        recommendation.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_welch : Return the frequency vector based on the Welch&#39;s method.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_scale : Return the frequency vector based on scales</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_log : Return the frequency vector based on logspace </span>

<span class="sd">    pyleoclim.utils.wavelet.make_freq_vector : Make frequency vector</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dt</span>
    <span class="n">n_freq</span> <span class="o">=</span> <span class="n">nt</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fs</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_freq</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">freq</span></div>

<div class="viewcode-block" id="freq_vector_scale"><a class="viewcode-back" href="../../../utils/wavelet/freq_vector_scale.html#pyleoclim.utils.wavelet.freq_vector_scale">[docs]</a><span class="k">def</span> <span class="nf">freq_vector_scale</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">nv</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the frequency vector based on scales</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>

<span class="sd">    nv : int</span>
<span class="sd">        the parameter that controls the number of freq points</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    freq : array</span>
<span class="sd">        the frequency vector</span>
<span class="sd">        </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.freq_vector_lomb_scargle : Return the frequency vector based on the REDFIT </span>
<span class="sd">        recommendation.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_welch : Return the frequency vector based on the Welch&#39;s method.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_nfft : Return the frequency vector based on NFFT</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_log : Return the frequency vector based on logspace </span>

<span class="sd">    pyleoclim.utils.wavelet.make_freq_vector : Make frequency vector</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">s0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
    <span class="n">a0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">nv</span><span class="p">)</span>
    <span class="n">noct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)))</span><span class="o">-</span><span class="mi">1</span>  <span class="c1"># number of octave</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">s0</span><span class="o">*</span><span class="n">a0</span><span class="o">**</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">noct</span><span class="o">*</span><span class="n">nv</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">scale</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">freq</span></div>

<div class="viewcode-block" id="freq_vector_log"><a class="viewcode-back" href="../../../utils/wavelet/freq_vector_log.html#pyleoclim.utils.wavelet.freq_vector_log">[docs]</a><span class="k">def</span> <span class="nf">freq_vector_log</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">nfreq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the frequency vector based on logspace</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>

<span class="sd">    nv : int</span>
<span class="sd">        the parameter that controls the number of freq points</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    freq : array</span>
<span class="sd">        the frequency vector</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.freq_vector_lomb_scargle : Return the frequency vector based on the REDFIT </span>
<span class="sd">        recommendation.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_welch : Return the frequency vector based on the Welch&#39;s method.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_nfft : Return the frequency vector based on NFFT</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_scale : Return the frequency vector based on scales</span>

<span class="sd">    pyleoclim.utils.wavelet.make_freq_vector : Make frequency vector</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dt</span>
    <span class="k">if</span> <span class="n">nfreq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="n">nt</span><span class="o">//</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">fmin</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
    <span class="n">fmax</span> <span class="o">=</span> <span class="n">fs</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">fmin</span><span class="p">)</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">fmax</span><span class="p">)</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">freq</span></div>

<div class="viewcode-block" id="make_freq_vector"><a class="viewcode-back" href="../../../utils/wavelet/make_freq_vector.html#pyleoclim.utils.wavelet.make_freq_vector">[docs]</a><span class="k">def</span> <span class="nf">make_freq_vector</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Make frequency vector</span>

<span class="sd">    This function selects among five methods to obtain the frequency</span>
<span class="sd">    vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ts : array</span>
<span class="sd">        Time axis of the time series</span>
<span class="sd">    method : string</span>
<span class="sd">        The method to use. Options are &#39;log&#39; (default), &#39;nfft&#39;, &#39;lomb_scargle&#39;, &#39;welch&#39;, and &#39;scale&#39;</span>
<span class="sd">    kwargs : dict, optional</span>
<span class="sd">            For Lomb_Scargle, additional parameters may be passed:</span>
<span class="sd">            - nf (int): number of frequency points</span>
<span class="sd">            - ofac (float): Oversampling rate that influences the resolution of the frequency axis,</span>
<span class="sd">                 when equals to 1, it means no oversamling (should be &gt;= 1).</span>
<span class="sd">                 The default value 4 is usaually a good value.</span>
<span class="sd">            - hifac (float): fhi/fnyq (should be &gt;= 1), where fhi is the highest frequency that</span>
<span class="sd">                  can be analyzed by the Lomb-Scargle algorithm and fnyq is the Nyquist frequency.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    freq : array</span>
<span class="sd">        the frequency vector</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.freq_vector_lomb_scargle : Return the frequency vector based on the REDFIT </span>
<span class="sd">        recommendation.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_welch : Return the frequency vector based on the Welch&#39;s method.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_nfft : Return the frequency vector based on NFFT</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_scale : Return the frequency vector based on scales</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_log : Return the frequency vector based on logspace </span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;lomb_scargle&#39;</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq_vector_lomb_scargle</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;welch&#39;</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq_vector_welch</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nfft&#39;</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq_vector_nfft</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;scale&#39;</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq_vector_scale</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq_vector_log</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;This method is not supported&#39;</span><span class="p">)</span>
    <span class="c1">#  freq = freq[1:]  # discard the first element 0</span>

    <span class="k">return</span> <span class="n">freq</span></div>

<div class="viewcode-block" id="beta_estimation"><a class="viewcode-back" href="../../../utils/wavelet/beta_estimation.html#pyleoclim.utils.wavelet.beta_estimation">[docs]</a><span class="k">def</span> <span class="nf">beta_estimation</span><span class="p">(</span><span class="n">psd</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Estimate the power slope of a 1/f^beta process.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    psd : array</span>
<span class="sd">        the power spectral density</span>
<span class="sd">    freq : array</span>
<span class="sd">        the frequency vector</span>
<span class="sd">    fmin : float</span>
<span class="sd">        the min of frequency range for beta estimation</span>
<span class="sd">    fmax : float</span>
<span class="sd">        the max of frequency range for beta estimation</span>
<span class="sd">    verbose : bool</span>
<span class="sd">         if True, will print out debug information</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    beta : float</span>
<span class="sd">        the estimated slope</span>
<span class="sd">    f_binned : array</span>
<span class="sd">        binned frequency vector</span>
<span class="sd">    psd_binned : array</span>
<span class="sd">        binned power spectral density</span>
<span class="sd">    Y_reg : array</span>
<span class="sd">        prediction based on linear regression</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># drop the PSD at frequency zero</span>
    <span class="k">if</span> <span class="n">freq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">psd</span> <span class="o">=</span> <span class="n">psd</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">if</span> <span class="n">fmin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">fmin</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="n">Results</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Results&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;beta&#39;</span><span class="p">,</span> <span class="s1">&#39;f_binned&#39;</span><span class="p">,</span> <span class="s1">&#39;psd_binned&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_reg&#39;</span><span class="p">,</span> <span class="s1">&#39;std_err&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">fmax</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">fmin</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">fmin</span><span class="p">,</span> <span class="n">fmax</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">freq</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WRONG&#39;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Results</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">f_binned</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">psd_binned</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">Y_reg</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">std_err</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="c1"># frequency binning start</span>
    <span class="n">fminindx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">freq</span> <span class="o">&gt;=</span> <span class="n">fmin</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">fmaxindx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">freq</span> <span class="o">&lt;=</span> <span class="n">fmax</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">fminindx</span> <span class="o">&gt;=</span> <span class="n">fmaxindx</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Results</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">f_binned</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">psd_binned</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">Y_reg</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">std_err</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="n">logf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
    <span class="n">logf_step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">logf</span><span class="p">))</span>
    <span class="n">logf_start</span> <span class="o">=</span> <span class="n">logf</span><span class="p">[</span><span class="n">fminindx</span><span class="p">]</span>
    <span class="n">logf_end</span> <span class="o">=</span> <span class="n">logf</span><span class="p">[</span><span class="n">fmaxindx</span><span class="p">]</span>
    <span class="n">logf_binedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">logf_start</span><span class="p">,</span> <span class="n">logf_end</span><span class="o">+</span><span class="n">logf_step</span><span class="p">,</span> <span class="n">logf_step</span><span class="p">)</span>

    <span class="n">n_intervals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">logf_binedges</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">logpsd_binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_intervals</span><span class="p">)</span>
    <span class="n">logf_binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_intervals</span><span class="p">)</span>

    <span class="n">logpsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_intervals</span><span class="p">):</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="n">logf_binedges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">logf_binedges</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">logf</span> <span class="o">&gt;=</span> <span class="n">lb</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">logf</span> <span class="o">&lt;=</span> <span class="n">ub</span><span class="p">))</span>

        <span class="n">logpsd_binned</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">logpsd</span><span class="p">[</span><span class="n">q</span><span class="p">])</span>
        <span class="n">logf_binned</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ub</span> <span class="o">+</span> <span class="n">lb</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">f_binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logf_binned</span><span class="p">)</span>
    <span class="n">psd_binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logpsd_binned</span><span class="p">)</span>
    <span class="c1"># frequency binning end</span>

    <span class="c1"># linear regression below</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">psd_binned</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_binned</span><span class="p">)</span>
    <span class="n">X_ex</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">OLS</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">X_ex</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;drop&#39;</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">Y_reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">std_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="o">-</span><span class="n">results</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># the slope we want</span>
        <span class="n">Y_reg</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>  <span class="c1"># prediction based on linear regression</span>
        <span class="n">std_err</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">bse</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">Results</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">f_binned</span><span class="o">=</span><span class="n">f_binned</span><span class="p">,</span> <span class="n">psd_binned</span><span class="o">=</span><span class="n">psd_binned</span><span class="p">,</span> <span class="n">Y_reg</span><span class="o">=</span><span class="n">Y_reg</span><span class="p">,</span> <span class="n">std_err</span><span class="o">=</span><span class="n">std_err</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="beta2HurstIndex"><a class="viewcode-back" href="../../../utils/wavelet/beta2HurstIndex.html#pyleoclim.utils.wavelet.beta2HurstIndex">[docs]</a><span class="k">def</span> <span class="nf">beta2HurstIndex</span><span class="p">(</span><span class="n">beta</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Translate psd slope to Hurst index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    beta : float</span>
<span class="sd">        the estimated slope of a power spectral density curve</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    H : float</span>
<span class="sd">        Hurst index, should be in (0, 1)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    Equation 2 in http://www.bearcave.com/misl/misl_tech/wavelets/hurst/</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

    <span class="k">return</span> <span class="n">H</span></div>

<div class="viewcode-block" id="psd_ar"><a class="viewcode-back" href="../../../utils/wavelet/psd_ar.html#pyleoclim.utils.wavelet.psd_ar">[docs]</a><span class="k">def</span> <span class="nf">psd_ar</span><span class="p">(</span><span class="n">var_noise</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">ar_params</span><span class="p">,</span> <span class="n">f_sampling</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the theoretical power spectral density (PSD) of an autoregressive model</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    var_noise : float</span>
<span class="sd">        the variance of the noise of the AR process</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    ar_params : array</span>
<span class="sd">        autoregressive coefficients, not including zero-lag</span>
<span class="sd">    f_sampling : float</span>
<span class="sd">        sampling frequency</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    psd : array</span>
<span class="sd">        power spectral density</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ar_params</span><span class="p">)</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">freq</span><span class="o">/</span><span class="n">f_sampling</span><span class="p">)</span>

    <span class="n">psd</span> <span class="o">=</span> <span class="n">var_noise</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ar_params</span><span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">return</span> <span class="n">psd</span></div>

<div class="viewcode-block" id="fBMsim"><a class="viewcode-back" href="../../../utils/wavelet/fBMsim.html#pyleoclim.utils.wavelet.fBMsim">[docs]</a><span class="k">def</span> <span class="nf">fBMsim</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="mf">0.25</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Simple method to generate fractional Brownian Motion</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    N : int</span>
<span class="sd">        the length of the simulated time series</span>
<span class="sd">    H : float</span>
<span class="sd">        Hurst index, should be in (0, 1). The relationship between H and the scaling exponent beta is</span>
<span class="sd">        H = (beta-1) / 2</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    xfBm : array</span>
<span class="sd">        the simulated fractional Brownian Motion time series</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    1. http://cours-physique.lps.ens.fr/index.php/TD11_Correlated_Noise_2011</span>
<span class="sd">    2. https://www.wikiwand.com/en/Fractional_Brownian_motion</span>

<span class="sd">    @authors: jeg, fzhu</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">N</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">H</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">H</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;H should be in (0, 1)!&quot;</span>

    <span class="n">HH</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">H</span>

    <span class="n">ns</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span>  <span class="c1"># number of steps</span>
    <span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ns</span><span class="p">,</span> <span class="n">ns</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">)</span>
            <span class="n">covariance</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">covariance</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">HH</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">HH</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">HH</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>

    <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">covariance</span><span class="p">)</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ns</span><span class="p">,</span> <span class="n">ns</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span>

    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">((</span><span class="n">ns</span><span class="p">))</span>
    <span class="n">eta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span>

    <span class="n">xfBm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">xfBm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">xfBm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">xfBm</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">eta</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">xfBm</span></div>

<div class="viewcode-block" id="psd_fBM"><a class="viewcode-back" href="../../../utils/wavelet/psd_fBm.html#pyleoclim.utils.wavelet.psd_fBM">[docs]</a><span class="k">def</span> <span class="nf">psd_fBM</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">H</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the theoretical psd of a fBM</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    ts : array</span>
<span class="sd">        the time axis of the time series</span>
<span class="sd">    H : float</span>
<span class="sd">        Hurst index, should be in (0, 1)</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>

<span class="sd">    psd : array</span>
<span class="sd">        power spectral density</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    Flandrin, P. On the spectrum of fractional Brownian motions.</span>
<span class="sd">    IEEE Transactions on Information Theory 35, 197â€“199 (1989).</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
    <span class="n">psd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nf</span><span class="p">))</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nf</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">T</span>
        <span class="n">psd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">H</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span><span class="o">/</span><span class="n">tmp</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">H</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">psd</span></div>

<div class="viewcode-block" id="get_wwz_func"><a class="viewcode-back" href="../../../utils/wavelet/get_wwz_func.html#pyleoclim.utils.wavelet.get_wwz_func">[docs]</a><span class="k">def</span> <span class="nf">get_wwz_func</span><span class="p">(</span><span class="n">nproc</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the wwz function to use.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    nproc : int</span>
<span class="sd">        the number of processes for multiprocessing</span>
<span class="sd">    method : string</span>
<span class="sd">        &#39;Foster&#39; - the original WWZ method;</span>
<span class="sd">        &#39;Kirchner&#39; - the method Kirchner adapted from Foster;</span>
<span class="sd">        &#39;Kirchner_f2py&#39; - the method Kirchner adapted from Foster with f2py</span>
<span class="sd">        &#39;Kirchner_numba&#39; - Kirchner&#39;s algorithm with Numba support for acceleration (default)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    wwz_func : function</span>
<span class="sd">        the wwz function to use</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">assertPositiveInt</span><span class="p">(</span><span class="n">nproc</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Foster&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nproc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">wwz_func</span> <span class="o">=</span> <span class="n">wwz_basic</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wwz_func</span> <span class="o">=</span> <span class="n">wwz_nproc</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Kirchner&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nproc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">wwz_func</span> <span class="o">=</span> <span class="n">kirchner_basic</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wwz_func</span> <span class="o">=</span> <span class="n">kirchner_nproc</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Kirchner_f2py&#39;</span><span class="p">:</span>
        <span class="n">wwz_func</span> <span class="o">=</span> <span class="n">kirchner_f2py</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># default method; Kirchner&#39;s algorithm with Numba support for acceleration</span>
        <span class="n">wwz_func</span> <span class="o">=</span> <span class="n">kirchner_numba</span>

    <span class="k">return</span> <span class="n">wwz_func</span></div>

<div class="viewcode-block" id="prepare_wwz"><a class="viewcode-back" href="../../../utils/wavelet/prepare_wwz.html#pyleoclim.utils.wavelet.prepare_wwz">[docs]</a><span class="k">def</span> <span class="nf">prepare_wwz</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq_method</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">freq_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">len_bd</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bc_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the truncated time series with NaNs deleted and estimate frequency vector and tau</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series, NaNs will be deleted automatically</span>
<span class="sd">    ts : array</span>
<span class="sd">        the time points, if `ys` contains any NaNs, some of the time points will be deleted accordingly</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency. If None, will be ganerated according to freq_method.</span>
<span class="sd">        may be set.</span>
<span class="sd">    freq_method : str</span>
<span class="sd">        when freq=None, freq will be ganerated according to freq_method</span>
<span class="sd">    freq_kwargs : str</span>
<span class="sd">        used when freq=None for certain methods</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>
<span class="sd">        if the boundaries of tau are not exactly on two of the time axis points, then tau will be adjusted to be so</span>
<span class="sd">    len_bd : int</span>
<span class="sd">        the number of the ghost grids want to create on each boundary</span>
<span class="sd">    bc_mode : string</span>
<span class="sd">        {&#39;constant&#39;, &#39;edge&#39;, &#39;linear_ramp&#39;, &#39;maximum&#39;, &#39;mean&#39;, &#39;median&#39;, &#39;minimum&#39;, &#39;reflect&#39; , &#39;symmetric&#39;, &#39;wrap&#39;}</span>
<span class="sd">        For more details, see np.lib.pad()</span>
<span class="sd">    reflect_type : string</span>
<span class="sd">         {â€˜evenâ€™, â€˜oddâ€™}, optional</span>
<span class="sd">         Used in â€˜reflectâ€™, and â€˜symmetricâ€™. The â€˜evenâ€™ style is the default with an unaltered reflection around the edge value.</span>
<span class="sd">         For the â€˜oddâ€™ style, the extented part of the array is created by subtracting the reflected values from two times the edge value.</span>
<span class="sd">         For more details, see np.lib.pad()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    ys_cut : array</span>
<span class="sd">        the truncated time series with NaNs deleted</span>
<span class="sd">    ts_cut : array</span>
<span class="sd">        the truncated time axis of the original time series with NaNs deleted</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ys</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">clean_ts</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tau</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">med_res</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">//</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">)))</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span><span class="o">//</span><span class="mi">10</span><span class="p">),</span> <span class="mi">50</span><span class="p">,</span> <span class="n">med_res</span><span class="p">]))</span>

    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The input tau contains some NaNs.&quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;It will be regenerated using the boundarys of the time axis of the time series with NaNs deleted,&quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;with the length of the size of the input tau.&quot;</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;tau should be within the time span of the time series.&quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;Note that sometimes if the leading points of the time series are NaNs,&quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;they will be deleted and cause np.min(tau) &lt; np.min(ts).&quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;A new tau with the same size of the input tau will be generated.&quot;</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ts</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The boundaries of tau are not exactly on two of the time axis points,&quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;and it will be adjusted to be so.&quot;</span><span class="p">)</span>
        <span class="n">tau_lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">ts</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau</span><span class="p">)])</span>
        <span class="n">tau_ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">ts</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau</span><span class="p">)])</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tau_lb</span><span class="p">,</span> <span class="n">tau_ub</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>

    <span class="c1"># boundary condition</span>
    <span class="k">if</span> <span class="n">len_bd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
        <span class="n">dtau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>
        <span class="n">len_bd_tau</span> <span class="o">=</span> <span class="n">len_bd</span><span class="o">*</span><span class="n">dt</span><span class="o">//</span><span class="n">dtau</span>

        <span class="k">if</span> <span class="n">bc_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">]:</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="p">(</span><span class="n">len_bd</span><span class="p">,</span> <span class="n">len_bd</span><span class="p">),</span> <span class="n">bc_mode</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="n">reflect_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="p">(</span><span class="n">len_bd</span><span class="p">,</span> <span class="n">len_bd</span><span class="p">),</span> <span class="n">bc_mode</span><span class="p">)</span>

        <span class="n">ts_left_bd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dt</span><span class="o">*</span><span class="n">len_bd</span><span class="p">,</span> <span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dt</span><span class="p">,</span> <span class="n">len_bd</span><span class="p">)</span>
        <span class="n">ts_right_bd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dt</span><span class="p">,</span> <span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dt</span><span class="o">*</span><span class="n">len_bd</span><span class="p">,</span> <span class="n">len_bd</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ts_left_bd</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">ts_right_bd</span><span class="p">))</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The tau will be regenerated to fit the boundary condition.&quot;</span><span class="p">)</span>
        <span class="n">tau_left_bd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tau</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dtau</span><span class="o">*</span><span class="n">len_bd_tau</span><span class="p">,</span> <span class="n">tau</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dtau</span><span class="p">,</span> <span class="n">len_bd_tau</span><span class="p">)</span>
        <span class="n">tau_right_bd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tau</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dtau</span><span class="p">,</span> <span class="n">tau</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dtau</span><span class="o">*</span><span class="n">len_bd_tau</span><span class="p">,</span> <span class="n">len_bd_tau</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">tau_left_bd</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">tau_right_bd</span><span class="p">))</span>

    <span class="c1"># truncate the time series when the range of tau is smaller than that of the time series</span>
    <span class="n">ts_cut</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">ts</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ts</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau</span><span class="p">))]</span>
    <span class="n">ys_cut</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">ts</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ts</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau</span><span class="p">))]</span>

    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq_kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">freq_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">freq_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">make_freq_vector</span><span class="p">(</span><span class="n">ts_cut</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">freq_method</span><span class="p">,</span> <span class="o">**</span><span class="n">freq_kwargs</span><span class="p">)</span>

    <span class="c1"># remove 0 in freq vector</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="n">freq</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">ys_cut</span><span class="p">,</span> <span class="n">ts_cut</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span></div>

<div class="viewcode-block" id="cross_wt"><a class="viewcode-back" href="../../../utils/wavelet/cross_wt.html#pyleoclim.utils.wavelet.cross_wt">[docs]</a><span class="k">def</span> <span class="nf">cross_wt</span><span class="p">(</span><span class="n">coeff1</span><span class="p">,</span> <span class="n">coeff2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the cross wavelet transform.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    coeff1 : array</span>
<span class="sd">        the first of two sets of wavelet transform coefficients **in the form of a1 + a2*1j**</span>
<span class="sd">    coeff2 : array</span>
<span class="sd">        the second of two sets of wavelet transform coefficients **in the form of a1 + a2*1j**</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array&#39;</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    xw_amplitude : array</span>
<span class="sd">        the cross wavelet amplitude</span>
<span class="sd">    xw_phase : array</span>
<span class="sd">        the cross wavelet phase</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    Grinsted, A., Moore, J. C. &amp; Jevrejeva, S. Application of the cross wavelet transform and</span>
<span class="sd">    wavelet coherence to geophysical time series. Nonlin. Processes Geophys. 11, 561â€“566 (2004).</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">xwt</span> <span class="o">=</span> <span class="n">coeff1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">coeff2</span><span class="p">)</span>
    <span class="n">xw_amplitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">xwt</span><span class="o">.</span><span class="n">real</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">xwt</span><span class="o">.</span><span class="n">imag</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">xw_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">xwt</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">xwt</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xwt</span><span class="p">,</span> <span class="n">xw_amplitude</span><span class="p">,</span> <span class="n">xw_phase</span></div>

<div class="viewcode-block" id="wavelet_coherence"><a class="viewcode-back" href="../../../utils/wavelet/wavelet_coherence.html#pyleoclim.utils.wavelet.wavelet_coherence">[docs]</a><span class="k">def</span> <span class="nf">wavelet_coherence</span><span class="p">(</span><span class="n">coeff1</span><span class="p">,</span> <span class="n">coeff2</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">smooth_factor</span><span class="o">=</span><span class="mf">0.25</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the cross wavelet coherence.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    coeff1 : array</span>
<span class="sd">        the first of two sets of wavelet transform coefficients **in the form of a1 + a2*1j**</span>
<span class="sd">    coeff2 : array</span>
<span class="sd">        the second of two sets of wavelet transform coefficients **in the form of a1 + a2*1j**</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array&#39;</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    xw_coherence : array</span>
<span class="sd">        the cross wavelet coherence</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    1. Grinsted, A., Moore, J. C. &amp; Jevrejeva, S. Application of the cross wavelet transform and</span>
<span class="sd">        wavelet coherence to geophysical time series. Nonlin. Processes Geophys. 11, 561â€“566 (2004).</span>
<span class="sd">    2. Matlab code by Grinsted (https://github.com/grinsted/wavelet-coherence)</span>
<span class="sd">    3. Python code by Sebastian Krieger (https://github.com/regeirk/pycwt)</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">rect</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Rectangular function adapted from https://github.com/regeirk/pycwt/blob/master/pycwt/helpers.py</span>

<span class="sd">        Args:</span>
<span class="sd">            length (int): length of the rectangular function</span>
<span class="sd">            normalize (bool): normalize or not</span>

<span class="sd">        Returns:</span>
<span class="sd">            rect (array): the (normalized) rectangular function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
        <span class="n">rect</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rect</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">rect</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">rect</span> <span class="o">/=</span> <span class="n">rect</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">rect</span>

    <span class="k">def</span> <span class="nf">smoothing</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">snorm</span><span class="p">,</span> <span class="n">dj</span><span class="p">,</span> <span class="n">smooth_factor</span><span class="o">=</span><span class="n">smooth_factor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Smoothing function adapted from https://github.com/regeirk/pycwt/blob/master/pycwt/helpers.py</span>

<span class="sd">        Args</span>
<span class="sd">        ----</span>

<span class="sd">        coeff : array</span>
<span class="sd">            the wavelet coefficients get from wavelet transform **in the form of a1 + a2*1j**</span>
<span class="sd">        snorm : array</span>
<span class="sd">            normalized scales</span>
<span class="sd">        dj : float</span>
<span class="sd">            it satisfies the equation [ Sj = S0 * 2**(j*dj) ]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        rect : array</span>
<span class="sd">            the (normalized) rectangular function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">fft_kwargs</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">))))}</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>

        <span class="c1"># Smooth in time</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">fft_kwargs</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])[</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="n">k</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># Notes by Smoothing by Gaussian window (absolute value of wavelet function)</span>
        <span class="c1"># using the convolution theorem: multiplication by Gaussian curve in</span>
        <span class="c1"># Fourier domain for each scale, outer product of scale and frequency</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">smooth_factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">snorm</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">k2</span><span class="p">)</span>  <span class="c1"># Outer product</span>
        <span class="n">smooth</span> <span class="o">=</span> <span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">F</span> <span class="o">*</span> <span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">fft_kwargs</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])),</span>
                          <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># Along Fourier frequencies</span>
                          <span class="o">**</span><span class="n">fft_kwargs</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">overwrite_x</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n</span><span class="p">]</span>  <span class="c1"># Remove possibly padded region due to FFT</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">W</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">real</span>

        <span class="c1"># Smooth in scale</span>
        <span class="n">wsize</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">/</span> <span class="n">dj</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="n">win</span> <span class="o">=</span> <span class="n">rect</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">wsize</span><span class="p">)),</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">win</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">S</span>

    <span class="n">xwt</span> <span class="o">=</span> <span class="n">coeff1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">coeff2</span><span class="p">)</span>
    <span class="n">power1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coeff1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">power2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coeff2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">scales</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">freq</span>  <span class="c1"># `scales` here is the `Period` axis in the wavelet plot</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>
    <span class="n">snorm</span> <span class="o">=</span> <span class="n">scales</span> <span class="o">/</span> <span class="n">dt</span>  <span class="c1"># normalized scales</span>

    <span class="c1"># with WWZ method, we don&#39;t have a constant dj, so we will just take the average over the whole scale range</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">scales</span><span class="p">)</span>
    <span class="n">s0</span> <span class="o">=</span> <span class="n">scales</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sN</span> <span class="o">=</span> <span class="n">scales</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">sN</span><span class="o">/</span><span class="n">s0</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>

    <span class="n">S12</span> <span class="o">=</span> <span class="n">smoothing</span><span class="p">(</span><span class="n">xwt</span><span class="o">/</span><span class="n">scales</span><span class="p">,</span> <span class="n">snorm</span><span class="p">,</span> <span class="n">dj</span><span class="p">)</span>
    <span class="n">S1</span> <span class="o">=</span> <span class="n">smoothing</span><span class="p">(</span><span class="n">power1</span><span class="o">/</span><span class="n">scales</span><span class="p">,</span> <span class="n">snorm</span><span class="p">,</span> <span class="n">dj</span><span class="p">)</span>
    <span class="n">S2</span> <span class="o">=</span> <span class="n">smoothing</span><span class="p">(</span><span class="n">power2</span><span class="o">/</span><span class="n">scales</span><span class="p">,</span> <span class="n">snorm</span><span class="p">,</span> <span class="n">dj</span><span class="p">)</span>
    <span class="n">xw_coherence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S12</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">wcs</span> <span class="o">=</span> <span class="n">S12</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S2</span><span class="p">))</span>
    <span class="n">xw_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">wcs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xw_coherence</span><span class="p">,</span> <span class="n">xw_phase</span></div>

<div class="viewcode-block" id="reconstruct_ts"><a class="viewcode-back" href="../../../utils/wavelet/reconstruct_ts.html#pyleoclim.utils.wavelet.reconstruct_ts">[docs]</a><span class="k">def</span> <span class="nf">reconstruct_ts</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">len_bd</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Reconstruct the normalized time series from the wavelet coefficients.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    coeff : array</span>
<span class="sd">        the coefficients of the corresponding basis functions (a0, a1, a2)</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency of the basis functions</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points of the basis functions</span>
<span class="sd">    t : array</span>
<span class="sd">        the specified evenly-spaced time points of the reconstructed time series</span>
<span class="sd">    len_bd : int</span>
<span class="sd">        the number of the ghost grids want to creat on each boundary</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    rec_ts : array</span>
<span class="sd">        the reconstructed normalized time series</span>
<span class="sd">    t : array</span>
<span class="sd">        the evenly-spaced time points of the reconstructed time series</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">freq</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">len_bd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">t_left_bd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dt</span><span class="o">*</span><span class="n">len_bd</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dt</span><span class="p">,</span> <span class="n">len_bd</span><span class="p">)</span>
        <span class="n">t_right_bd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dt</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dt</span><span class="o">*</span><span class="n">len_bd</span><span class="p">,</span> <span class="n">len_bd</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">t_left_bd</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t_right_bd</span><span class="p">))</span>

    <span class="n">ntau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">a_0</span><span class="p">,</span> <span class="n">a_1</span><span class="p">,</span> <span class="n">a_2</span> <span class="o">=</span> <span class="n">coeff</span>

    <span class="n">rec_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nf</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntau</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a_0</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a_1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a_1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dz</span> <span class="o">=</span> <span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">phi_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>
                <span class="n">phi_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>

                <span class="n">rec_ts</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a_0</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">a_1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">phi_1</span> <span class="o">+</span> <span class="n">a_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">phi_2</span><span class="p">)</span>

    <span class="n">rec_ts</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">rec_ts</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rec_ts</span><span class="p">,</span> <span class="n">t</span></div>

</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2017-2020, Deborah Khider, Feng Zhu, Julien Emile-Geay, Alexander James

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>