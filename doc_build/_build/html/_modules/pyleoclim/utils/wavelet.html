<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyleoclim.utils.wavelet &mdash; Pyleoclim 0.6.3beta documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/rtd_sphinx_search.min.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/js/rtd_sphinx_search.min.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> Pyleoclim
            <img src="../../../_static/pyleoclim_insigna_full_white.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.6.3beta
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Working with Pyleoclim</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing Pyleoclim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../core/ui.html">Pyleoclim User API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced functionalities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../utils/introduction.html">Pyleoclim Utilities API (pyleoclim.utils)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting Involved</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../citation.html">Citing Pyleoclim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribution_guide.html">Contributing to Pyleoclim</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Pyleoclim</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>pyleoclim.utils.wavelet</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pyleoclim.utils.wavelet</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Tue Feb 25 08:14:31 2020</span>

<span class="sd">@author: deborahkhider</span>

<span class="sd">Functions concerning wavelet analysis</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1">#&#39;cwt&#39;,</span>
    <span class="s1">&#39;wwz&#39;</span><span class="p">,</span>
    <span class="s1">&#39;xwc&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="kn">from</span> <span class="nn">pathos.multiprocessing</span> <span class="kn">import</span> <span class="n">ProcessingPool</span> <span class="k">as</span> <span class="n">Pool</span>
<span class="kn">import</span> <span class="nn">numba</span> <span class="k">as</span> <span class="nn">nb</span>
<span class="kn">from</span> <span class="nn">numba.core.errors</span> <span class="kn">import</span> <span class="n">NumbaPerformanceWarning</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">scipy.fftpack</span> <span class="k">as</span> <span class="nn">fft</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fminbound</span>
<span class="kn">from</span> <span class="nn">scipy.special._ufuncs</span> <span class="kn">import</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">gammainc</span>

<span class="c1">#from .tsmodel import ar1_sim</span>
<span class="kn">from</span> <span class="nn">.tsutils</span> <span class="kn">import</span> <span class="n">preprocess</span>
<span class="kn">from</span> <span class="nn">.tsbase</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">clean_ts</span><span class="p">,</span>
    <span class="n">is_evenly_spaced</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">.filter</span> <span class="kn">import</span> <span class="n">ts_pad</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">NumbaPerformanceWarning</span><span class="p">)</span>

<span class="c1">#---------------</span>
<span class="c1">#Wrapper functions</span>
<span class="c1">#---------------</span>

<span class="c1">#----------------</span>
<span class="c1">#Main Functions</span>
<span class="c1">#----------------</span>

<div class="viewcode-block" id="AliasFilter"><a class="viewcode-back" href="../../../utils/wavelet/AliasFilter.html#pyleoclim.utils.wavelet.AliasFilter">[docs]</a><span class="k">class</span> <span class="nc">AliasFilter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Performing anti-alias filter on a psd </span>
<span class="sd">    </span>
<span class="sd">    experimental: Use at your own risk</span>
<span class="sd">    </span>
<span class="sd">    @author: fzhu</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">alias_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">pwr</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">f_limit</span><span class="p">,</span> <span class="n">avgs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; anti_alias filter</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        freq : array</span>
<span class="sd">            vector of frequencies in power spectrum</span>
<span class="sd">        pwr : array</span>
<span class="sd">            vector of spectral power corresponding to frequencies &quot;freq&quot;</span>
<span class="sd">        fs : float</span>
<span class="sd">            sampling frequency</span>
<span class="sd">        fc : float</span>
<span class="sd">            corner frequency for 1/f^2 steepening of power spectrum</span>
<span class="sd">        f_limit : float</span>
<span class="sd">            lower frequency limit for estimating misfit of model-plus-alias spectrum vs. measured power</span>
<span class="sd">        avgs : int</span>
<span class="sd">            flag for whether spectrum is derived from instantaneous point measurements (avgs&lt;&gt;1)</span>
<span class="sd">            OR from measurements averaged over each sampling interval (avgs==1)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        alpha : float</span>
<span class="sd">            best-fit exponent of power-law model</span>
<span class="sd">        filtered_pwr : array</span>
<span class="sd">            vector of alias-filtered spectral power</span>
<span class="sd">        model_pwr : array</span>
<span class="sd">            vector of modeled spectral power</span>
<span class="sd">        aliased_pwr : array</span>
<span class="sd">            vector of modeled spectral power, plus aliases</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>

<span class="sd">        Kirchner, J. W. Aliasing in 1/f(alpha) noise spectra: origins, consequences, and remedies.</span>
<span class="sd">        Phys Rev E Stat Nonlin Soft Matter Phys 71, 66110 (2005).</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">log_pwr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pwr</span><span class="p">)</span>
        <span class="n">freq_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">freq</span> <span class="o">&gt;</span> <span class="n">f_limit</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span>  <span class="c1"># convert True &amp; False to 1 &amp; 0</span>

        <span class="n">alpha_upper_bound</span> <span class="o">=</span> <span class="mi">5</span>

        <span class="k">if</span> <span class="n">avgs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">alpha_lower_bound</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.9</span>  <span class="c1"># if measurements are time-averaged</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha_lower_bound</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.9</span>  <span class="c1"># if measurements are point samples</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misfit</span><span class="p">,</span> <span class="n">alpha_lower_bound</span><span class="p">,</span> <span class="n">alpha_upper_bound</span><span class="p">,</span>
                                   <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">log_pwr</span><span class="p">,</span> <span class="n">freq_mask</span><span class="p">,</span> <span class="n">avgs</span><span class="p">),</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>

        <span class="n">model_pwr</span><span class="p">,</span> <span class="n">aliased_pwr</span><span class="p">,</span> <span class="n">RMSE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">log_pwr</span><span class="p">,</span> <span class="n">freq_mask</span><span class="p">,</span> <span class="n">avgs</span><span class="p">)</span>
        <span class="n">filtered_pwr</span> <span class="o">=</span> <span class="n">pwr</span> <span class="o">*</span> <span class="n">model_pwr</span> <span class="o">/</span> <span class="n">aliased_pwr</span>

        <span class="k">return</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">filtered_pwr</span><span class="p">,</span> <span class="n">model_pwr</span><span class="p">,</span> <span class="n">aliased_pwr</span>

    <span class="k">def</span> <span class="nf">misfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">log_pwr</span><span class="p">,</span> <span class="n">freq_mask</span><span class="p">,</span> <span class="n">avgs</span><span class="p">):</span>
        <span class="n">model</span><span class="p">,</span> <span class="n">aliased_pwr</span><span class="p">,</span> <span class="n">RMSE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">log_pwr</span><span class="p">,</span> <span class="n">freq_mask</span><span class="p">,</span> <span class="n">avgs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">RMSE</span>

    <span class="k">def</span> <span class="nf">alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">log_pwr</span><span class="p">,</span> <span class="n">freq_mask</span><span class="p">,</span> <span class="n">avgs</span><span class="p">):</span>
        <span class="n">model_pwr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">avgs</span><span class="p">)</span>
        <span class="n">aliased_pwr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">model_pwr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">avgs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">aliased_pwr</span> <span class="o">=</span> <span class="n">aliased_pwr</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">freq</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
            <span class="n">alias_minus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">k</span><span class="o">*</span><span class="n">fs</span><span class="o">-</span><span class="n">freq</span><span class="p">,</span> <span class="n">avgs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">avgs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">alias_minus</span> <span class="o">=</span> <span class="n">alias_minus</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">((</span><span class="n">k</span><span class="o">*</span><span class="n">fs</span><span class="o">-</span><span class="n">freq</span><span class="p">)</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="n">aliased_pwr</span> <span class="o">=</span> <span class="n">aliased_pwr</span> <span class="o">+</span> <span class="n">alias_minus</span>

            <span class="n">alias_plus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">k</span><span class="o">*</span><span class="n">fs</span><span class="o">+</span><span class="n">freq</span><span class="p">,</span> <span class="n">avgs</span><span class="p">)</span>  <span class="c1"># notice the + in (k*fs+freq)</span>
            <span class="k">if</span> <span class="n">avgs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">alias_plus</span> <span class="o">=</span> <span class="n">alias_plus</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">((</span><span class="n">k</span><span class="o">*</span><span class="n">fs</span><span class="o">+</span><span class="n">freq</span><span class="p">)</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="n">aliased_pwr</span> <span class="o">=</span> <span class="n">aliased_pwr</span> <span class="o">+</span> <span class="n">alias_plus</span>

        <span class="k">if</span> <span class="n">avgs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">+</span> <span class="mi">3</span>
            <span class="n">const</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">const</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">beta</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span>

        <span class="n">zo_minus</span> <span class="o">=</span> <span class="p">(</span><span class="mi">11</span><span class="o">*</span><span class="n">fs</span><span class="o">-</span><span class="n">freq</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span><span class="p">)</span>
        <span class="n">dz_minus</span> <span class="o">=</span> <span class="n">zo_minus</span> <span class="o">/</span> <span class="mi">20</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">):</span>
            <span class="n">aliased_pwr</span> <span class="o">=</span> <span class="n">aliased_pwr</span> <span class="o">+</span> <span class="n">const</span> <span class="o">/</span> <span class="p">((</span><span class="n">j</span><span class="o">*</span><span class="n">dz_minus</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">beta</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">fc</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">dz_minus</span>

        <span class="n">zo_plus</span> <span class="o">=</span> <span class="p">(</span><span class="mi">11</span><span class="o">*</span><span class="n">fs</span><span class="o">+</span><span class="n">freq</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span><span class="p">)</span>
        <span class="n">dz_plus</span> <span class="o">=</span> <span class="n">zo_plus</span> <span class="o">/</span> <span class="mi">20</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">):</span>
            <span class="n">aliased_pwr</span> <span class="o">=</span> <span class="n">aliased_pwr</span> <span class="o">+</span> <span class="n">const</span> <span class="o">/</span> <span class="p">((</span><span class="n">j</span><span class="o">*</span><span class="n">dz_plus</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">beta</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">fc</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">dz_plus</span>

        <span class="n">log_aliased</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">aliased_pwr</span><span class="p">)</span>

        <span class="n">prefactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">log_pwr</span> <span class="o">-</span> <span class="n">log_aliased</span><span class="p">)</span> <span class="o">*</span> <span class="n">freq_mask</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">freq_mask</span><span class="p">)</span>

        <span class="n">log_aliased</span> <span class="o">=</span> <span class="n">log_aliased</span> <span class="o">+</span> <span class="n">prefactor</span>
        <span class="n">aliased_pwr</span> <span class="o">=</span> <span class="n">aliased_pwr</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">prefactor</span><span class="p">)</span>
        <span class="n">model_pwr</span> <span class="o">=</span> <span class="n">model_pwr</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">prefactor</span><span class="p">)</span>

        <span class="n">RMSE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">log_aliased</span><span class="o">-</span><span class="n">log_pwr</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">log_aliased</span><span class="o">-</span><span class="n">log_pwr</span><span class="p">)</span><span class="o">*</span><span class="n">freq_mask</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">freq_mask</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">model_pwr</span><span class="p">,</span> <span class="n">aliased_pwr</span><span class="p">,</span> <span class="n">RMSE</span>

    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">avgs</span><span class="p">):</span>
        <span class="n">spectr</span> <span class="o">=</span> <span class="n">freq</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">freq</span><span class="o">/</span><span class="n">fc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spectr</span></div>
    
<span class="c1"># def cwt(ys,ts,scales,wavelet=&#39;morl&#39;,sampling_period=1.0,method=&#39;conv&#39;,axis=-1):</span>
<span class="c1">#     &#39;&#39;&#39;Continous wavelet transform for evenly spaced data</span>
    
<span class="c1">#     pywavelet documentation: https://pywavelets.readthedocs.io/en/latest/ref/cwt.html</span>
    
<span class="c1">#     Parameters</span>
<span class="c1">#     ----------</span>
<span class="c1">#     ys : array</span>
<span class="c1">#         signal</span>
<span class="c1">#     ts : array</span>
<span class="c1">#         time </span>
<span class="c1">#     scales : array (float)</span>
<span class="c1">#         different wavelet scales to use</span>
<span class="c1">#     wavelet : str</span>
<span class="c1">#         types of wavelet options in function documentation link. The default is &#39;morl&#39; for a morlet wavelet.</span>
<span class="c1">#     sampling_period : float, optional</span>
<span class="c1">#         sampling period for frequencies output. The default is 1.0.</span>
<span class="c1">#     method : str, optional</span>
<span class="c1">#         cwt computation  method. &#39;conv&#39;,&#39;fft&#39;. or &#39;auto&#39; The default is &#39;conv&#39;.</span>
<span class="c1">#     axis : int, optional</span>
<span class="c1">#         axis over which to compute cwt. The default is -1, the last axis.</span>


<span class="c1">#     Returns</span>
<span class="c1">#     -------</span>
<span class="c1">#     res : dictionary</span>
<span class="c1">#         &#39;freq&#39; - array(float) </span>
<span class="c1">#             frequencies</span>
<span class="c1">#         &#39;time&#39; - array(float)</span>
<span class="c1">#         &#39;amplitude&#39; - array(float)</span>
<span class="c1">#         &#39;coi&#39; - array(float)</span>
<span class="c1">#             cone of inference</span>

<span class="c1">#     &#39;&#39;&#39;    </span>
<span class="c1">#     coeff,freq=pywt.cwt(data=ys,scales=scales,wavelet=wavelet,sampling_period=sampling_period,method=method,axis=axis)</span>
<span class="c1">#     amplitude=abs(coeff).T</span>
<span class="c1">#     if wavelet==&#39;morl&#39; or wavelet[:4]==&#39;cmor&#39;:</span>
<span class="c1">#         coi=make_coi(tau=ts,Neff=6)</span>
<span class="c1">#     else:</span>
<span class="c1">#         coi=make_coi(tau=ts)</span>
<span class="c1">#     Results = collections.namedtuple(&#39;Results&#39;, [&#39;amplitude&#39;,&#39;coi&#39;, &#39;freq&#39;, &#39;time&#39;, &#39;coeff&#39;])</span>
<span class="c1">#     res = Results(amplitude=amplitude, coi=coi, freq=freq, time=ts, coeff=coeff)</span>
<span class="c1">#     return res</span>

<div class="viewcode-block" id="assertPositiveInt"><a class="viewcode-back" href="../../../utils/wavelet/assertPositiveInt.html#pyleoclim.utils.wavelet.assertPositiveInt">[docs]</a><span class="k">def</span> <span class="nf">assertPositiveInt</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Assert that the arguments are all positive integers.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    args</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span> <span class="o">&gt;=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="wwz_basic"><a class="viewcode-back" href="../../../utils/wavelet/wwz_basic.html#pyleoclim.utils.wavelet.wwz_basic">[docs]</a><span class="k">def</span> <span class="nf">wwz_basic</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the weighted wavelet amplitude (WWA).</span>

<span class="sd">    Original method from Foster. Not multiprocessing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series</span>
<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>
<span class="sd">    c : float</span>
<span class="sd">        the decay constant that determines the analytical resolution of frequency for analysis, the smaller the higher resolution;</span>
<span class="sd">        the default value 1/(8*np.pi**2) is good for most of the wavelet analysis cases</span>
<span class="sd">    Neff : int</span>
<span class="sd">        the threshold of the number of effective degree of freedom</span>
<span class="sd">    nproc :int</span>
<span class="sd">        fake argument, just for convenience</span>
<span class="sd">    detrend : string</span>
<span class="sd">        None - the original time series is assumed to have no trend;</span>
<span class="sd">        &#39;linear&#39; - a linear least-squares fit to `ys` is subtracted;</span>
<span class="sd">        &#39;constant&#39; - the mean of `ys` is subtracted</span>
<span class="sd">        &#39;savitzy-golay&#39; - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">        Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series</span>
<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.</span>
<span class="sd">    gaussianize : bool</span>
<span class="sd">        If True, gaussianizes the timeseries</span>
<span class="sd">    standardize : bool</span>
<span class="sd">        If True, standardizes the timeseries</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    wwa : array</span>
<span class="sd">        the weighted wavelet amplitude</span>
<span class="sd">    phase : array</span>
<span class="sd">        the weighted wavelet phase</span>
<span class="sd">    Neffs : array</span>
<span class="sd">        the matrix of effective number of points in the time-scale coordinates</span>
<span class="sd">    coeff : array</span>
<span class="sd">        the wavelet transform coefficients (a0, a1, a2)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    Foster, G. Wavelets for period analysis of unevenly sampled time series. The Astronomical Journal 112, 1709 (1996).</span>
<span class="sd">    Witt, A. &amp; Schumann, A. Y. Holocene climate variability on millennial scales recorded in Greenland ice cores.</span>
<span class="sd">    Nonlinear Processes in Geophysics 12, 345â€“352 (2005).</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.wwz_nproc : Returns the weighted wavelet amplitude using the original method from Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_basic : Return the weighted wavelet amplitude (WWA) modified by Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_nproc : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_numba : Return the weighted wavelet amplitude (WWA) modified by Kirchner using Numba package.</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_f2py : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Uses Fortran. Fastest method but requires a compiler. </span>

<span class="sd">    pyleoclim.utils.filter.savitzky_golay : Smooth (and optionally differentiate) data with a Savitzky-Golay filter.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="n">nproc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;wwz_basic() only supports nproc=1&quot;</span>
    <span class="n">assertPositiveInt</span><span class="p">(</span><span class="n">Neff</span><span class="p">)</span>

    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="n">pd_ys</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span> <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">)</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="n">make_omega</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

    <span class="n">Neffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">ywave_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">ywave_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">ywave_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nf</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">dz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">sum_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">Neffs</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_w</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># local number of effective dof</span>

            <span class="k">if</span> <span class="n">Neffs</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Neff</span><span class="p">:</span>
                <span class="n">ywave_1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># the coefficients cannot be estimated reliably when Neff_loc &lt;= Neff</span>
                <span class="n">ywave_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">ywave_3</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">phi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>
                <span class="n">phi3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>

                <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi2</span><span class="o">*</span><span class="n">phi2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
                <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi3</span><span class="o">*</span><span class="n">phi3</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
                <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
                <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi3</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
                <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi2</span><span class="o">*</span><span class="n">phi3</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>

                <span class="n">S_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

                <span class="n">weighted_phi1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">pd_ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
                <span class="n">weighted_phi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi2</span><span class="o">*</span><span class="n">pd_ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
                <span class="n">weighted_phi3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi3</span><span class="o">*</span><span class="n">pd_ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>

                <span class="n">ywave_1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi1</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi2</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi3</span>
                <span class="n">ywave_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi1</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi2</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi3</span>
                <span class="n">ywave_3</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi1</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi2</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi3</span>

    <span class="n">wwa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ywave_2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">ywave_3</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">ywave_3</span><span class="p">,</span> <span class="n">ywave_2</span><span class="p">)</span>
    <span class="c1">#  coeff = ywave_2 + ywave_3*1j</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">ywave_1</span><span class="p">,</span> <span class="n">ywave_2</span><span class="p">,</span> <span class="n">ywave_3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wwa</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">coeff</span></div>

<div class="viewcode-block" id="wwz_nproc"><a class="viewcode-back" href="../../../utils/wavelet/wwz_nproc.html#pyleoclim.utils.wavelet.wwz_nproc">[docs]</a><span class="k">def</span> <span class="nf">wwz_nproc</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>  <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the weighted wavelet amplitude (WWA).</span>

<span class="sd">    Original method from Foster. Supports multiprocessing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series</span>
<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>
<span class="sd">    c : float</span>
<span class="sd">        the decay constant that determines the analytical resolution of frequency for analysis, the smaller the higher resolution;</span>
<span class="sd">        the default value 1/(8*np.pi**2) is good for most of the wavelet analysis cases</span>
<span class="sd">    Neff : int</span>
<span class="sd">        the threshold of the number of effective degree of freedom</span>
<span class="sd">    nproc : int</span>
<span class="sd">        the number of processes for multiprocessing</span>
<span class="sd">    detrend : string</span>
<span class="sd">        None - the original time series is assumed to have no trend;</span>
<span class="sd">        &#39;linear&#39; - a linear least-squares fit to `ys` is subtracted;</span>
<span class="sd">        &#39;constant&#39; - the mean of `ys` is subtracted</span>
<span class="sd">        &#39;savitzy-golay&#39; - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">        Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series</span>
<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.</span>
<span class="sd">    gaussianize : bool</span>
<span class="sd">        If True, gaussianizes the timeseries</span>
<span class="sd">    standardize : bool</span>
<span class="sd">        If True, standardizes the timeseries</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    wwa : array</span>
<span class="sd">        the weighted wavelet amplitude</span>
<span class="sd">    phase : array</span>
<span class="sd">        the weighted wavelet phase</span>
<span class="sd">    Neffs : array</span>
<span class="sd">        the matrix of effective number of points in the time-scale coordinates</span>
<span class="sd">    coeff : array</span>
<span class="sd">        the wavelet transform coefficients (a0, a1, a2)</span>
<span class="sd">        </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.wwz_basic : Returns the weighted wavelet amplitude using the original method from Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_basic : Return the weighted wavelet amplitude (WWA) modified by Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_nproc : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_numba : Return the weighted wavelet amplitude (WWA) modified by Kirchner using Numba package.</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_f2py : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Uses Fortran. Fastest method but requires a compiler. </span>

<span class="sd">    pyleoclim.utils.filter.savitzky_golay : Smooth (and optionally differentiate) data with a Savitzky-Golay filter.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="n">nproc</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;wwz_nproc() should use nproc &gt;= 2, if want serial run, please use wwz_basic()&quot;</span>
    <span class="n">assertPositiveInt</span><span class="p">(</span><span class="n">Neff</span><span class="p">)</span>

    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="n">pd_ys</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span> <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">)</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="n">make_omega</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

    <span class="n">Neffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">ywave_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">ywave_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">ywave_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">wwa_1g</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">omega</span><span class="p">):</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">omega</span> <span class="o">*</span> <span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">dz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">sum_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">Neff_loc</span> <span class="o">=</span> <span class="n">sum_w</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">Neff_loc</span> <span class="o">&lt;=</span> <span class="n">Neff</span><span class="p">:</span>
            <span class="n">ywave_2_1g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">ywave_3_1g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">phi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>
            <span class="n">phi3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>

            <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi2</span><span class="o">*</span><span class="n">phi2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
            <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi3</span><span class="o">*</span><span class="n">phi3</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
            <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
            <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi3</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
            <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi2</span><span class="o">*</span><span class="n">phi3</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>

            <span class="n">S_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

            <span class="n">weighted_phi1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">pd_ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
            <span class="n">weighted_phi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi2</span><span class="o">*</span><span class="n">pd_ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>
            <span class="n">weighted_phi3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">phi3</span><span class="o">*</span><span class="n">pd_ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>

            <span class="n">ywave_1_1g</span> <span class="o">=</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi1</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi2</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi3</span>
            <span class="n">ywave_2_1g</span> <span class="o">=</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi1</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi2</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi3</span>
            <span class="n">ywave_3_1g</span> <span class="o">=</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi1</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi2</span> <span class="o">+</span> <span class="n">S_inv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">weighted_phi3</span>

        <span class="k">return</span> <span class="n">Neff_loc</span><span class="p">,</span> <span class="n">ywave_1_1g</span><span class="p">,</span> <span class="n">ywave_2_1g</span><span class="p">,</span> <span class="n">ywave_3_1g</span>

    <span class="n">tf_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span>
    <span class="n">list_of_grids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">flat</span> <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">tf_mesh</span><span class="p">)))</span>
    <span class="n">tau_grids</span><span class="p">,</span> <span class="n">omega_grids</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">list_of_grids</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">nproc</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">wwa_1g</span><span class="p">,</span> <span class="n">tau_grids</span><span class="p">,</span> <span class="n">omega_grids</span><span class="p">)</span>
        <span class="n">res_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="n">Neffs</span> <span class="o">=</span> <span class="n">res_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">ywave_1</span> <span class="o">=</span> <span class="n">res_array</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">ywave_2</span> <span class="o">=</span> <span class="n">res_array</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">ywave_3</span> <span class="o">=</span> <span class="n">res_array</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>

    <span class="n">wwa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ywave_2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">ywave_3</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">ywave_3</span><span class="p">,</span> <span class="n">ywave_2</span><span class="p">)</span>
    <span class="c1">#  coeff = ywave_2 + ywave_3*1j</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">ywave_1</span><span class="p">,</span> <span class="n">ywave_2</span><span class="p">,</span> <span class="n">ywave_3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wwa</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">coeff</span></div>

<div class="viewcode-block" id="kirchner_basic"><a class="viewcode-back" href="../../../utils/wavelet/kirchner_basic.html#pyleoclim.utils.wavelet.kirchner_basic">[docs]</a><span class="k">def</span> <span class="nf">kirchner_basic</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the weighted wavelet amplitude (WWA) modified by Kirchner.</span>

<span class="sd">    Method modified by Kirchner. No multiprocessing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series</span>
<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>
<span class="sd">    c : float</span>
<span class="sd">        the decay constant that determines the analytical resolution of frequency for analysis, the smaller the higher resolution;</span>
<span class="sd">        the default value 1/(8*np.pi**2) is good for most of the wavelet analysis cases</span>
<span class="sd">    Neff : int</span>
<span class="sd">        the threshold of the number of effective degree of freedom</span>
<span class="sd">    nproc : int</span>
<span class="sd">        fake argument for convenience, for parameter consistency between functions, does not need to be specified</span>
<span class="sd">    detrend : string</span>
<span class="sd">        None - the original time series is assumed to have no trend;</span>
<span class="sd">        &#39;linear&#39; - a linear least-squares fit to `ys` is subtracted;</span>
<span class="sd">        &#39;constant&#39; - the mean of `ys` is subtracted</span>
<span class="sd">        &#39;savitzy-golay&#39; - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">        Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series</span>
<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.</span>
<span class="sd">    gaussianize : bool</span>
<span class="sd">        If True, gaussianizes the timeseries</span>
<span class="sd">    standardize : bool</span>
<span class="sd">        If True, standardizes the timeseries</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    wwa : array</span>
<span class="sd">        the weighted wavelet amplitude</span>
<span class="sd">    phase : array</span>
<span class="sd">        the weighted wavelet phase</span>
<span class="sd">    Neffs : array</span>
<span class="sd">        the matrix of effective number of points in the time-scale coordinates</span>
<span class="sd">    coeff : array</span>
<span class="sd">        the wavelet transform coefficients (a0, a1, a2)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    Foster, G. Wavelets for period analysis of unevenly sampled time series. The Astronomical Journal 112, 1709 (1996).</span>
<span class="sd">    Witt, A. &amp; Schumann, A. Y. Holocene climate variability on millennial scales recorded in Greenland ice cores.</span>
<span class="sd">    Nonlinear Processes in Geophysics 12, 345â€“352 (2005).</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.wwz_basic : Returns the weighted wavelet amplitude using the original method from Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.wwz_nproc : Returns the weighted wavelet amplitude using the original method from Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_nproc : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_numba : Return the weighted wavelet amplitude (WWA) modified by Kirchner using Numba package.</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_f2py : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Uses Fortran. Fastest method but requires a compiler. </span>

<span class="sd">    pyleoclim.utils.filter.savitzky_golay : Smooth (and optionally differentiate) data with a Savitzky-Golay filter.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="n">nproc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;wwz_basic() only supports nproc=1&quot;</span>
    <span class="n">assertPositiveInt</span><span class="p">(</span><span class="n">Neff</span><span class="p">)</span>

    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">nts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="n">pd_ys</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span> <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">)</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="n">make_omega</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

    <span class="n">Neffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nf</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">dz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">sum_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">Neffs</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_w</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># local number of effective dof</span>

            <span class="k">if</span> <span class="n">Neffs</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Neff</span><span class="p">:</span>
                <span class="n">a0</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># the coefficients cannot be estimated reliably when Neff_loc &lt;= Neff</span>
                <span class="n">a1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">a2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">w_prod</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">xs</span><span class="o">*</span><span class="n">ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>

                <span class="n">sin_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">ts</span><span class="p">)</span>
                <span class="n">cos_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">ts</span><span class="p">)</span>
                <span class="n">one_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nts</span><span class="p">)</span>

                <span class="n">sin_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
                <span class="n">cos_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_basis</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
                <span class="n">sin_cos</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">cos_basis</span><span class="p">)</span>
                <span class="n">sin_sin</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">sin_basis</span><span class="p">)</span>
                <span class="n">cos_cos</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_basis</span><span class="p">,</span> <span class="n">cos_basis</span><span class="p">)</span>

                <span class="n">numerator</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">sin_cos</span> <span class="o">-</span> <span class="n">sin_one</span> <span class="o">*</span> <span class="n">cos_one</span><span class="p">)</span>
                <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos_cos</span> <span class="o">-</span> <span class="n">cos_one</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">sin_sin</span> <span class="o">-</span> <span class="n">sin_one</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">time_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span> <span class="n">denominator</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>  <span class="c1"># Eq. (S5)</span>

                <span class="n">sin_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">time_shift</span><span class="p">))</span>
                <span class="n">cos_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">time_shift</span><span class="p">))</span>
                <span class="n">sin_tau_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">time_shift</span> <span class="o">-</span> <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="n">cos_tau_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">time_shift</span> <span class="o">-</span> <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

                <span class="n">ys_cos_shift</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">cos_shift</span><span class="p">)</span>
                <span class="n">ys_sin_shift</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">sin_shift</span><span class="p">)</span>
                <span class="n">ys_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
                <span class="n">cos_shift_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_shift</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
                <span class="n">sin_shift_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_shift</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>

                <span class="n">A</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">ys_cos_shift</span><span class="o">-</span><span class="n">ys_one</span><span class="o">*</span><span class="n">cos_shift_one</span><span class="p">)</span>
                <span class="n">B</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">ys_sin_shift</span><span class="o">-</span><span class="n">ys_one</span><span class="o">*</span><span class="n">sin_shift_one</span><span class="p">)</span>

                <span class="n">a0</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ys_one</span>
                <span class="n">a1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_tau_center</span><span class="o">*</span><span class="n">A</span> <span class="o">-</span> <span class="n">sin_tau_center</span><span class="o">*</span><span class="n">B</span>  <span class="c1"># Eq. (S6)</span>
                <span class="n">a2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_tau_center</span><span class="o">*</span><span class="n">A</span> <span class="o">+</span> <span class="n">cos_tau_center</span><span class="o">*</span><span class="n">B</span>  <span class="c1"># Eq. (S7)</span>

    <span class="n">wwa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
    <span class="c1">#  coeff = a1 + a2*1j</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wwa</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">coeff</span></div>

<div class="viewcode-block" id="kirchner_nproc"><a class="viewcode-back" href="../../../utils/wavelet/kirchner_nproc.html#pyleoclim.utils.wavelet.kirchner_nproc">[docs]</a><span class="k">def</span> <span class="nf">kirchner_nproc</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the weighted wavelet amplitude (WWA) modified by Kirchner.</span>

<span class="sd">    Method modified by kirchner. Supports multiprocessing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series</span>
<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>
<span class="sd">    c : float</span>
<span class="sd">        the decay constant that determines the analytical resolution of frequency for analysis, the smaller the higher resolution;</span>
<span class="sd">        the default value 1/(8*np.pi**2) is good for most of the wavelet analysis cases</span>
<span class="sd">    Neff : int</span>
<span class="sd">        the threshold of the number of effective degree of freedom</span>
<span class="sd">    nproc : int</span>
<span class="sd">        the number of processes for multiprocessing</span>
<span class="sd">    detrend : string</span>
<span class="sd">        None - the original time series is assumed to have no trend;</span>
<span class="sd">        &#39;linear&#39; - a linear least-squares fit to `ys` is subtracted;</span>
<span class="sd">        &#39;constant&#39; - the mean of `ys` is subtracted</span>
<span class="sd">        &#39;savitzy-golay&#39; - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">        Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series</span>
<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.</span>
<span class="sd">    gaussianize : bool</span>
<span class="sd">        If True, gaussianizes the timeseries</span>
<span class="sd">    standardize : bool</span>
<span class="sd">        If True, standardizes the timeseries</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    wwa (array): the weighted wavelet amplitude</span>
<span class="sd">    phase (array): the weighted wavelet phase</span>
<span class="sd">    Neffs (array): the matrix of effective number of points in the time-scale coordinates</span>
<span class="sd">    coeff (array): the wavelet transform coefficients (a0, a1, a2)</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.wwz_basic : Returns the weighted wavelet amplitude using the original method from Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.wwz_nproc : Returns the weighted wavelet amplitude using the original method from Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_basic : Return the weighted wavelet amplitude (WWA) modified by Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_numba : Return the weighted wavelet amplitude (WWA) modified by Kirchner using Numba package.</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_f2py : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Uses Fortran. Fastest method but requires a compiler. </span>

<span class="sd">    pyleoclim.utils.filter.savitzky_golay : Smooth (and optionally differentiate) data with a Savitzky-Golay filter.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="n">nproc</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;wwz_nproc() should use nproc &gt;= 2, if want serial run, please use wwz_basic()&quot;</span>
    <span class="n">assertPositiveInt</span><span class="p">(</span><span class="n">Neff</span><span class="p">)</span>

    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">nts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="n">pd_ys</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span> <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">)</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="n">make_omega</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

    <span class="n">Neffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">wwa_1g</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">omega</span><span class="p">):</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">omega</span> <span class="o">*</span> <span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">dz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">sum_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">Neff_loc</span> <span class="o">=</span> <span class="n">sum_w</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">Neff_loc</span> <span class="o">&lt;=</span> <span class="n">Neff</span><span class="p">:</span>
            <span class="n">a0_1g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># the coefficients cannot be estimated reliably when Neff_loc &lt;= Neff</span>
            <span class="n">a1_1g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># the coefficients cannot be estimated reliably when Neff_loc &lt;= Neff</span>
            <span class="n">a2_1g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">w_prod</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">xs</span><span class="o">*</span><span class="n">ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>

            <span class="n">sin_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">ts</span><span class="p">)</span>
            <span class="n">cos_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">ts</span><span class="p">)</span>
            <span class="n">one_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nts</span><span class="p">)</span>

            <span class="n">sin_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
            <span class="n">cos_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_basis</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
            <span class="n">sin_cos</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">cos_basis</span><span class="p">)</span>
            <span class="n">sin_sin</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">sin_basis</span><span class="p">)</span>
            <span class="n">cos_cos</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_basis</span><span class="p">,</span> <span class="n">cos_basis</span><span class="p">)</span>

            <span class="n">numerator</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">sin_cos</span> <span class="o">-</span> <span class="n">sin_one</span><span class="o">*</span><span class="n">cos_one</span><span class="p">)</span>
            <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos_cos</span> <span class="o">-</span> <span class="n">cos_one</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">sin_sin</span> <span class="o">-</span> <span class="n">sin_one</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">time_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span> <span class="n">denominator</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="p">)</span>  <span class="c1"># Eq. (S5)</span>

            <span class="n">sin_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">time_shift</span><span class="p">))</span>
            <span class="n">cos_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">time_shift</span><span class="p">))</span>
            <span class="n">sin_tau_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="n">time_shift</span> <span class="o">-</span> <span class="n">tau</span><span class="p">))</span>
            <span class="n">cos_tau_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="n">time_shift</span> <span class="o">-</span> <span class="n">tau</span><span class="p">))</span>

            <span class="n">ys_cos_shift</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">cos_shift</span><span class="p">)</span>
            <span class="n">ys_sin_shift</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">sin_shift</span><span class="p">)</span>
            <span class="n">ys_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
            <span class="n">cos_shift_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_shift</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
            <span class="n">sin_shift_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_shift</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>

            <span class="n">A</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">ys_cos_shift</span> <span class="o">-</span> <span class="n">ys_one</span><span class="o">*</span><span class="n">cos_shift_one</span><span class="p">)</span>
            <span class="n">B</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">ys_sin_shift</span> <span class="o">-</span> <span class="n">ys_one</span><span class="o">*</span><span class="n">sin_shift_one</span><span class="p">)</span>

            <span class="n">a0_1g</span> <span class="o">=</span> <span class="n">ys_one</span>
            <span class="n">a1_1g</span> <span class="o">=</span> <span class="n">cos_tau_center</span><span class="o">*</span><span class="n">A</span> <span class="o">-</span> <span class="n">sin_tau_center</span><span class="o">*</span><span class="n">B</span>  <span class="c1"># Eq. (S6)</span>
            <span class="n">a2_1g</span> <span class="o">=</span> <span class="n">sin_tau_center</span><span class="o">*</span><span class="n">A</span> <span class="o">+</span> <span class="n">cos_tau_center</span><span class="o">*</span><span class="n">B</span>  <span class="c1"># Eq. (S7)</span>

        <span class="k">return</span> <span class="n">Neff_loc</span><span class="p">,</span> <span class="n">a0_1g</span><span class="p">,</span> <span class="n">a1_1g</span><span class="p">,</span> <span class="n">a2_1g</span>

    <span class="n">tf_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span>
    <span class="n">list_of_grids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">flat</span> <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">tf_mesh</span><span class="p">)))</span>
    <span class="n">tau_grids</span><span class="p">,</span> <span class="n">omega_grids</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">list_of_grids</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">nproc</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">wwa_1g</span><span class="p">,</span> <span class="n">tau_grids</span><span class="p">,</span> <span class="n">omega_grids</span><span class="p">)</span>
        <span class="n">res_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="n">Neffs</span> <span class="o">=</span> <span class="n">res_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">a0</span> <span class="o">=</span> <span class="n">res_array</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">res_array</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">res_array</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>

    <span class="n">wwa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
    <span class="c1">#  coeff = a1 + a2*1j</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wwa</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">coeff</span></div>

<div class="viewcode-block" id="kirchner_numba"><a class="viewcode-back" href="../../../utils/wavelet/kirchner_numba.html#pyleoclim.utils.wavelet.kirchner_numba">[docs]</a><span class="k">def</span> <span class="nf">kirchner_numba</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the weighted wavelet amplitude (WWA) modified by Kirchner.</span>

<span class="sd">    Using numba.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series</span>
<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>
<span class="sd">    c : float</span>
<span class="sd">        the decay constant that determines the analytical resolution of frequency for analysis, the smaller the higher resolution;</span>
<span class="sd">        the default value 1/(8*np.pi**2) is good for most of the wavelet analysis cases</span>
<span class="sd">    Neff : int</span>
<span class="sd">        the threshold of the number of effective degree of freedom</span>
<span class="sd">    nproc : int</span>
<span class="sd">        fake argument, just for convenience</span>
<span class="sd">    detrend : string</span>
<span class="sd">        None - the original time series is assumed to have no trend;</span>
<span class="sd">        &#39;linear&#39; - a linear least-squares fit to `ys` is subtracted;</span>
<span class="sd">        &#39;constant&#39; - the mean of `ys` is subtracted</span>
<span class="sd">        &#39;savitzy-golay&#39; - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">        Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series</span>
<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.</span>
<span class="sd">    gaussianize : bool</span>
<span class="sd">        If True, gaussianizes the timeseries</span>
<span class="sd">    standardize : bool</span>
<span class="sd">        If True, standardizes the timeseries</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    wwa : array</span>
<span class="sd">        the weighted wavelet amplitude</span>
<span class="sd">    phase : array</span>
<span class="sd">        the weighted wavelet phase</span>
<span class="sd">    Neffs : array</span>
<span class="sd">        the matrix of effective number of points in the time-scale coordinates</span>
<span class="sd">    coeff : array</span>
<span class="sd">        the wavelet transform coefficients (a0, a1, a2)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    Foster, G. Wavelets for period analysis of unevenly sampled time series. The Astronomical Journal 112, 1709 (1996).</span>
<span class="sd">    Witt, A. &amp; Schumann, A. Y. Holocene climate variability on millennial scales recorded in Greenland ice cores.</span>
<span class="sd">    Nonlinear Processes in Geophysics 12, 345â€“352 (2005).</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.wwz_basic : Returns the weighted wavelet amplitude using the original method from Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.wwz_nproc : Returns the weighted wavelet amplitude using the original method from Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_basic : Return the weighted wavelet amplitude (WWA) modified by Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_nproc : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_f2py : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Uses Fortran. Fastest method but requires a compiler. </span>

<span class="sd">    pyleoclim.utils.filter.savitzky_golay : Smooth (and optionally differentiate) data with a Savitzky-Golay filter.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">assertPositiveInt</span><span class="p">(</span><span class="n">Neff</span><span class="p">)</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">nts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="n">pd_ys</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span> <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">)</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="n">make_omega</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

    <span class="n">Neffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">))</span>

    <span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">loop_over</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span> <span class="n">nt</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">wwa_1g</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">omega</span><span class="p">):</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">omega</span> <span class="o">*</span> <span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">dz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">sum_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">Neff_loc</span> <span class="o">=</span> <span class="n">sum_w</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">Neff_loc</span> <span class="o">&lt;=</span> <span class="n">Neff</span><span class="p">:</span>
                <span class="n">a0_1g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># the coefficients cannot be estimated reliably when Neff_loc &lt;= Neff</span>
                <span class="n">a1_1g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># the coefficients cannot be estimated reliably when Neff_loc &lt;= Neff</span>
                <span class="n">a2_1g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">w_prod</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">*</span><span class="n">xs</span><span class="o">*</span><span class="n">ys</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_w</span>

                <span class="n">sin_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">ts</span><span class="p">)</span>
                <span class="n">cos_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">ts</span><span class="p">)</span>
                <span class="n">one_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nts</span><span class="p">)</span>

                <span class="n">sin_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
                <span class="n">cos_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_basis</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
                <span class="n">sin_cos</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">cos_basis</span><span class="p">)</span>
                <span class="n">sin_sin</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_basis</span><span class="p">,</span> <span class="n">sin_basis</span><span class="p">)</span>
                <span class="n">cos_cos</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_basis</span><span class="p">,</span> <span class="n">cos_basis</span><span class="p">)</span>

                <span class="n">numerator</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">sin_cos</span> <span class="o">-</span> <span class="n">sin_one</span><span class="o">*</span><span class="n">cos_one</span><span class="p">)</span>
                <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos_cos</span> <span class="o">-</span> <span class="n">cos_one</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">sin_sin</span> <span class="o">-</span> <span class="n">sin_one</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">time_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span> <span class="n">denominator</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="p">)</span>  <span class="c1"># Eq. (S5)</span>

                <span class="n">sin_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">time_shift</span><span class="p">))</span>
                <span class="n">cos_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="n">ts</span> <span class="o">-</span> <span class="n">time_shift</span><span class="p">))</span>
                <span class="n">sin_tau_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="n">time_shift</span> <span class="o">-</span> <span class="n">tau</span><span class="p">))</span>
                <span class="n">cos_tau_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="n">time_shift</span> <span class="o">-</span> <span class="n">tau</span><span class="p">))</span>

                <span class="n">ys_cos_shift</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">cos_shift</span><span class="p">)</span>
                <span class="n">ys_sin_shift</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">sin_shift</span><span class="p">)</span>
                <span class="n">ys_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">pd_ys</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
                <span class="n">cos_shift_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">cos_shift</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>
                <span class="n">sin_shift_one</span> <span class="o">=</span> <span class="n">w_prod</span><span class="p">(</span><span class="n">sin_shift</span><span class="p">,</span> <span class="n">one_v</span><span class="p">)</span>

                <span class="n">A</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">ys_cos_shift</span> <span class="o">-</span> <span class="n">ys_one</span><span class="o">*</span><span class="n">cos_shift_one</span><span class="p">)</span>
                <span class="n">B</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">ys_sin_shift</span> <span class="o">-</span> <span class="n">ys_one</span><span class="o">*</span><span class="n">sin_shift_one</span><span class="p">)</span>

                <span class="n">a0_1g</span> <span class="o">=</span> <span class="n">ys_one</span>
                <span class="n">a1_1g</span> <span class="o">=</span> <span class="n">cos_tau_center</span><span class="o">*</span><span class="n">A</span> <span class="o">-</span> <span class="n">sin_tau_center</span><span class="o">*</span><span class="n">B</span>  <span class="c1"># Eq. (S6)</span>
                <span class="n">a2_1g</span> <span class="o">=</span> <span class="n">sin_tau_center</span><span class="o">*</span><span class="n">A</span> <span class="o">+</span> <span class="n">cos_tau_center</span><span class="o">*</span><span class="n">B</span>  <span class="c1"># Eq. (S7)</span>

            <span class="k">return</span> <span class="n">Neff_loc</span><span class="p">,</span> <span class="n">a0_1g</span><span class="p">,</span> <span class="n">a1_1g</span><span class="p">,</span> <span class="n">a2_1g</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nb</span><span class="o">.</span><span class="n">prange</span><span class="p">(</span><span class="n">nf</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">nb</span><span class="o">.</span><span class="n">prange</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
                <span class="n">Neffs</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">a0</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">a1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">a2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">wwa_1g</span><span class="p">(</span><span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span>

    <span class="n">Neffs</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">loop_over</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span> <span class="n">nt</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>

    <span class="n">wwa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
    <span class="c1">#  coeff = a1 + a2*1j</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wwa</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">coeff</span></div>

<div class="viewcode-block" id="kirchner_f2py"><a class="viewcode-back" href="../../../utils/wavelet/kirchner_f2py.html#pyleoclim.utils.wavelet.kirchner_f2py">[docs]</a><span class="k">def</span> <span class="nf">kirchner_f2py</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Returns the weighted wavelet amplitude (WWA) modified by Kirchner.</span>

<span class="sd">    Fastest method. Calls Fortran libraries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series</span>
<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>
<span class="sd">    c : float</span>
<span class="sd">        the decay constant that determines the analytical resolution of frequency for analysis, the smaller the higher resolution;</span>
<span class="sd">        the default value 1/(8*np.pi**2) is good for most of the wavelet analysis cases</span>
<span class="sd">    Neff : int</span>
<span class="sd">        the threshold of the number of effective degree of freedom</span>
<span class="sd">    nproc : int</span>
<span class="sd">        fake argument, just for convenience</span>
<span class="sd">    detrend : string</span>
<span class="sd">        None - the original time series is assumed to have no trend;</span>
<span class="sd">        &#39;linear&#39; - a linear least-squares fit to `ys` is subtracted;</span>
<span class="sd">        &#39;constant&#39; - the mean of `ys` is subtracted</span>
<span class="sd">        &#39;savitzy-golay&#39; - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">        Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series</span>
<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.</span>
<span class="sd">    gaussianize : bool</span>
<span class="sd">        If True, gaussianizes the timeseries</span>
<span class="sd">    standardize : bool</span>
<span class="sd">        If True, standardizes the timeseries</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    wwa : array</span>
<span class="sd">        the weighted wavelet amplitude</span>
<span class="sd">    phase : array</span>
<span class="sd">        the weighted wavelet phase</span>
<span class="sd">    Neffs : array</span>
<span class="sd">        the matrix of effective number of points in the time-scale coordinates</span>
<span class="sd">    coeff : array</span>
<span class="sd">        the wavelet transform coefficients (a0, a1, a2)</span>
<span class="sd">        </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.wwz_basic : Returns the weighted wavelet amplitude using the original method from Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.wwz_nproc : Returns the weighted wavelet amplitude using the original method from Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_basic : Return the weighted wavelet amplitude (WWA) modified by Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_nproc : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_numba : Return the weighted wavelet amplitude (WWA) modified by Kirchner using Numba package.</span>

<span class="sd">    pyleoclim.utils.filter.savitzky_golay : Smooth (and optionally differentiate) data with a Savitzky-Golay filter.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">f2py_wwz</span> <span class="k">as</span> <span class="n">f2py</span>
    <span class="n">assertPositiveInt</span><span class="p">(</span><span class="n">Neff</span><span class="p">,</span> <span class="n">nproc</span><span class="p">)</span>

    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">nts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="n">pd_ys</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span> <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">)</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="n">make_omega</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

    <span class="n">Neffs</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">f2py</span><span class="o">.</span><span class="n">f2py_wwz</span><span class="o">.</span><span class="n">wwa</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Neff</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">pd_ys</span><span class="p">,</span> <span class="n">nproc</span><span class="p">,</span> <span class="n">nts</span><span class="p">,</span> <span class="n">nt</span><span class="p">,</span> <span class="n">nf</span><span class="p">)</span>

    <span class="n">undef</span> <span class="o">=</span> <span class="o">-</span><span class="mf">99999.</span>
    <span class="n">a0</span><span class="p">[</span><span class="n">a0</span> <span class="o">==</span> <span class="n">undef</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">a1</span><span class="p">[</span><span class="n">a1</span> <span class="o">==</span> <span class="n">undef</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">a2</span><span class="p">[</span><span class="n">a2</span> <span class="o">==</span> <span class="n">undef</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">wwa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>

    <span class="c1">#  coeff = a1 + a2*1j</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wwa</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">coeff</span></div>

<div class="viewcode-block" id="make_coi"><a class="viewcode-back" href="../../../utils/wavelet/make_coi.html#pyleoclim.utils.wavelet.make_coi">[docs]</a><span class="k">def</span> <span class="nf">make_coi</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the cone of influence.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>
<span class="sd">    Neff : int</span>
<span class="sd">        the threshold of the number of effective samples</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">        coi : array</span>
<span class="sd">            cone of influence</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    wave_signif() in http://paos.colorado.edu/research/wavelets/wave_python/waveletFunctions.py</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Neff</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Neff</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>

    <span class="n">fourier_factor</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="n">Neff</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">Neff</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">coi_const</span> <span class="o">=</span> <span class="n">fourier_factor</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>
    <span class="n">nt_half</span> <span class="o">=</span> <span class="p">(</span><span class="n">nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.00001</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nt_half</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">nt</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="n">coi</span> <span class="o">=</span> <span class="n">coi_const</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">C</span>

    <span class="k">return</span> <span class="n">coi</span></div>

<div class="viewcode-block" id="make_omega"><a class="viewcode-back" href="../../../utils/wavelet/make_omega.html#pyleoclim.utils.wavelet.make_omega">[docs]</a><span class="k">def</span> <span class="nf">make_omega</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the angular frequency based on the time axis and given frequency vector</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series</span>
<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>


<span class="sd">    omega : array</span>
<span class="sd">        the angular frequency vector</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># for the frequency band larger than f_Nyquist, the wwa will be marked as NaNs</span>
    <span class="n">f_Nyquist</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
    <span class="n">freq_with_nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
    <span class="n">freq_with_nan</span><span class="p">[</span><span class="n">freq</span> <span class="o">&gt;</span> <span class="n">f_Nyquist</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">freq_with_nan</span>

    <span class="k">return</span> <span class="n">omega</span></div>

<div class="viewcode-block" id="wwa2psd"><a class="viewcode-back" href="../../../utils/wavelet/wwa2psd.html#pyleoclim.utils.wavelet.wwa2psd">[docs]</a><span class="k">def</span> <span class="nf">wwa2psd</span><span class="p">(</span><span class="n">wwa</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">anti_alias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">avgs</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return the power spectral density (PSD) using the weighted wavelet amplitude (WWA).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    wwa : array</span>
<span class="sd">        the weighted wavelet amplitude.</span>
<span class="sd">    ts : array</span>
<span class="sd">        the time points, should be pre-truncated so that the span is exactly what is used for wwz</span>
<span class="sd">    Neffs : array</span>
<span class="sd">        the matrix of effective number of points in the time-scale coordinates obtained from wwz from wwz</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency from wwz</span>
<span class="sd">    Neff : int</span>
<span class="sd">        the threshold of the number of effective samples</span>
<span class="sd">    anti_alias : bool</span>
<span class="sd">        whether to apply anti-alias filter</span>
<span class="sd">    avgs : int</span>
<span class="sd">        flag for whether spectrum is derived from instantaneous point measurements (avgs&lt;&gt;1) OR from measurements averaged over each sampling interval (avgs==1)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    psd : array</span>
<span class="sd">        power spectral density</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    Kirchner&#39;s C code for weighted psd calculation</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">af</span> <span class="o">=</span> <span class="n">AliasFilter</span><span class="p">()</span>

    <span class="c1"># weighted psd calculation start</span>
    <span class="n">power</span> <span class="o">=</span> <span class="n">wwa</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">*</span> <span class="n">Neffs</span>

    <span class="n">Neff_diff</span> <span class="o">=</span> <span class="n">Neffs</span> <span class="o">-</span> <span class="n">Neff</span>
    <span class="n">Neff_diff</span><span class="p">[</span><span class="n">Neff_diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">sum_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">power</span> <span class="o">*</span> <span class="n">Neff_diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">sum_eff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">Neff_diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">psd</span> <span class="o">=</span> <span class="n">sum_power</span> <span class="o">/</span> <span class="n">sum_eff</span>
    <span class="c1"># weighted psd calculation end</span>

    <span class="k">if</span> <span class="n">anti_alias</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;freq is required for alias filter!&quot;</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
        <span class="n">f_sampling</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">dt</span>
        <span class="n">psd_copy</span> <span class="o">=</span> <span class="n">psd</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">freq_copy</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">filtered_pwr</span><span class="p">,</span> <span class="n">model_pwer</span><span class="p">,</span> <span class="n">aliased_pwr</span> <span class="o">=</span> <span class="n">af</span><span class="o">.</span><span class="n">alias_filter</span><span class="p">(</span>
            <span class="n">freq_copy</span><span class="p">,</span> <span class="n">psd_copy</span><span class="p">,</span> <span class="n">f_sampling</span><span class="p">,</span> <span class="n">f_sampling</span><span class="o">*</span><span class="mf">1e3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">avgs</span><span class="p">)</span>

        <span class="n">psd</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">filtered_pwr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">psd</span></div>

<div class="viewcode-block" id="wwz"><a class="viewcode-back" href="../../../utils/wavelet/wwz.html#pyleoclim.utils.wavelet.wwz">[docs]</a><span class="k">def</span> <span class="nf">wwz</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ntau</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq_method</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">freq_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">Neff_coi</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">nMC</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Kirchner_numba&#39;</span><span class="p">,</span> <span class="n">len_bd</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">bc_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Weighted wavelet amplitude (WWA) for unevenly-spaced data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series, NaNs will be deleted automatically</span>
<span class="sd">    ts : array</span>
<span class="sd">        the time points, if `ys` contains any NaNs, some of the time points will be deleted accordingly</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time vector for the analysis, namely the time shift for wavelet analysis</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    freq_method : str</span>
<span class="sd">        Method to generate the frequency vector if not set directly. The following options are avialable:</span>

<span class="sd">        - &#39;log&#39; (default)</span>
<span class="sd">        - &#39;lomb_scargle&#39;</span>
<span class="sd">        - &#39;welch&#39;</span>
<span class="sd">        - &#39;scale&#39;</span>
<span class="sd">        - &#39;nfft&#39;</span>
<span class="sd">        See :func:`pyleoclim.utils.wavelet.make_freq_vector()` for details</span>

<span class="sd">    freq_kwargs : str</span>
<span class="sd">        used when freq=None for certain methods</span>
<span class="sd">    c : float</span>
<span class="sd">        the decay constant that determines the analytical resolution of frequency for analysis, the smaller the higher resolution;</span>
<span class="sd">        the default value 1/(8*np.pi**2) is good for most of the wavelet analysis cases</span>
<span class="sd">    Neff : int</span>
<span class="sd">        effective number of points</span>
<span class="sd">    nMC : int</span>
<span class="sd">        the number of Monte-Carlo simulations</span>
<span class="sd">    nproc : int</span>
<span class="sd">        the number of processes for multiprocessing</span>

<span class="sd">    detrend : string, {None, &#39;linear&#39;, &#39;constant&#39;, &#39;savitzy-golay&#39;}</span>
<span class="sd">        available methods for detrending, including</span>

<span class="sd">        - None: the original time series is assumed to have no trend;</span>
<span class="sd">        - &#39;linear&#39;: a linear least-squares fit to `ys` is subtracted;</span>
<span class="sd">        - &#39;constant&#39;: the mean of `ys` is subtracted</span>
<span class="sd">        - &#39;savitzy-golay&#39;: ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">        Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series</span>

<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. See :func:`pyleoclim.utils.filter.savitzky_golay()` for details.</span>

<span class="sd">    method : string, {&#39;Foster&#39;, &#39;Kirchner&#39;, &#39;Kirchner_f2py&#39;, &#39;Kirchner_numba&#39;}</span>
<span class="sd">        available specific implementation of WWZ, including</span>

<span class="sd">        - &#39;Foster&#39;: the original WWZ method;</span>
<span class="sd">        - &#39;Kirchner&#39;: the method Kirchner adapted from Foster;</span>
<span class="sd">        - &#39;Kirchner_f2py&#39;: the method Kirchner adapted from Foster, implemented with f2py for acceleration;</span>
<span class="sd">        - &#39;Kirchner_numba&#39;: the method Kirchner adapted from Foster, implemented with Numba for acceleration (default);</span>

<span class="sd">    len_bd : int</span>
<span class="sd">        the number of the ghost grids want to creat on each boundary</span>

<span class="sd">    bc_mode : string, {&#39;constant&#39;, &#39;edge&#39;, &#39;linear_ramp&#39;, &#39;maximum&#39;, &#39;mean&#39;, &#39;median&#39;, &#39;minimum&#39;, &#39;reflect&#39; , &#39;symmetric&#39;, &#39;wrap&#39;}</span>
<span class="sd">        For more details, see np.lib.pad()</span>

<span class="sd">    reflect_type : string, optional, {â€˜evenâ€™, â€˜oddâ€™}</span>
<span class="sd">         Used in â€˜reflectâ€™, and â€˜symmetricâ€™. The â€˜evenâ€™ style is the default with an unaltered reflection around the edge value.</span>
<span class="sd">         For the â€˜oddâ€™ style, the extented part of the array is created by subtracting the reflected values from two times the edge value.</span>
<span class="sd">         For more details, see np.lib.pad()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    res : namedtuple</span>
<span class="sd">        a namedtuple that includes below items</span>

<span class="sd">        wwa : array</span>
<span class="sd">            the weighted wavelet amplitude.</span>

<span class="sd">        coi : array</span>
<span class="sd">            cone of influence</span>

<span class="sd">        freq : array</span>
<span class="sd">            vector of frequency</span>

<span class="sd">        tau : array</span>
<span class="sd">            the evenly-spaced time points, namely the time shift for wavelet analysis</span>

<span class="sd">        Neffs : array</span>
<span class="sd">            the matrix of effective number of points in the time-scale coordinates</span>

<span class="sd">        coeff : array</span>
<span class="sd">            the wavelet transform coefficents</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.wwz_basic : Returns the weighted wavelet amplitude using the original method from Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.wwz_nproc : Returns the weighted wavelet amplitude using the original method from Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_basic : Return the weighted wavelet amplitude (WWA) modified by Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_nproc : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_numba : Return the weighted wavelet amplitude (WWA) modified by Kirchner using Numba package.</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_f2py : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Uses Fortran. Fastest method but requires a compiler. </span>

<span class="sd">    pyleoclim.utils.filter.savitzky_golay : Smooth (and optionally differentiate) data with a Savitzky-Golay filter.    </span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.make_freq_vector : Make frequency vector</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    We perform an ideal test below.</span>
<span class="sd">    We use a sine wave with a period of 50 yrs as the signal for test.</span>
<span class="sd">    Then performing wavelet analysis should return an energy band around period of 50 yrs in the time-period scalogram domain.</span>

<span class="sd">    .. ipython:: python</span>
<span class="sd">        :okwarning:</span>

<span class="sd">        from pyleoclim import utils</span>
<span class="sd">        import matplotlib.pyplot as plt</span>
<span class="sd">        from matplotlib.ticker import ScalarFormatter, FormatStrFormatter</span>
<span class="sd">        import numpy as np</span>

<span class="sd">        # Create a signal</span>
<span class="sd">        time = np.arange(2001)</span>
<span class="sd">        f = 1/50  # the period is then 1/f = 50</span>
<span class="sd">        signal = np.cos(2*np.pi*f*time)</span>

<span class="sd">        # Wavelet Analysis</span>
<span class="sd">        res = utils.wwz(signal, time)</span>

<span class="sd">        # Visualization</span>
<span class="sd">        fig, ax = plt.subplots()</span>
<span class="sd">        contourf_args = {&#39;cmap&#39;: &#39;magma&#39;, &#39;origin&#39;: &#39;lower&#39;, &#39;levels&#39;: 11}</span>
<span class="sd">        cbar_args = {&#39;drawedges&#39;: False, &#39;orientation&#39;: &#39;vertical&#39;, &#39;fraction&#39;: 0.15, &#39;pad&#39;: 0.05}</span>
<span class="sd">        cont = ax.contourf(res.time, 1/res.freq, res.amplitude.T, **contourf_args)</span>
<span class="sd">        ax.plot(res.time, res.coi, &#39;k--&#39;)  # plot the cone of influence</span>
<span class="sd">        ax.set_yscale(&#39;log&#39;)</span>
<span class="sd">        ax.set_yticks([2, 5, 10, 20, 50, 100, 200, 500, 1000])</span>
<span class="sd">        ax.set_ylim([2, 1000])</span>
<span class="sd">        ax.yaxis.set_major_formatter(ScalarFormatter())</span>
<span class="sd">        ax.yaxis.set_major_formatter(FormatStrFormatter(&#39;%g&#39;))</span>
<span class="sd">        ax.set_xlabel(&#39;Time (yr)&#39;)</span>
<span class="sd">        ax.set_ylabel(&#39;Period (yrs)&#39;)</span>
<span class="sd">        cb = plt.colorbar(cont, **cbar_args)</span>
<span class="sd">        @savefig wwa_wwz.png</span>
<span class="sd">        plt.show()</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nMC</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nMC</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;nMC should be larger than or equal to 0.&quot;</span>

    <span class="n">ys_cut</span><span class="p">,</span> <span class="n">ts_cut</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">prepare_wwz</span><span class="p">(</span>
        <span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">freq_method</span><span class="o">=</span><span class="n">freq_method</span><span class="p">,</span> <span class="n">freq_kwargs</span><span class="o">=</span><span class="n">freq_kwargs</span><span class="p">,</span>
        <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span> <span class="n">len_bd</span><span class="o">=</span><span class="n">len_bd</span><span class="p">,</span>
        <span class="n">bc_mode</span><span class="o">=</span><span class="n">bc_mode</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="n">reflect_type</span>
    <span class="p">)</span>

    <span class="n">wwz_func</span> <span class="o">=</span> <span class="n">get_wwz_func</span><span class="p">(</span><span class="n">nproc</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
    <span class="n">wwa</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">Neffs</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">wwz_func</span><span class="p">(</span><span class="n">ys_cut</span><span class="p">,</span> <span class="n">ts_cut</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">Neff</span><span class="o">=</span><span class="n">Neff</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="n">nproc</span><span class="p">,</span>
                                        <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span>
                                        <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">)</span>

    <span class="c1"># Monte-Carlo simulations of AR1 process</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="c1">#  wwa_red = np.ndarray(shape=(nMC, nt, nf))</span>
    <span class="c1">#  AR1_q = np.ndarray(shape=(nt, nf))</span>

    <span class="c1">#  if nMC &gt;= 1:</span>
        <span class="c1">#  for i in tqdm(range(nMC), desc=&#39;Monte-Carlo simulations&#39;):</span>
            <span class="c1">#  r = ar1_sim(ys_cut, np.size(ts_cut), 1, ts=ts_cut)</span>
            <span class="c1">#  wwa_red[i, :, :], _, _, _ = wwz_func(r, ts_cut, freq, tau, c=c, Neff=Neff, nproc=nproc,</span>
                                                 <span class="c1">#  detrend=detrend, sg_kwargs=sg_kwargs,</span>
                                                 <span class="c1">#  gaussianize=gaussianize, standardize=standardize)</span>

        <span class="c1">#  for j in range(nt):</span>
            <span class="c1">#  for k in range(nf):</span>
                <span class="c1">#  AR1_q[j, k] = mquantiles(wwa_red[:, j, k], 0.95)</span>

    <span class="c1">#  else:</span>
        <span class="c1">#  AR1_q = None</span>
    <span class="c1"># AR1_q = None</span>

    <span class="c1"># calculate the cone of influence</span>
    <span class="n">coi</span> <span class="o">=</span> <span class="n">make_coi</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">Neff</span><span class="o">=</span><span class="n">Neff_coi</span><span class="p">)</span>

    <span class="c1"># Results = collections.namedtuple(&#39;Results&#39;, [&#39;amplitude&#39;, &#39;phase&#39;, &#39;AR1_q&#39;, &#39;coi&#39;, &#39;freq&#39;, &#39;time&#39;, &#39;Neffs&#39;, &#39;coeff&#39;])</span>
    <span class="c1"># res = Results(amplitude=wwa, phase=phase, AR1_q=AR1_q, coi=coi, freq=freq, time=tau, Neffs=Neffs, coeff=coeff)</span>
    <span class="n">Results</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Results&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;amplitude&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="s1">&#39;coi&#39;</span><span class="p">,</span> <span class="s1">&#39;freq&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;Neffs&#39;</span><span class="p">,</span> <span class="s1">&#39;coeff&#39;</span><span class="p">])</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">Results</span><span class="p">(</span><span class="n">amplitude</span><span class="o">=</span><span class="n">wwa</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="n">phase</span><span class="p">,</span> <span class="n">coi</span><span class="o">=</span><span class="n">coi</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span> <span class="n">Neffs</span><span class="o">=</span><span class="n">Neffs</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="n">coeff</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="xwc"><a class="viewcode-back" href="../../../utils/wavelet/xwc.html#pyleoclim.utils.wavelet.xwc">[docs]</a><span class="k">def</span> <span class="nf">xwc</span><span class="p">(</span><span class="n">ys1</span><span class="p">,</span> <span class="n">ts1</span><span class="p">,</span> <span class="n">ys2</span><span class="p">,</span> <span class="n">ts2</span><span class="p">,</span> <span class="n">smooth_factor</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
        <span class="n">tau</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq_method</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">freq_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Neff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nMC</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
        <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Kirchner_numba&#39;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the cross-wavelet coherence of two time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys1 : array</span>
<span class="sd">        first of two time series</span>
<span class="sd">    ys2 : array</span>
<span class="sd">        second of the two time series</span>
<span class="sd">    ts1 : array</span>
<span class="sd">        time axis of first time series</span>
<span class="sd">    ts2 : array</span>
<span class="sd">        time axis of the second time series</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    c : float</span>
<span class="sd">        the decay constant that determines the analytical resolution of frequency for analysis, the smaller the higher resolution;</span>
<span class="sd">        the default value 1/(8*np.pi**2) is good for most of the wavelet analysis cases</span>
<span class="sd">    Neff : int</span>
<span class="sd">        effective number of points</span>
<span class="sd">    nproc : int</span>
<span class="sd">        the number of processes for multiprocessing</span>
<span class="sd">    nMC : int</span>
<span class="sd">        the number of Monte-Carlo simulations</span>
<span class="sd">    detrend : string</span>
<span class="sd">        - None: the original time series is assumed to have no trend;</span>
<span class="sd">        - &#39;linear&#39;: a linear least-squares fit to `ys` is subtracted;</span>
<span class="sd">        - &#39;constant&#39;: the mean of `ys` is subtracted</span>
<span class="sd">        - &#39;savitzy-golay&#39;: ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">        Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series</span>
<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.</span>
<span class="sd">    gaussianize : bool</span>
<span class="sd">        If True, gaussianizes the timeseries</span>
<span class="sd">    standardize : bool</span>
<span class="sd">        If True, standardizes the timeseries</span>
<span class="sd">    method : string</span>
<span class="sd">        - &#39;Foster&#39;: the original WWZ method;</span>
<span class="sd">        - &#39;Kirchner&#39;: the method Kirchner adapted from Foster;</span>
<span class="sd">        - &#39;Kirchner_f2py&#39;: the method Kirchner adapted from Foster with f2py</span>
<span class="sd">        - &#39;Kirchner_numba&#39;: Kirchner&#39;s algorithm with Numba support for acceleration (default)</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        If True, print warning messages</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    res : dict</span>
<span class="sd">        contains the cross wavelet coherence, cross-wavelet phase,</span>
<span class="sd">        vector of frequency, evenly-spaced time points, AR1 sims, cone of influence</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.wwz_basic : Returns the weighted wavelet amplitude using the original method from Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.wwz_nproc : Returns the weighted wavelet amplitude using the original method from Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_basic : Return the weighted wavelet amplitude (WWA) modified by Kirchner. No multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_nproc : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Supports multiprocessing</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_numba : Return the weighted wavelet amplitude (WWA) modified by Kirchner using Numba package.</span>

<span class="sd">    pyleoclim.utils.wavelet.kirchner_f2py : Returns the weighted wavelet amplitude (WWA) modified by Kirchner. Uses Fortran. Fastest method but requires a compiler. </span>

<span class="sd">    pyleoclim.utils.filter.savitzky_golay : Smooth (and optionally differentiate) data with a Savitzky-Golay filter.    </span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.make_freq_vector : Make frequency vector</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nMC</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nMC</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;nMC should be larger than or eaqual to 0.&quot;</span>

    <span class="k">if</span> <span class="n">tau</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lb1</span><span class="p">,</span> <span class="n">ub1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts1</span><span class="p">)</span>
        <span class="n">lb2</span><span class="p">,</span> <span class="n">ub2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts2</span><span class="p">)</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">lb1</span><span class="p">,</span> <span class="n">lb2</span><span class="p">])</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">ub1</span><span class="p">,</span> <span class="n">ub2</span><span class="p">])</span>

        <span class="n">inside</span> <span class="o">=</span> <span class="n">ts1</span><span class="p">[(</span><span class="n">ts1</span><span class="o">&gt;=</span><span class="n">lb</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ts1</span><span class="o">&lt;=</span><span class="n">ub</span><span class="p">)]</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">inside</span><span class="p">)</span><span class="o">//</span><span class="mi">10</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Setting tau=</span><span class="si">{</span><span class="n">tau</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="s1">...</span><span class="si">{</span><span class="n">tau</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span><span class="si">}</span><span class="s1">, ntau=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq_kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">freq_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">freq_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">make_freq_vector</span><span class="p">(</span><span class="n">ts1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">freq_method</span><span class="p">,</span> <span class="o">**</span><span class="n">freq_kwargs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Setting freq=</span><span class="si">{</span><span class="n">freq</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="s1">...</span><span class="si">{</span><span class="n">freq</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span><span class="si">}</span><span class="s1">, nfreq=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">ys1_cut</span><span class="p">,</span> <span class="n">ts1_cut</span><span class="p">,</span> <span class="n">freq1</span><span class="p">,</span> <span class="n">tau1</span> <span class="o">=</span> <span class="n">prepare_wwz</span><span class="p">(</span><span class="n">ys1</span><span class="p">,</span> <span class="n">ts1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">ys2_cut</span><span class="p">,</span> <span class="n">ts2_cut</span><span class="p">,</span> <span class="n">freq2</span><span class="p">,</span> <span class="n">tau2</span> <span class="o">=</span> <span class="n">prepare_wwz</span><span class="p">(</span><span class="n">ys2</span><span class="p">,</span> <span class="n">ts2</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tau1</span> <span class="o">!=</span> <span class="n">tau2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inconsistent `tau`, recalculating...&#39;</span><span class="p">)</span>
        <span class="n">tau_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau2</span><span class="p">)])</span>
        <span class="n">tau_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau2</span><span class="p">)])</span>
        <span class="n">ntau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau2</span><span class="p">)])</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tau_min</span><span class="p">,</span> <span class="n">tau_max</span><span class="p">,</span> <span class="n">ntau</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">tau1</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">freq1</span> <span class="o">!=</span> <span class="n">freq2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inconsistent `freq`, recalculating...&#39;</span><span class="p">)</span>
        <span class="n">freq_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">freq1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">freq2</span><span class="p">)])</span>
        <span class="n">freq_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">freq1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">freq2</span><span class="p">)])</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq2</span><span class="p">)])</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">freq_min</span><span class="p">,</span> <span class="n">freq_max</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq1</span>

    <span class="k">if</span> <span class="n">freq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># delete 0 frequency if present</span>

    <span class="n">res_wwz1</span> <span class="o">=</span> <span class="n">wwz</span><span class="p">(</span><span class="n">ys1_cut</span><span class="p">,</span> <span class="n">ts1_cut</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">Neff</span><span class="o">=</span><span class="n">Neff</span><span class="p">,</span> <span class="n">nMC</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                   <span class="n">nproc</span><span class="o">=</span><span class="n">nproc</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span>
                   <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
    <span class="n">res_wwz2</span> <span class="o">=</span> <span class="n">wwz</span><span class="p">(</span><span class="n">ys2_cut</span><span class="p">,</span> <span class="n">ts2_cut</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">Neff</span><span class="o">=</span><span class="n">Neff</span><span class="p">,</span> <span class="n">nMC</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                   <span class="n">nproc</span><span class="o">=</span><span class="n">nproc</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">,</span>
                   <span class="n">gaussianize</span><span class="o">=</span><span class="n">gaussianize</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="n">standardize</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

    <span class="n">wt_coeff1</span> <span class="o">=</span> <span class="n">res_wwz1</span><span class="o">.</span><span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">res_wwz1</span><span class="o">.</span><span class="n">coeff</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
    <span class="n">wt_coeff2</span> <span class="o">=</span> <span class="n">res_wwz2</span><span class="o">.</span><span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">res_wwz2</span><span class="o">.</span><span class="n">coeff</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>

    <span class="n">xw_coherence</span><span class="p">,</span> <span class="n">xw_phase</span> <span class="o">=</span> <span class="n">wavelet_coherence</span><span class="p">(</span><span class="n">wt_coeff1</span><span class="p">,</span> <span class="n">wt_coeff2</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">smooth_factor</span><span class="o">=</span><span class="n">smooth_factor</span><span class="p">)</span>
    <span class="n">xwt</span><span class="p">,</span> <span class="n">xw_amplitude</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cross_wt</span><span class="p">(</span><span class="n">wt_coeff1</span><span class="p">,</span> <span class="n">wt_coeff2</span><span class="p">)</span>

    <span class="c1"># Monte-Carlo simulations of AR1 process</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="c1">#  coherence_red = np.ndarray(shape=(nMC, nt, nf))</span>
    <span class="c1">#  AR1_q = np.ndarray(shape=(nt, nf))</span>
    <span class="n">coherence_red</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">AR1_q</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#  if nMC &gt;= 1:</span>

        <span class="c1">#  for i in tqdm(range(nMC), desc=&#39;Monte-Carlo simulations&#39;):</span>
            <span class="c1">#  r1 = ar1_sim(ys1_cut, np.size(ts1_cut), 1, ts=ts1_cut)</span>
            <span class="c1">#  r2 = ar1_sim(ys2_cut, np.size(ts2_cut), 1, ts=ts2_cut)</span>
            <span class="c1">#  res_wwz_r1 = wwz(r1, ts1_cut, tau=tau, freq=freq, c=c, Neff=Neff, nMC=0, nproc=nproc,</span>
                                                     <span class="c1">#  detrend=detrend, sg_kwargs=sg_kwrags,</span>
                                                     <span class="c1">#  gaussianize=gaussianize, standardize=standardize)</span>
            <span class="c1">#  res_wwz_r2 = wwz(r2, ts2_cut, tau=tau, freq=freq, c=c, Neff=Neff, nMC=0, nproc=nproc,</span>
                                                     <span class="c1">#  detrend=detrend, sg_kwargs=sg_kwargs,</span>
                                                     <span class="c1">#  gaussianize=gaussianize, standardize=standardize)</span>

            <span class="c1">#  wt_coeffr1 = res_wwz_r1.coeff[1] - res_wwz_r2.coeff[2]*1j</span>
            <span class="c1">#  wt_coeffr2 = res_wwz_r1.coeff[1] - res_wwz_r2.coeff[2]*1j</span>
            <span class="c1">#  coherence_red[i, :, :], phase_red = wavelet_coherence(wt_coeffr1, wt_coeffr2, freq, tau, smooth_factor=smooth_factor)</span>

        <span class="c1">#  for j in range(nt):</span>
            <span class="c1">#  for k in range(nf):</span>
                <span class="c1">#  AR1_q[j, k] = mquantiles(coherence_red[:, j, k], 0.95)</span>

    <span class="c1">#  else:</span>
        <span class="c1">#  AR1_q = None</span>

    <span class="n">coi</span> <span class="o">=</span> <span class="n">make_coi</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">Neff</span><span class="o">=</span><span class="n">Neff</span><span class="p">)</span>
    <span class="n">Results</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Results&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;xw_coherence&#39;</span><span class="p">,</span> <span class="s1">&#39;xw_amplitude&#39;</span><span class="p">,</span> <span class="s1">&#39;xw_phase&#39;</span><span class="p">,</span> <span class="s1">&#39;xwt&#39;</span><span class="p">,</span> <span class="s1">&#39;freq&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;AR1_q&#39;</span><span class="p">,</span> <span class="s1">&#39;coi&#39;</span><span class="p">])</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">Results</span><span class="p">(</span><span class="n">xw_coherence</span><span class="o">=</span><span class="n">xw_coherence</span><span class="p">,</span> <span class="n">xw_amplitude</span><span class="o">=</span><span class="n">xw_amplitude</span><span class="p">,</span> <span class="n">xw_phase</span><span class="o">=</span><span class="n">xw_phase</span><span class="p">,</span> <span class="n">xwt</span><span class="o">=</span><span class="n">xwt</span><span class="p">,</span>
                  <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span> <span class="n">AR1_q</span><span class="o">=</span><span class="n">AR1_q</span><span class="p">,</span> <span class="n">coi</span><span class="o">=</span><span class="n">coi</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>
<div class="viewcode-block" id="freq_vector_lomb_scargle"><a class="viewcode-back" href="../../../utils/wavelet/freq_vector_lomb_scargle.html#pyleoclim.utils.wavelet.freq_vector_lomb_scargle">[docs]</a><span class="k">def</span> <span class="nf">freq_vector_lomb_scargle</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ofac</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">hifac</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the frequency vector based on the REDFIT recommendation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>
<span class="sd">    dt : float</span>
<span class="sd">        The resolution of the data. If None, uses the median resolution. Defaults to None. </span>
<span class="sd">    nf : int</span>
<span class="sd">        Number of frequency points. </span>
<span class="sd">        If None, calculated as the difference between the highest and lowest frequencies (set by hifac and ofac) divided by resolution. Defaults to None</span>
<span class="sd">    ofac : float</span>
<span class="sd">        Oversampling rate that influences the resolution of the frequency axis,</span>
<span class="sd">                 when equals to 1, it means no oversamling (should be &gt;= 1).</span>
<span class="sd">                 The default value 4 is usually a good value.</span>
<span class="sd">    hifac : float</span>
<span class="sd">        fhi/fnyq (should be &lt;= 1), where fhi is the highest frequency that</span>
<span class="sd">        can be analyzed by the Lomb-Scargle algorithm and fnyq is the Nyquist frequency.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    freq : array</span>
<span class="sd">        the frequency vector</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    Trauth, M. H. MATLABÂ® Recipes for Earth Sciences. (Springer, 2015). pp 181.</span>


<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.freq_vector_welch : Return the frequency vector based on the Welch&#39;s method.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_nfft : Return the frequency vector based on NFFT</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_scale : Return the frequency vector based on scales</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_log : Return the frequency vector based on logspace </span>

<span class="sd">    pyleoclim.utils.wavelet.make_freq_vector : Make frequency vector</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="n">ofac</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">hifac</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;`ofac` should be &gt;= 1, and `hifac` should be &lt;= 1&quot;</span>
    
    <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
    <span class="n">flo</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span><span class="o">*</span><span class="n">ofac</span><span class="p">)</span>
    <span class="n">fhi</span> <span class="o">=</span> <span class="n">hifac</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">flo</span>
        <span class="n">nf</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">fhi</span> <span class="o">-</span> <span class="n">flo</span><span class="p">)</span> <span class="o">/</span> <span class="n">df</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">flo</span><span class="p">,</span> <span class="n">fhi</span><span class="p">,</span> <span class="n">nf</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">freq</span></div>

<div class="viewcode-block" id="freq_vector_welch"><a class="viewcode-back" href="../../../utils/wavelet/freq_vector_welch.html#pyleoclim.utils.wavelet.freq_vector_welch">[docs]</a><span class="k">def</span> <span class="nf">freq_vector_welch</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the frequency vector based on the Welch&#39;s method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    freq : array</span>
<span class="sd">        the frequency vector</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    https://github.com/scipy/scipy/blob/v0.14.0/scipy/signal/Spectral.py</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.freq_vector_lomb_scargle : Return the frequency vector based on the REDFIT </span>
<span class="sd">        recommendation.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_nfft : Return the frequency vector based on NFFT</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_scale : Return the frequency vector based on scales</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_log : Return the frequency vector based on logspace </span>

<span class="sd">    pyleoclim.utils.wavelet.make_freq_vector : Make frequency vector</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dt</span>
    <span class="k">if</span> <span class="n">nt</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_freq</span> <span class="o">=</span> <span class="n">nt</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_freq</span> <span class="o">=</span> <span class="p">(</span><span class="n">nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_freq</span><span class="p">)</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">/</span> <span class="n">nt</span>

    <span class="k">return</span> <span class="n">freq</span></div>

<div class="viewcode-block" id="freq_vector_nfft"><a class="viewcode-back" href="../../../utils/wavelet/freq_vector_nfft.html#pyleoclim.utils.wavelet.freq_vector_nfft">[docs]</a><span class="k">def</span> <span class="nf">freq_vector_nfft</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the frequency vector based on NFFT</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    freq : array</span>
<span class="sd">        the frequency vector</span>
<span class="sd">        </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.freq_vector_lomb_scargle : Return the frequency vector based on the REDFIT </span>
<span class="sd">        recommendation.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_welch : Return the frequency vector based on the Welch&#39;s method.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_scale : Return the frequency vector based on scales</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_log : Return the frequency vector based on logspace </span>

<span class="sd">    pyleoclim.utils.wavelet.make_freq_vector : Make frequency vector</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dt</span>
    <span class="n">n_freq</span> <span class="o">=</span> <span class="n">nt</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fs</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_freq</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">freq</span></div>

<div class="viewcode-block" id="freq_vector_scale"><a class="viewcode-back" href="../../../utils/wavelet/freq_vector_scale.html#pyleoclim.utils.wavelet.freq_vector_scale">[docs]</a><span class="k">def</span> <span class="nf">freq_vector_scale</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">nv</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">fourier_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the frequency vector based on scales for wavelet analysis</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>

<span class="sd">    nv : int</span>
<span class="sd">        the parameter that controls the number of freq points</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    freq : array</span>
<span class="sd">        the frequency vector</span>
<span class="sd">        </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.freq_vector_lomb_scargle : Return the frequency vector based on the REDFIT </span>
<span class="sd">        recommendation.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_welch : Return the frequency vector based on the Welch&#39;s method.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_nfft : Return the frequency vector based on NFFT</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_log : Return the frequency vector based on logspace </span>

<span class="sd">    pyleoclim.utils.wavelet.make_freq_vector : Make frequency vector</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">s0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
    <span class="n">a0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">nv</span><span class="p">)</span>
    <span class="n">noct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)))</span><span class="o">-</span><span class="mi">1</span>  <span class="c1"># number of octave</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">s0</span><span class="o">*</span><span class="n">a0</span><span class="o">**</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">noct</span><span class="o">*</span><span class="n">nv</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">scale</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">fourier_factor</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">freq</span></div>

<div class="viewcode-block" id="freq_vector_log"><a class="viewcode-back" href="../../../utils/wavelet/freq_vector_log.html#pyleoclim.utils.wavelet.freq_vector_log">[docs]</a><span class="k">def</span> <span class="nf">freq_vector_log</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">nfreq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the frequency vector based on logspace</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ts : array</span>
<span class="sd">        time axis of the time series</span>

<span class="sd">    nv : int</span>
<span class="sd">        the parameter that controls the number of freq points</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    freq : array</span>
<span class="sd">        the frequency vector</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.freq_vector_lomb_scargle : Return the frequency vector based on the REDFIT </span>
<span class="sd">        recommendation.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_welch : Return the frequency vector based on the Welch&#39;s method.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_nfft : Return the frequency vector based on NFFT</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_scale : Return the frequency vector based on scales</span>

<span class="sd">    pyleoclim.utils.wavelet.make_freq_vector : Make frequency vector</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dt</span>
    <span class="k">if</span> <span class="n">nfreq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="n">nt</span><span class="o">//</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">fmin</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
    <span class="n">fmax</span> <span class="o">=</span> <span class="n">fs</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">fmin</span><span class="p">)</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">fmax</span><span class="p">)</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">freq</span></div>

<div class="viewcode-block" id="make_freq_vector"><a class="viewcode-back" href="../../../utils/wavelet/make_freq_vector.html#pyleoclim.utils.wavelet.make_freq_vector">[docs]</a><span class="k">def</span> <span class="nf">make_freq_vector</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Make frequency vector</span>

<span class="sd">    This function selects among five methods to obtain the frequency</span>
<span class="sd">    vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ts : array</span>
<span class="sd">        Time axis of the time series</span>
<span class="sd">    method : string</span>
<span class="sd">        The method to use. Options are &#39;log&#39; (default), &#39;nfft&#39;, &#39;lomb_scargle&#39;, &#39;welch&#39;, and &#39;scale&#39;</span>
<span class="sd">    kwargs : dict, optional</span>
<span class="sd">            For Lomb_Scargle, additional parameters may be passed:</span>
<span class="sd">            - nf (int): number of frequency points</span>
<span class="sd">            - ofac (float): Oversampling rate that influences the resolution of the frequency axis,</span>
<span class="sd">                 when equals to 1, it means no oversamling (should be &gt;= 1).</span>
<span class="sd">                 The default value 4 is usaually a good value.</span>
<span class="sd">            - hifac (float): fhi/fnyq (should be &gt;= 1), where fhi is the highest frequency that</span>
<span class="sd">                  can be analyzed by the Lomb-Scargle algorithm and fnyq is the Nyquist frequency.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    freq : array</span>
<span class="sd">        the frequency vector</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    pyleoclim.utils.wavelet.freq_vector_lomb_scargle : Return the frequency vector based on the REDFIT </span>
<span class="sd">        recommendation.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_welch : Return the frequency vector based on the Welch&#39;s method.</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_nfft : Return the frequency vector based on NFFT</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_scale : Return the frequency vector based on scales</span>

<span class="sd">    pyleoclim.utils.wavelet.freq_vector_log : Return the frequency vector based on logspace </span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;lomb_scargle&#39;</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq_vector_lomb_scargle</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;welch&#39;</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq_vector_welch</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nfft&#39;</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq_vector_nfft</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;scale&#39;</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq_vector_scale</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq_vector_log</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;This method is not supported&#39;</span><span class="p">)</span>
    <span class="c1">#  freq = freq[1:]  # discard the first element 0</span>

    <span class="k">return</span> <span class="n">freq</span></div>

<div class="viewcode-block" id="beta_estimation"><a class="viewcode-back" href="../../../utils/wavelet/beta_estimation.html#pyleoclim.utils.wavelet.beta_estimation">[docs]</a><span class="k">def</span> <span class="nf">beta_estimation</span><span class="p">(</span><span class="n">psd</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">logf_binning_step</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Estimate the power slope of a 1/f^beta process.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    psd : array</span>
<span class="sd">        the power spectral density</span>
<span class="sd">    freq : array</span>
<span class="sd">        the frequency vector</span>
<span class="sd">    fmin : float</span>
<span class="sd">        the min of frequency range for beta estimation</span>
<span class="sd">    fmax : float</span>
<span class="sd">        the max of frequency range for beta estimation</span>
<span class="sd">    verbose : bool</span>
<span class="sd">         if True, will print out debug information</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    beta : float</span>
<span class="sd">        the estimated slope</span>
<span class="sd">    f_binned : array</span>
<span class="sd">        binned frequency vector</span>
<span class="sd">    psd_binned : array</span>
<span class="sd">        binned power spectral density</span>
<span class="sd">    Y_reg : array</span>
<span class="sd">        prediction based on linear regression</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># drop the PSD at frequency zero</span>
    <span class="k">if</span> <span class="n">freq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">psd</span> <span class="o">=</span> <span class="n">psd</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">if</span> <span class="n">fmin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">fmin</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="n">Results</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Results&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;beta&#39;</span><span class="p">,</span> <span class="s1">&#39;f_binned&#39;</span><span class="p">,</span> <span class="s1">&#39;psd_binned&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_reg&#39;</span><span class="p">,</span> <span class="s1">&#39;std_err&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">fmax</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">fmin</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">fmin</span><span class="p">,</span> <span class="n">fmax</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">freq</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WRONG&#39;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Results</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">f_binned</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">psd_binned</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">Y_reg</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">std_err</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="c1"># frequency binning start</span>
    <span class="n">fminindx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">freq</span> <span class="o">&gt;=</span> <span class="n">fmin</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">fmaxindx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">freq</span> <span class="o">&lt;=</span> <span class="n">fmax</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">fminindx</span> <span class="o">&gt;=</span> <span class="n">fmaxindx</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Results</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">f_binned</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">psd_binned</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">Y_reg</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">std_err</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="n">logf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">logf_binning_step</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
        <span class="n">logf_step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">logf</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">logf_binning_step</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
        <span class="n">logf_step</span> <span class="o">=</span> <span class="n">logf</span><span class="p">[</span><span class="n">fminindx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">logf</span><span class="p">[</span><span class="n">fminindx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;the option for logf_binning_step is unknown&#39;</span><span class="p">)</span>

    <span class="n">logf_start</span> <span class="o">=</span> <span class="n">logf</span><span class="p">[</span><span class="n">fminindx</span><span class="p">]</span>
    <span class="n">logf_end</span> <span class="o">=</span> <span class="n">logf</span><span class="p">[</span><span class="n">fmaxindx</span><span class="p">]</span>
    <span class="n">logf_binedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">logf_start</span><span class="p">,</span> <span class="n">logf_end</span><span class="o">+</span><span class="n">logf_step</span><span class="p">,</span> <span class="n">logf_step</span><span class="p">)</span>

    <span class="n">n_intervals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">logf_binedges</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">logpsd_binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_intervals</span><span class="p">)</span>
    <span class="n">logf_binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_intervals</span><span class="p">)</span>

    <span class="n">logpsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_intervals</span><span class="p">):</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="n">logf_binedges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">logf_binedges</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">logf</span> <span class="o">&gt;</span> <span class="n">lb</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">logf</span> <span class="o">&lt;=</span> <span class="n">ub</span><span class="p">))</span>

        <span class="n">logpsd_binned</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">logpsd</span><span class="p">[</span><span class="n">q</span><span class="p">])</span>
        <span class="n">logf_binned</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ub</span> <span class="o">+</span> <span class="n">lb</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">f_binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logf_binned</span><span class="p">)</span>
    <span class="n">psd_binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logpsd_binned</span><span class="p">)</span>
    <span class="c1"># frequency binning end</span>

    <span class="c1"># linear regression below</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">psd_binned</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_binned</span><span class="p">)</span>
    <span class="n">X_ex</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="c1"># note below: &#39;drop&#39; is used for missing, so NaNs will be removed, and we need to put it back in the end</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">OLS</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">X_ex</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;drop&#39;</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">Y_reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">std_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="o">-</span><span class="n">results</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># the slope we want</span>
        <span class="n">Y_reg_raw</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>  <span class="c1"># prediction based on linear regression</span>
        <span class="c1"># handeling potential NaNs in psd_binned</span>
        <span class="n">Y_reg</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">psd</span> <span class="ow">in</span> <span class="n">psd_binned</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">psd</span><span class="p">):</span>
                <span class="n">Y_reg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Y_reg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Y_reg_raw</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">Y_reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Y_reg</span><span class="p">)</span>

        <span class="n">std_err</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">bse</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">Results</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">f_binned</span><span class="o">=</span><span class="n">f_binned</span><span class="p">,</span> <span class="n">psd_binned</span><span class="o">=</span><span class="n">psd_binned</span><span class="p">,</span> <span class="n">Y_reg</span><span class="o">=</span><span class="n">Y_reg</span><span class="p">,</span> <span class="n">std_err</span><span class="o">=</span><span class="n">std_err</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="beta2HurstIndex"><a class="viewcode-back" href="../../../utils/wavelet/beta2HurstIndex.html#pyleoclim.utils.wavelet.beta2HurstIndex">[docs]</a><span class="k">def</span> <span class="nf">beta2HurstIndex</span><span class="p">(</span><span class="n">beta</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Translate psd slope to Hurst index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    beta : float</span>
<span class="sd">        the estimated slope of a power spectral density curve</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    H : float</span>
<span class="sd">        Hurst index, should be in (0, 1)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    Equation 2 in http://www.bearcave.com/misl/misl_tech/wavelets/hurst/</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

    <span class="k">return</span> <span class="n">H</span></div>

<div class="viewcode-block" id="psd_ar"><a class="viewcode-back" href="../../../utils/wavelet/psd_ar.html#pyleoclim.utils.wavelet.psd_ar">[docs]</a><span class="k">def</span> <span class="nf">psd_ar</span><span class="p">(</span><span class="n">var_noise</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">ar_params</span><span class="p">,</span> <span class="n">f_sampling</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the theoretical power spectral density (PSD) of an autoregressive model</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    var_noise : float</span>
<span class="sd">        the variance of the noise of the AR process</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    ar_params : array</span>
<span class="sd">        autoregressive coefficients, not including zero-lag</span>
<span class="sd">    f_sampling : float</span>
<span class="sd">        sampling frequency</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    psd : array</span>
<span class="sd">        power spectral density</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ar_params</span><span class="p">)</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">freq</span><span class="o">/</span><span class="n">f_sampling</span><span class="p">)</span>

    <span class="n">psd</span> <span class="o">=</span> <span class="n">var_noise</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ar_params</span><span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">return</span> <span class="n">psd</span></div>

<div class="viewcode-block" id="fBMsim"><a class="viewcode-back" href="../../../utils/wavelet/fBMsim.html#pyleoclim.utils.wavelet.fBMsim">[docs]</a><span class="k">def</span> <span class="nf">fBMsim</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="mf">0.25</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Simple method to generate fractional Brownian Motion</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    N : int</span>
<span class="sd">        the length of the simulated time series</span>
<span class="sd">    H : float</span>
<span class="sd">        Hurst index, should be in (0, 1). The relationship between H and the scaling exponent beta is</span>
<span class="sd">        H = (beta-1) / 2</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    xfBm : array</span>
<span class="sd">        the simulated fractional Brownian Motion time series</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    1. http://cours-physique.lps.ens.fr/index.php/TD11_Correlated_Noise_2011</span>
<span class="sd">    2. https://www.wikiwand.com/en/Fractional_Brownian_motion</span>

<span class="sd">    @authors: jeg, fzhu</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">N</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">H</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">H</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;H should be in (0, 1)!&quot;</span>

    <span class="n">HH</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">H</span>

    <span class="n">ns</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span>  <span class="c1"># number of steps</span>
    <span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ns</span><span class="p">,</span> <span class="n">ns</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">)</span>
            <span class="n">covariance</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">covariance</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">HH</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">HH</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">HH</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>

    <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">covariance</span><span class="p">)</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ns</span><span class="p">,</span> <span class="n">ns</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span>

    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">((</span><span class="n">ns</span><span class="p">))</span>
    <span class="n">eta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span>

    <span class="n">xfBm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">xfBm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">xfBm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">xfBm</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">eta</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">xfBm</span></div>

<div class="viewcode-block" id="psd_fBM"><a class="viewcode-back" href="../../../utils/wavelet/psd_fBm.html#pyleoclim.utils.wavelet.psd_fBM">[docs]</a><span class="k">def</span> <span class="nf">psd_fBM</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">H</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the theoretical psd of a fBM</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    ts : array</span>
<span class="sd">        the time axis of the time series</span>
<span class="sd">    H : float</span>
<span class="sd">        Hurst index, should be in (0, 1)</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>

<span class="sd">    psd : array</span>
<span class="sd">        power spectral density</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    Flandrin, P. On the spectrum of fractional Brownian motions.</span>
<span class="sd">    IEEE Transactions on Information Theory 35, 197â€“199 (1989).</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
    <span class="n">psd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nf</span><span class="p">))</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nf</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">T</span>
        <span class="n">psd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">H</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span><span class="o">/</span><span class="n">tmp</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">H</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">psd</span></div>

<div class="viewcode-block" id="get_wwz_func"><a class="viewcode-back" href="../../../utils/wavelet/get_wwz_func.html#pyleoclim.utils.wavelet.get_wwz_func">[docs]</a><span class="k">def</span> <span class="nf">get_wwz_func</span><span class="p">(</span><span class="n">nproc</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the wwz function to use.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    nproc : int</span>
<span class="sd">        the number of processes for multiprocessing</span>
<span class="sd">    method : string</span>
<span class="sd">        &#39;Foster&#39; - the original WWZ method;</span>
<span class="sd">        &#39;Kirchner&#39; - the method Kirchner adapted from Foster;</span>
<span class="sd">        &#39;Kirchner_f2py&#39; - the method Kirchner adapted from Foster with f2py</span>
<span class="sd">        &#39;Kirchner_numba&#39; - Kirchner&#39;s algorithm with Numba support for acceleration (default)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    wwz_func : function</span>
<span class="sd">        the wwz function to use</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">assertPositiveInt</span><span class="p">(</span><span class="n">nproc</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Foster&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nproc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">wwz_func</span> <span class="o">=</span> <span class="n">wwz_basic</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wwz_func</span> <span class="o">=</span> <span class="n">wwz_nproc</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Kirchner&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nproc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">wwz_func</span> <span class="o">=</span> <span class="n">kirchner_basic</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wwz_func</span> <span class="o">=</span> <span class="n">kirchner_nproc</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Kirchner_f2py&#39;</span><span class="p">:</span>
        <span class="n">wwz_func</span> <span class="o">=</span> <span class="n">kirchner_f2py</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Kirchner_numba&#39;</span><span class="p">:</span>
        <span class="n">wwz_func</span> <span class="o">=</span> <span class="n">kirchner_numba</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Wrong specific method name for WWZ. Should be one of {&quot;Foster&quot;, &quot;Kirchner&quot;, &quot;Kirchner_f2py&quot;, &quot;Kirchner_numba&quot;}&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wwz_func</span></div>

<div class="viewcode-block" id="prepare_wwz"><a class="viewcode-back" href="../../../utils/wavelet/prepare_wwz.html#pyleoclim.utils.wavelet.prepare_wwz">[docs]</a><span class="k">def</span> <span class="nf">prepare_wwz</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq_method</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">freq_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">len_bd</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bc_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the truncated time series with NaNs deleted and estimate frequency vector and tau</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series, NaNs will be deleted automatically</span>
<span class="sd">    ts : array</span>
<span class="sd">        the time points, if `ys` contains any NaNs, some of the time points will be deleted accordingly</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency. If None, will be ganerated according to freq_method.</span>
<span class="sd">        may be set.</span>
<span class="sd">    freq_method : str</span>
<span class="sd">        when freq=None, freq will be ganerated according to freq_method</span>
<span class="sd">    freq_kwargs : str</span>
<span class="sd">        used when freq=None for certain methods</span>
<span class="sd">    tau : array</span>
<span class="sd">        The evenly-spaced time points, namely the time shift for wavelet analysis.</span>
<span class="sd">        If the boundaries of tau are not exactly on two of the time axis points, then tau will be adjusted to be so.</span>
<span class="sd">        If None, at most 50 tau points will be generated from the input time span.</span>
<span class="sd">    len_bd : int</span>
<span class="sd">        the number of the ghost grids want to create on each boundary</span>
<span class="sd">    bc_mode : string</span>
<span class="sd">        {&#39;constant&#39;, &#39;edge&#39;, &#39;linear_ramp&#39;, &#39;maximum&#39;, &#39;mean&#39;, &#39;median&#39;, &#39;minimum&#39;, &#39;reflect&#39; , &#39;symmetric&#39;, &#39;wrap&#39;}</span>
<span class="sd">        For more details, see np.lib.pad()</span>
<span class="sd">    reflect_type : string</span>
<span class="sd">         {â€˜evenâ€™, â€˜oddâ€™}, optional</span>
<span class="sd">         Used in â€˜reflectâ€™, and â€˜symmetricâ€™. The â€˜evenâ€™ style is the default with an unaltered reflection around the edge value.</span>
<span class="sd">         For the â€˜oddâ€™ style, the extented part of the array is created by subtracting the reflected values from two times the edge value.</span>
<span class="sd">         For more details, see np.lib.pad()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    ys_cut : array</span>
<span class="sd">        the truncated time series with NaNs deleted</span>
<span class="sd">    ts_cut : array</span>
<span class="sd">        the truncated time axis of the original time series with NaNs deleted</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ys</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">clean_ts</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tau</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ntau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="mi">50</span><span class="p">])</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="n">ntau</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The input tau contains some NaNs.&quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;It will be regenerated using the boundarys of the time axis of the time series with NaNs deleted,&quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;with the length of the size of the input tau.&quot;</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;tau should be within the time span of the time series.&quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;Note that sometimes if the leading points of the time series are NaNs,&quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;they will be deleted and cause np.min(tau) &lt; np.min(ts).&quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;A new tau with the same size of the input tau will be generated.&quot;</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ts</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The boundaries of tau are not exactly on two of the time axis points,&quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;and it will be adjusted to be so.&quot;</span><span class="p">)</span>
        <span class="n">tau_lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">ts</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau</span><span class="p">)])</span>
        <span class="n">tau_ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">ts</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau</span><span class="p">)])</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tau_lb</span><span class="p">,</span> <span class="n">tau_ub</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>

    <span class="c1"># boundary condition</span>
    <span class="k">if</span> <span class="n">len_bd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
        <span class="n">dtau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>
        <span class="n">len_bd_tau</span> <span class="o">=</span> <span class="n">len_bd</span><span class="o">*</span><span class="n">dt</span><span class="o">//</span><span class="n">dtau</span>

        <span class="k">if</span> <span class="n">bc_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">]:</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="p">(</span><span class="n">len_bd</span><span class="p">,</span> <span class="n">len_bd</span><span class="p">),</span> <span class="n">bc_mode</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="n">reflect_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="p">(</span><span class="n">len_bd</span><span class="p">,</span> <span class="n">len_bd</span><span class="p">),</span> <span class="n">bc_mode</span><span class="p">)</span>

        <span class="n">ts_left_bd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dt</span><span class="o">*</span><span class="n">len_bd</span><span class="p">,</span> <span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dt</span><span class="p">,</span> <span class="n">len_bd</span><span class="p">)</span>
        <span class="n">ts_right_bd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dt</span><span class="p">,</span> <span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dt</span><span class="o">*</span><span class="n">len_bd</span><span class="p">,</span> <span class="n">len_bd</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ts_left_bd</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">ts_right_bd</span><span class="p">))</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The tau will be regenerated to fit the boundary condition.&quot;</span><span class="p">)</span>
        <span class="n">tau_left_bd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tau</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dtau</span><span class="o">*</span><span class="n">len_bd_tau</span><span class="p">,</span> <span class="n">tau</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dtau</span><span class="p">,</span> <span class="n">len_bd_tau</span><span class="p">)</span>
        <span class="n">tau_right_bd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tau</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dtau</span><span class="p">,</span> <span class="n">tau</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dtau</span><span class="o">*</span><span class="n">len_bd_tau</span><span class="p">,</span> <span class="n">len_bd_tau</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">tau_left_bd</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">tau_right_bd</span><span class="p">))</span>

    <span class="c1"># truncate the time series when the range of tau is smaller than that of the time series</span>
    <span class="n">ts_cut</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">ts</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ts</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau</span><span class="p">))]</span>
    <span class="n">ys_cut</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">ts</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ts</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau</span><span class="p">))]</span>

    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq_kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">freq_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">freq_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">make_freq_vector</span><span class="p">(</span><span class="n">ts_cut</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">freq_method</span><span class="p">,</span> <span class="o">**</span><span class="n">freq_kwargs</span><span class="p">)</span>

    <span class="c1"># remove 0 in freq vector</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="n">freq</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">ys_cut</span><span class="p">,</span> <span class="n">ts_cut</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span></div>

<div class="viewcode-block" id="cross_wt"><a class="viewcode-back" href="../../../utils/wavelet/cross_wt.html#pyleoclim.utils.wavelet.cross_wt">[docs]</a><span class="k">def</span> <span class="nf">cross_wt</span><span class="p">(</span><span class="n">coeff1</span><span class="p">,</span> <span class="n">coeff2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the cross wavelet transform.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    coeff1 : array</span>
<span class="sd">        the first of two sets of wavelet transform coefficients **in the form of a1 + a2*1j**</span>
<span class="sd">    coeff2 : array</span>
<span class="sd">        the second of two sets of wavelet transform coefficients **in the form of a1 + a2*1j**</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array&#39;</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    xw_amplitude : array</span>
<span class="sd">        the cross wavelet amplitude</span>
<span class="sd">    xw_phase : array</span>
<span class="sd">        the cross wavelet phase</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    Grinsted, A., Moore, J. C. &amp; Jevrejeva, S. Application of the cross wavelet transform and</span>
<span class="sd">    wavelet coherence to geophysical time series. Nonlin. Processes Geophys. 11, 561â€“566 (2004).</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">xwt</span> <span class="o">=</span> <span class="n">coeff1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">coeff2</span><span class="p">)</span>
    <span class="n">xw_amplitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">xwt</span><span class="o">.</span><span class="n">real</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">xwt</span><span class="o">.</span><span class="n">imag</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">xw_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">xwt</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">xwt</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xwt</span><span class="p">,</span> <span class="n">xw_amplitude</span><span class="p">,</span> <span class="n">xw_phase</span></div>

<div class="viewcode-block" id="wavelet_coherence"><a class="viewcode-back" href="../../../utils/wavelet/wavelet_coherence.html#pyleoclim.utils.wavelet.wavelet_coherence">[docs]</a><span class="k">def</span> <span class="nf">wavelet_coherence</span><span class="p">(</span><span class="n">coeff1</span><span class="p">,</span> <span class="n">coeff2</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">smooth_factor</span><span class="o">=</span><span class="mf">0.25</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the cross wavelet coherence.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    coeff1 : array</span>
<span class="sd">        the first of two sets of wavelet transform coefficients **in the form of a1 + a2*1j**</span>
<span class="sd">    coeff2 : array</span>
<span class="sd">        the second of two sets of wavelet transform coefficients **in the form of a1 + a2*1j**</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency</span>
<span class="sd">    tau : array&#39;</span>
<span class="sd">        the evenly-spaced time points, namely the time shift for wavelet analysis</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    xw_coherence : array</span>
<span class="sd">        the cross wavelet coherence</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    1. Grinsted, A., Moore, J. C. &amp; Jevrejeva, S. Application of the cross wavelet transform and</span>
<span class="sd">        wavelet coherence to geophysical time series. Nonlin. Processes Geophys. 11, 561â€“566 (2004).</span>
<span class="sd">    2. Matlab code by Grinsted (https://github.com/grinsted/wavelet-coherence)</span>
<span class="sd">    3. Python code by Sebastian Krieger (https://github.com/regeirk/pycwt)</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">rect</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Rectangular function adapted from https://github.com/regeirk/pycwt/blob/master/pycwt/helpers.py</span>

<span class="sd">        Args:</span>
<span class="sd">            length (int): length of the rectangular function</span>
<span class="sd">            normalize (bool): normalize or not</span>

<span class="sd">        Returns:</span>
<span class="sd">            rect (array): the (normalized) rectangular function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
        <span class="n">rect</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rect</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">rect</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">rect</span> <span class="o">/=</span> <span class="n">rect</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">rect</span>

    <span class="k">def</span> <span class="nf">smoothing</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">snorm</span><span class="p">,</span> <span class="n">dj</span><span class="p">,</span> <span class="n">smooth_factor</span><span class="o">=</span><span class="n">smooth_factor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Smoothing function adapted from https://github.com/regeirk/pycwt/blob/master/pycwt/helpers.py</span>

<span class="sd">        Args</span>
<span class="sd">        ----</span>

<span class="sd">        coeff : array</span>
<span class="sd">            the wavelet coefficients get from wavelet transform **in the form of a1 + a2*1j**</span>
<span class="sd">        snorm : array</span>
<span class="sd">            normalized scales</span>
<span class="sd">        dj : float</span>
<span class="sd">            it satisfies the equation [ Sj = S0 * 2**(j*dj) ]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        rect : array</span>
<span class="sd">            the (normalized) rectangular function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">fft_kwargs</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">))))}</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>

        <span class="c1"># Smooth in time</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">fft_kwargs</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])[</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="n">k</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># Notes by Smoothing by Gaussian window (absolute value of wavelet function)</span>
        <span class="c1"># using the convolution theorem: multiplication by Gaussian curve in</span>
        <span class="c1"># Fourier domain for each scale, outer product of scale and frequency</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">smooth_factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">snorm</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">k2</span><span class="p">)</span>  <span class="c1"># Outer product</span>
        <span class="n">smooth</span> <span class="o">=</span> <span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">F</span> <span class="o">*</span> <span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">fft_kwargs</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])),</span>
                          <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># Along Fourier frequencies</span>
                          <span class="o">**</span><span class="n">fft_kwargs</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">overwrite_x</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n</span><span class="p">]</span>  <span class="c1"># Remove possibly padded region due to FFT</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">W</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">real</span>

        <span class="c1"># Smooth in scale</span>
        <span class="n">wsize</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">/</span> <span class="n">dj</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="n">win</span> <span class="o">=</span> <span class="n">rect</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">wsize</span><span class="p">)),</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">win</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">S</span>

    <span class="n">xwt</span> <span class="o">=</span> <span class="n">coeff1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">coeff2</span><span class="p">)</span>
    <span class="n">power1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coeff1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">power2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coeff2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">scales</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">freq</span>  <span class="c1"># `scales` here is the `Period` axis in the wavelet plot</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>
    <span class="n">snorm</span> <span class="o">=</span> <span class="n">scales</span> <span class="o">/</span> <span class="n">dt</span>  <span class="c1"># normalized scales</span>

    <span class="c1"># with WWZ method, we don&#39;t have a constant dj, so we will just take the average over the whole scale range</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">scales</span><span class="p">)</span>
    <span class="n">s0</span> <span class="o">=</span> <span class="n">scales</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sN</span> <span class="o">=</span> <span class="n">scales</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">sN</span><span class="o">/</span><span class="n">s0</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>

    <span class="n">S12</span> <span class="o">=</span> <span class="n">smoothing</span><span class="p">(</span><span class="n">xwt</span><span class="o">/</span><span class="n">scales</span><span class="p">,</span> <span class="n">snorm</span><span class="p">,</span> <span class="n">dj</span><span class="p">)</span>
    <span class="n">S1</span> <span class="o">=</span> <span class="n">smoothing</span><span class="p">(</span><span class="n">power1</span><span class="o">/</span><span class="n">scales</span><span class="p">,</span> <span class="n">snorm</span><span class="p">,</span> <span class="n">dj</span><span class="p">)</span>
    <span class="n">S2</span> <span class="o">=</span> <span class="n">smoothing</span><span class="p">(</span><span class="n">power2</span><span class="o">/</span><span class="n">scales</span><span class="p">,</span> <span class="n">snorm</span><span class="p">,</span> <span class="n">dj</span><span class="p">)</span>
    <span class="n">xw_coherence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S12</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">wcs</span> <span class="o">=</span> <span class="n">S12</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S2</span><span class="p">))</span>
    <span class="n">xw_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">wcs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xw_coherence</span><span class="p">,</span> <span class="n">xw_phase</span></div>

<div class="viewcode-block" id="reconstruct_ts"><a class="viewcode-back" href="../../../utils/wavelet/reconstruct_ts.html#pyleoclim.utils.wavelet.reconstruct_ts">[docs]</a><span class="k">def</span> <span class="nf">reconstruct_ts</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">len_bd</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Reconstruct the normalized time series from the wavelet coefficients.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    coeff : array</span>
<span class="sd">        the coefficients of the corresponding basis functions (a0, a1, a2)</span>
<span class="sd">    freq : array</span>
<span class="sd">        vector of frequency of the basis functions</span>
<span class="sd">    tau : array</span>
<span class="sd">        the evenly-spaced time points of the basis functions</span>
<span class="sd">    t : array</span>
<span class="sd">        the specified evenly-spaced time points of the reconstructed time series</span>
<span class="sd">    len_bd : int</span>
<span class="sd">        the number of the ghost grids want to creat on each boundary</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    rec_ts : array</span>
<span class="sd">        the reconstructed normalized time series</span>
<span class="sd">    t : array</span>
<span class="sd">        the evenly-spaced time points of the reconstructed time series</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">freq</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">len_bd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">t_left_bd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dt</span><span class="o">*</span><span class="n">len_bd</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dt</span><span class="p">,</span> <span class="n">len_bd</span><span class="p">)</span>
        <span class="n">t_right_bd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dt</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dt</span><span class="o">*</span><span class="n">len_bd</span><span class="p">,</span> <span class="n">len_bd</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">t_left_bd</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t_right_bd</span><span class="p">))</span>

    <span class="n">ntau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">a_0</span><span class="p">,</span> <span class="n">a_1</span><span class="p">,</span> <span class="n">a_2</span> <span class="o">=</span> <span class="n">coeff</span>

    <span class="n">rec_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nf</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntau</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a_0</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a_1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a_1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dz</span> <span class="o">=</span> <span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">tau</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">phi_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>
                <span class="n">phi_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>

                <span class="n">rec_ts</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a_0</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">a_1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">phi_1</span> <span class="o">+</span> <span class="n">a_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">phi_2</span><span class="p">)</span>

    <span class="n">rec_ts</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">rec_ts</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rec_ts</span><span class="p">,</span> <span class="n">t</span></div>

<span class="c1"># ## Methods for Torrence and compo</span>

<span class="c1"># # This is the main function, which has been rewritten to work with functionalities in Pyleoclim</span>

<span class="c1"># def cwt(ys,ts,mother=&#39;morlet&#39;,param=None,freq=None,freq_method=&#39;scale&#39;,</span>
<span class="c1">#         freq_kwargs={},detrend=False, sg_kwargs={}, gaussianize=False,</span>
<span class="c1">#         standardize=False,pad=False,pad_kwargs={}):</span>
    
<span class="c1">#     ys=np.array(ys)</span>
<span class="c1">#     ts=np.array(ts)</span>
    
<span class="c1">#     ys, ts = clean_ts(ys, ts) #clean up time</span>
    
<span class="c1">#     #make sure that the time series is evenly-spaced</span>
<span class="c1">#     if is_evenly_spaced(ts) == True:</span>
<span class="c1">#         dt = np.mean(np.diff(ts))</span>
<span class="c1">#     else:</span>
<span class="c1">#         raise ValueError(&#39;Time series must be evenly spaced in time&#39;)</span>
       
<span class="c1">#     # prepare the time series </span>
<span class="c1">#     pd_ys = preprocess(ys, ts, detrend=detrend, sg_kwargs=sg_kwargs, </span>
<span class="c1">#                        gaussianize=gaussianize, standardize=standardize)</span>
    
<span class="c1">#     # Get the fourier factor</span>
<span class="c1">#     if mother.lower() == &#39;morlet&#39;:</span>
<span class="c1">#         if param is None:</span>
<span class="c1">#             param = 6.</span>
<span class="c1">#         fourier_factor = 4 * np.pi / (param + np.sqrt(2 + param**2))</span>
<span class="c1">#     elif mother.lower() == &#39;paul&#39;:</span>
<span class="c1">#         if param is None:</span>
<span class="c1">#             param = 4.</span>
<span class="c1">#         fourier_factor = 4 * np.pi / (2 * param + 1)</span>
<span class="c1">#     elif mother.lower() == &#39;dog&#39;:</span>
<span class="c1">#         if param is None:</span>
<span class="c1">#             param = 2.</span>
<span class="c1">#         fourier_factor = 2 * np.pi * np.sqrt(2. / (2 * param + 1))</span>
<span class="c1">#     else:</span>
<span class="c1">#         fourier_factor = 1</span>
    
<span class="c1">#     #get the frequency/scale information</span>
<span class="c1">#     if freq is None: </span>
<span class="c1">#         freq_kwargs = {} if freq_kwargs is None else freq_kwargs.copy()</span>
<span class="c1">#         if freq_method == &#39;scale&#39;:</span>
<span class="c1">#             freq_kwargs.update({&#39;fourier_factor&#39;:fourier_factor})</span>
<span class="c1">#         freq = make_freq_vector(ts, method=freq_method, **freq_kwargs)</span>
<span class="c1">#     # Use scales</span>
<span class="c1">#     scale = np.sort(1/(freq*fourier_factor))</span>
    
<span class="c1">#     #Normalize</span>
<span class="c1">#     #n_ys = pd_ys-np.mean(pd_ys)</span>
    
<span class="c1">#     #pad if wanted</span>
<span class="c1">#     if pad == True:</span>
<span class="c1">#         pad_kwargs = {} if pad_kwargs is None else pad_kwargs.copy()</span>
<span class="c1">#         yp,tp = ts_pad(pd_ys,ts,**pad_kwargs)</span>
<span class="c1">#     else:</span>
<span class="c1">#         yp=pd_ys</span>
<span class="c1">#         tp=ts</span>
        
<span class="c1">#     # Wave calculation</span>
<span class="c1">#     n = len(yp)</span>
    
<span class="c1">#     # construct wavenumber array used in transform [Eqn(5)]</span>
<span class="c1">#     kplus = np.arange(1, int(n / 2) + 1)</span>
<span class="c1">#     kplus = (kplus * 2 * np.pi / (n * dt))</span>
<span class="c1">#     kminus = np.arange(1, int((n - 1) / 2) + 1)</span>
<span class="c1">#     kminus = np.sort((-kminus * 2 * np.pi / (n * dt)))</span>
<span class="c1">#     k = np.concatenate(([0.], kplus, kminus))</span>

<span class="c1">#     # compute FFT of the (padded) time series</span>
<span class="c1">#     f = np.fft.fft(yp) </span>
    
<span class="c1">#     # define the wavelet array</span>
<span class="c1">#     wave = np.zeros(shape=(len(scale), n), dtype=complex)</span>

<span class="c1">#     # loop through all scales and compute transform</span>
<span class="c1">#     for a1 in range(0, len(scale)):</span>
<span class="c1">#         daughter, fourier_factor, coi, _ = \</span>
<span class="c1">#             wave_bases(mother, k, scale[a1], param)</span>
<span class="c1">#         wave[a1, :] = np.fft.ifft(f * daughter)  # wavelet transform[Eqn(4)]</span>
    
<span class="c1">#     #COI</span>
<span class="c1">#     coi = coi * dt * np.concatenate((</span>
<span class="c1">#         np.insert(np.arange(int((len(ys) + 1) / 2) - 1), [0], [1E-5]),</span>
<span class="c1">#         np.insert(np.flipud(np.arange(0, int(len(ys) / 2) - 1)), [-1], [1E-5])))</span>
    
<span class="c1">#     #Remove the padding </span>
<span class="c1">#     if pad == True:</span>
<span class="c1">#         idx = np.in1d(tp,ts)</span>
<span class="c1">#         wave = wave[:,idx]</span>
        
<span class="c1">#     res = {}</span>
    
<span class="c1">#     return res</span>
    

<span class="c1"># def wave_bases(mother, k, scale, param):</span>
<span class="c1">#     &#39;&#39;&#39;</span>
    

<span class="c1">#     Parameters</span>
<span class="c1">#     ----------</span>
<span class="c1">#     mother : string, {}</span>
<span class="c1">#         DESCRIPTION.</span>
<span class="c1">#     k : TYPE</span>
<span class="c1">#         DESCRIPTION.</span>
<span class="c1">#     scale : TYPE</span>
<span class="c1">#         DESCRIPTION.</span>
<span class="c1">#     param : TYPE</span>
<span class="c1">#         DESCRIPTION.</span>

<span class="c1">#     Raises</span>
<span class="c1">#     ------</span>
<span class="c1">#     KeyError</span>
<span class="c1">#         DESCRIPTION.</span>

<span class="c1">#     Returns</span>
<span class="c1">#     -------</span>
<span class="c1">#     daughter : TYPE</span>
<span class="c1">#         DESCRIPTION.</span>
<span class="c1">#     fourier_factor : TYPE</span>
<span class="c1">#         DESCRIPTION.</span>
<span class="c1">#     coi : TYPE</span>
<span class="c1">#         DESCRIPTION.</span>
<span class="c1">#     dofmin : TYPE</span>
<span class="c1">#         DESCRIPTION.</span>

<span class="c1">#     &#39;&#39;&#39;</span>
    
<span class="c1">#     n = len(k)</span>
<span class="c1">#     kplus = np.array(k &gt; 0., dtype=float)</span>

<span class="c1">#     if mother == &#39;morlet&#39;:  # -----------------------------------  Morlet</span>

<span class="c1">#         if param == -1:</span>
<span class="c1">#             param = 6.</span>

<span class="c1">#         k0 = np.copy(param)</span>
<span class="c1">#         # calc psi_0(s omega) from Table 1</span>
<span class="c1">#         expnt = -(scale * k - k0) ** 2 / 2. * kplus</span>
<span class="c1">#         norm = np.sqrt(scale * k[1]) * (np.pi ** (-0.25)) * np.sqrt(n)</span>
<span class="c1">#         daughter = norm * np.exp(expnt)</span>
<span class="c1">#         daughter = daughter * kplus  # Heaviside step function</span>
<span class="c1">#         # Scale--&gt;Fourier [Sec.3h]</span>
<span class="c1">#         fourier_factor = (4 * np.pi) / (k0 + np.sqrt(2 + k0 ** 2))</span>
<span class="c1">#         coi = fourier_factor / np.sqrt(2)  # Cone-of-influence [Sec.3g]</span>
<span class="c1">#         dofmin = 2  # Degrees of freedom</span>
<span class="c1">#     elif mother == &#39;paul&#39;:  # --------------------------------  Paul</span>
<span class="c1">#         if param == -1:</span>
<span class="c1">#             param = 4.</span>
<span class="c1">#         m = param</span>
<span class="c1">#         # calc psi_0(s omega) from Table 1</span>
<span class="c1">#         expnt = -scale * k * kplus</span>
<span class="c1">#         norm_bottom = np.sqrt(m * np.prod(np.arange(1, (2 * m))))</span>
<span class="c1">#         norm = np.sqrt(scale * k[1]) * (2 ** m / norm_bottom) * np.sqrt(n)</span>
<span class="c1">#         daughter = norm * ((scale * k) ** m) * np.exp(expnt) * kplus</span>
<span class="c1">#         fourier_factor = 4 * np.pi / (2 * m + 1)</span>
<span class="c1">#         coi = fourier_factor * np.sqrt(2)</span>
<span class="c1">#         dofmin = 2</span>
<span class="c1">#     elif mother == &#39;dog&#39;:  # --------------------------------  DOG</span>
<span class="c1">#         if param == -1:</span>
<span class="c1">#             param = 2.</span>
<span class="c1">#         m = param</span>
<span class="c1">#         # calc psi_0(s omega) from Table 1</span>
<span class="c1">#         expnt = -(scale * k) ** 2 / 2.0</span>
<span class="c1">#         norm = np.sqrt(scale * k[1] / gamma(m + 0.5)) * np.sqrt(n)</span>
<span class="c1">#         daughter = -norm * (1j ** m) * ((scale * k) ** m) * np.exp(expnt)</span>
<span class="c1">#         fourier_factor = 2 * np.pi * np.sqrt(2. / (2 * m + 1))</span>
<span class="c1">#         coi = fourier_factor / np.sqrt(2)</span>
<span class="c1">#         dofmin = 1</span>
<span class="c1">#     else:</span>
<span class="c1">#         raise KeyError(&#39;Mother must be one of &quot;morlet&quot;, &quot;paul&quot;, &quot;dog&quot;&#39;)</span>

<span class="c1">#     return daughter, fourier_factor, coi, dofmin</span>
        
    
<span class="c1"># def chisquare_inv(P, V):</span>

<span class="c1">#     if (1 - P) &lt; 1E-4:</span>
<span class="c1">#         print(&#39;P must be &lt; 0.9999&#39;)</span>

<span class="c1">#     if P == 0.95 and V == 2:  # this is a no-brainer</span>
<span class="c1">#         X = 5.9915</span>
<span class="c1">#         return X</span>

<span class="c1">#     MINN = 0.01  # hopefully this is small enough</span>
<span class="c1">#     MAXX = 1  # actually starts at 10 (see while loop below)</span>
<span class="c1">#     X = 1</span>
<span class="c1">#     TOLERANCE = 1E-4  # this should be accurate enough</span>

<span class="c1">#     while (X + TOLERANCE) &gt;= MAXX:  # should only need to loop thru once</span>
<span class="c1">#         MAXX = MAXX * 10.</span>
<span class="c1">#     # this calculates value for X, NORMALIZED by V</span>
<span class="c1">#         X = fminbound(chisquare_solve, MINN, MAXX, args=(P, V), xtol=TOLERANCE)</span>
<span class="c1">#         MINN = MAXX</span>

<span class="c1">#     X = X * V  # put back in the goofy V factor</span>

<span class="c1">#     return X  </span>

<span class="c1"># def chisquare_solve(XGUESS, P, V):</span>

<span class="c1">#     PGUESS = gammainc(V / 2, V * XGUESS / 2)  # incomplete Gamma function</span>

<span class="c1">#     PDIFF = np.abs(PGUESS - P)            # error in calculated P</span>

<span class="c1">#     TOL = 1E-4</span>
<span class="c1">#     if PGUESS &gt;= 1 - TOL:  # if P is very close to 1 (i.e. a bad guess)</span>
<span class="c1">#         PDIFF = XGUESS   # then just assign some big number like XGUESS</span>

<span class="c1">#     return PDIFF</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2021, Deborah Khider, Feng Zhu, Julien Emile-Geay, Alexander James.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>