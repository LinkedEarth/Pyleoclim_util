

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyleoclim.utils.tsutils &mdash; Pyleoclim 0.6.2beta documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/rtd_sphinx_search.min.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/js/rtd_sphinx_search.min.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> Pyleoclim
          

          
            
            <img src="../../../_static/pyleoclim_insigna_full_white.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.6.2beta
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Working with Pyleoclim</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing Pyleoclim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../core/ui.html">The Pyleoclim User Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
</ul>
<p class="caption"><span class="caption-text">Advanced functionalities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../utils/introduction.html">Pyleoclim Utilities (pyleoclim.utils)</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting Involved</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../citation.html">Citing Pyleoclim</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Pyleoclim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pyleoclim.utils.tsutils</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyleoclim.utils.tsutils</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Tue Feb 25 06:43:14 2020</span>

<span class="sd">@author: deborahkhider, fzhu, jeg</span>

<span class="sd">Utilities to manipulate timeseries</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;simple_stats&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bin&#39;</span><span class="p">,</span>
    <span class="s1">&#39;interp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;gkernel&#39;</span><span class="p">,</span>
    <span class="s1">&#39;grid_properties&#39;</span><span class="p">,</span>
    <span class="s1">&#39;standardize&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ts2segments&#39;</span><span class="p">,</span>
    <span class="s1">&#39;clean_ts&#39;</span><span class="p">,</span>
    <span class="s1">&#39;dropna&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sort_ts&#39;</span><span class="p">,</span>
    <span class="s1">&#39;annualize&#39;</span><span class="p">,</span>
    <span class="s1">&#39;gaussianize&#39;</span><span class="p">,</span>
    <span class="s1">&#39;gaussianize_single&#39;</span><span class="p">,</span>
    <span class="s1">&#39;detrend&#39;</span><span class="p">,</span>
    <span class="s1">&#39;detect_outliers&#39;</span><span class="p">,</span>
    <span class="s1">&#39;is_evenly_spaced&#39;</span><span class="p">,</span>
    <span class="s1">&#39;remove_outliers&#39;</span><span class="p">,</span>
    <span class="s1">&#39;reduce_duplicated_timestamps&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">special</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">from</span> <span class="nn">pyhht</span> <span class="kn">import</span> <span class="n">EMD</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">DBSCAN</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">NearestNeighbors</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">exit</span>
<span class="kn">from</span> <span class="nn">.plotting</span> <span class="kn">import</span> <span class="n">plot_scatter_xy</span><span class="p">,</span><span class="n">plot_xy</span><span class="p">,</span><span class="n">savefig</span><span class="p">,</span><span class="n">showfig</span>
<span class="kn">from</span> <span class="nn">.filter</span> <span class="kn">import</span> <span class="n">savitzky_golay</span>



<div class="viewcode-block" id="simple_stats"><a class="viewcode-back" href="../../../utils/tsutils/simple_stats.html#pyleoclim.utils.tsutils.simple_stats">[docs]</a><span class="k">def</span> <span class="nf">simple_stats</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Computes simple statistics</span>

<span class="sd">    Computes the mean, median, min, max, standard deviation, and interquartile</span>
<span class="sd">    range of a numpy array y, ignoring NaNs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    y: array</span>
<span class="sd">        A Numpy array</span>
<span class="sd">    axis : int, tuple of ints</span>
<span class="sd">        Optional. Axis or Axes along which the means</span>
<span class="sd">        are computed, the default is to compute the mean of the flattened</span>
<span class="sd">        array. If a tuple of ints, performed over multiple axes</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    mean :  float</span>
<span class="sd">        mean of y, ignoring NaNs</span>
<span class="sd">    median : float</span>
<span class="sd">        median of y, ignoring NaNs</span>
<span class="sd">    min_ : float</span>
<span class="sd">        mininum value in y, ignoring NaNs</span>
<span class="sd">    max_ : float</span>
<span class="sd">        max value in y, ignoring NaNs</span>
<span class="sd">    std : float</span>
<span class="sd">        standard deviation of y, ignoring NaNs</span>
<span class="sd">    IQR : float</span>
<span class="sd">        Interquartile range of y along specified axis, ignoring NaNs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure that y is an array</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

    <span class="c1"># Perform the various calculations</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">min_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">max_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">IQR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">median</span><span class="p">,</span> <span class="n">min_</span><span class="p">,</span> <span class="n">max_</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">IQR</span></div>


<div class="viewcode-block" id="bin"><a class="viewcode-back" href="../../../utils/tsutils/bin_values.html#pyleoclim.utils.tsutils.bin">[docs]</a><span class="k">def</span> <span class="nf">bin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">evenly_spaced</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Bin the values</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    x : array</span>
<span class="sd">        The x-axis series.</span>
<span class="sd">    y : array</span>
<span class="sd">        The y-axis series.</span>
<span class="sd">    bin_size : float</span>
<span class="sd">        The size of the bins. Default is the mean resolution if evenly_spaced is not True</span>
<span class="sd">    start : float</span>
<span class="sd">        Where/when to start binning. Default is the minimum</span>
<span class="sd">    stop : float</span>
<span class="sd">        When/where to stop binning. Default is the maximum</span>
<span class="sd">    evenly_spaced : {True,False}</span>
<span class="sd">        Makes the series evenly-spaced. This option is ignored if bin_size is set to float</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    binned_values : array</span>
<span class="sd">        The binned values</span>
<span class="sd">    bins : array</span>
<span class="sd">        The bins (centered on the median, i.e., the 100-200 bin is 150)</span>
<span class="sd">    n : array</span>
<span class="sd">        number of data points in each bin</span>
<span class="sd">    error : array</span>
<span class="sd">        the standard error on the mean in each bin</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Make sure x and y are numpy arrays</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">bin_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">evenly_spaced</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The bin_size has been set, the series may not be evenly_spaced&#39;</span><span class="p">)</span>

    <span class="c1"># Get the bin_size if not available</span>
    <span class="k">if</span> <span class="n">bin_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">evenly_spaced</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">bin_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bin_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="c1"># Get the start/stop if not given</span>
    <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Set the bin medians</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="o">+</span><span class="n">bin_size</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">stop</span> <span class="o">+</span> <span class="n">bin_size</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">)</span>

    <span class="c1"># Perform the calculation</span>
    <span class="n">binned_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">val</span><span class="o">-</span><span class="n">bin_size</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">val</span><span class="o">+</span><span class="n">bin_size</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">binned_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">error</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">binned_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>
            <span class="n">n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="n">error</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>

    <span class="n">res_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;bins&#39;</span><span class="p">:</span> <span class="n">bins</span><span class="p">,</span>
        <span class="s1">&#39;binned_values&#39;</span><span class="p">:</span> <span class="n">binned_values</span><span class="p">,</span>
        <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span>
        <span class="s1">&#39;error&#39;</span><span class="p">:</span> <span class="n">error</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">return</span>  <span class="n">res_dict</span></div>


<div class="viewcode-block" id="gkernel"><a class="viewcode-back" href="../../../utils/tsutils/gkernel.html#pyleoclim.utils.tsutils.gkernel">[docs]</a><span class="k">def</span> <span class="nf">gkernel</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step_style</span> <span class="o">=</span> <span class="s1">&#39;max&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Coarsen time resolution using a Gaussian kernel</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t  : 1d array</span>
<span class="sd">        the original time axis</span>
<span class="sd">    </span>
<span class="sd">    y  : 1d array</span>
<span class="sd">        values on the original time axis</span>
<span class="sd">    </span>
<span class="sd">    step : float</span>
<span class="sd">        The interpolation step. Default is max spacing between consecutive points.</span>
<span class="sd">        </span>
<span class="sd">    start : float</span>
<span class="sd">        where/when to start the interpolation. Default is min(t).</span>
<span class="sd">        </span>
<span class="sd">    stop : float</span>
<span class="sd">        where/when to stop the interpolation. Default is max(t).</span>
<span class="sd">    </span>
<span class="sd">    h  : scalar;  kernel e-folding scale</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tc : 1d array</span>
<span class="sd">        the coarse time axis</span>
<span class="sd">        </span>
<span class="sd">    yc:  1d array</span>
<span class="sd">        The coarse-grained time series</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    Rehfeld, K., Marwan, N., Heitzig, J., and Kurths, J.: Comparison of correlation analysis</span>
<span class="sd">    techniques for irregularly sampled time series, Nonlin. Processes Geophys.,</span>
<span class="sd">    18, 389–404, https://doi.org/10.5194/npg-18-389-2011, 2011.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;y and t must have the same length&#39;</span><span class="p">)</span>
        
    <span class="c1"># get the interpolation step if not provided</span>
    <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">grid_properties</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">step_style</span> <span class="o">=</span> <span class="n">step_style</span><span class="p">)</span>
        <span class="c1"># Get the start and end point if not given</span>
    <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
    
    <span class="c1"># Get the uniform time axis.</span>
    <span class="n">tc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">stop</span><span class="p">,</span><span class="n">step</span><span class="p">)</span>
        

    <span class="n">kernel</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span> <span class="p">:</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">s</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># define kernel function</span>

    <span class="n">yc</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">tc</span><span class="p">)))</span>
    <span class="n">yc</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tc</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">xslice</span> <span class="o">=</span> <span class="n">t</span><span class="p">[(</span><span class="n">t</span><span class="o">&gt;=</span><span class="n">tc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">&amp;</span><span class="p">(</span><span class="n">t</span><span class="o">&lt;</span><span class="n">tc</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">yslice</span> <span class="o">=</span> <span class="n">y</span><span class="p">[(</span><span class="n">t</span><span class="o">&gt;=</span><span class="n">tc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">&amp;</span><span class="p">(</span><span class="n">t</span><span class="o">&lt;</span><span class="n">tc</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xslice</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">d</span>      <span class="o">=</span> <span class="n">xslice</span><span class="o">-</span><span class="n">tc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
            <span class="n">yc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weight</span><span class="o">*</span><span class="n">yslice</span><span class="p">)</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">yc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">return</span> <span class="n">tc</span><span class="p">,</span> <span class="n">yc</span></div>


<div class="viewcode-block" id="grid_properties"><a class="viewcode-back" href="../../../utils/tsutils/grid_properties.html#pyleoclim.utils.tsutils.grid_properties">[docs]</a><span class="k">def</span> <span class="nf">grid_properties</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">step_style</span><span class="o">=</span><span class="s1">&#39;median&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Establishes the grid properties of a numerical array:</span>
<span class="sd">        start, stop, and representative step.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array</span>

<span class="sd">    step_style : str</span>
<span class="sd">        Method to obtain a representative step if x is not evenly spaced.</span>
<span class="sd">        Valid entries: &#39;median&#39; [default], &#39;mean&#39;, &#39;mode&#39; or &#39;max&#39;</span>
<span class="sd">        The mode is the most frequent entry in a dataset, and may be a good choice if the timeseries</span>
<span class="sd">        is nearly equally spaced but for a few gaps. </span>
<span class="sd">        </span>
<span class="sd">        Max is a conservative choice, appropriate for binning methods and Gaussian kernel coarse-graining</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    start : float</span>
<span class="sd">        min(x)</span>
<span class="sd">    stop : float</span>
<span class="sd">        max(x)</span>
<span class="sd">    step : float</span>
<span class="sd">        The representative spacing between consecutive values, computed as above</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">step_style</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">step_style</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">step_style</span> <span class="o">==</span> <span class="s1">&#39;mode&#39;</span><span class="p">:</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">delta</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span></div>


<div class="viewcode-block" id="interp"><a class="viewcode-back" href="../../../utils/tsutils/interp.html#pyleoclim.utils.tsutils.interp">[docs]</a><span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">interp_type</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step_style</span><span class="o">=</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Interpolate y onto a new x-axis</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    x : array</span>
<span class="sd">       The x-axis</span>
<span class="sd">    y : array</span>
<span class="sd">       The y-axis</span>
<span class="sd">    interp_type : {‘linear’, ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’, ‘previous’, ‘next’}</span>
<span class="sd">        where ‘zero’, ‘slinear’, ‘quadratic’ and ‘cubic’ refer to a spline interpolation of zeroth, first, second or third order; ‘previous’ and ‘next’ simply return the previous or next value of the point) or as an integer specifying the order of the spline interpolator to use. Default is ‘linear’.</span>
<span class="sd">    step : float</span>
<span class="sd">            The interpolation step. Default is mean spacing between consecutive points.</span>
<span class="sd">    start : float</span>
<span class="sd">           where/when to start the interpolation. Default is min..</span>
<span class="sd">    stop : float</span>
<span class="sd">         where/when to stop the interpolation. Default is max.</span>
<span class="sd">    kwargs :  kwargs</span>
<span class="sd">        Aguments specific to interpolate.interp1D. See scipy for details https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html</span>
<span class="sd">        If getting an error about extrapolation, you can use the arguments `bound_errors=False` and `fill_value=&quot;extrapolate&quot;` to allow for extrapolation. </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    xi : array</span>
<span class="sd">        The interpolated x-axis</span>
<span class="sd">    yi : array</span>
<span class="sd">        The interpolated y values</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="c1">#Make sure x and y are numpy arrays</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

    <span class="c1"># get the interpolation step if not available</span>
    <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">grid_properties</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">step_style</span> <span class="o">=</span> <span class="n">step_style</span><span class="p">)</span>

        <span class="c1"># Get the start and end point if not given</span>
    <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="c1"># Get the interpolated x-axis.</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">stop</span><span class="p">,</span><span class="n">step</span><span class="p">)</span>

    <span class="c1">#Make sure the data is increasing</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;x-axis&quot;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s2">&quot;y-axis&quot;</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;x-axis&#39;</span><span class="p">)</span>

    <span class="c1"># Add arguments</span>

    <span class="n">yi</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;x-axis&#39;</span><span class="p">],</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;y-axis&#39;</span><span class="p">],</span><span class="n">kind</span><span class="o">=</span><span class="n">interp_type</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)(</span><span class="n">xi</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span></div>


<div class="viewcode-block" id="on_common_axis"><a class="viewcode-back" href="../../../utils/tsutils/on_common_axis.html#pyleoclim.utils.tsutils.on_common_axis">[docs]</a><span class="k">def</span> <span class="nf">on_common_axis</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;interpolation&#39;</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Places two timeseries on a common axis</span>

<span class="sd">    Note this function assumes that the time representation and units are the same (e.g., BP vs CE)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : array</span>
<span class="sd">        x-axis values of the first timeseries</span>
<span class="sd">    y1 : array</span>
<span class="sd">        y-axis values of the first timeseries</span>
<span class="sd">    x2 : array</span>
<span class="sd">        x-axis values of the second timeseries</span>
<span class="sd">    y2 : array</span>
<span class="sd">        y-axis values of the second timeseries</span>
<span class="sd">    method : str</span>
<span class="sd">        Which method to use to get the timeseries on the same x axis.</span>
<span class="sd">        Valid entries: &#39;interpolation&#39; (default, linear interpolation),</span>
<span class="sd">        &#39;bin&#39;, &#39;None&#39;. &#39;None&#39; only cuts the timeseries to the common</span>
<span class="sd">        period but does not attempt to generate a common time axis</span>
<span class="sd">    step : float</span>
<span class="sd">        The interpolation step. Default is mean resolution</span>
<span class="sd">        of lowest resolution series</span>
<span class="sd">    start : float</span>
<span class="sd">        where/when to start. Default is the maximum of the minima of</span>
<span class="sd">        the two timeseries</span>
<span class="sd">    stop : float</span>
<span class="sd">        Where/when to stop. Default is the minimum of the maxima of</span>
<span class="sd">        the two timeseries</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    xi1, xi2 : array</span>
<span class="sd">        The interpolated x-axis</span>
<span class="sd">    interp_values1, interp_values2 : array</span>
<span class="sd">        the interpolated y-values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure that x1, y1, x2, y2 are numpy arrays</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

    <span class="c1"># Find the mean/max x-axis is not provided</span>
    <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">x2</span><span class="p">)])</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">x2</span><span class="p">)])</span>

    <span class="c1"># Get the interp_step</span>
    <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x2</span><span class="p">))])</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;interpolation&#39;</span><span class="p">:</span>
    <span class="c1"># perform the interpolation</span>
        <span class="n">xi1</span><span class="p">,</span> <span class="n">interp_values1</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
                                <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
        <span class="n">xi2</span><span class="p">,</span> <span class="n">interp_values2</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
                                <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;bin&#39;</span><span class="p">:</span>
        <span class="n">xi1</span><span class="p">,</span> <span class="n">interp_values1</span><span class="p">,</span> <span class="n">_</span> <span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
                                <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
        <span class="n">xi2</span><span class="p">,</span> <span class="n">interp_values2</span><span class="p">,</span> <span class="n">_</span> <span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
                                <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_idx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x1</span><span class="o">&gt;=</span><span class="n">start</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">min_idx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x2</span><span class="o">&gt;=</span><span class="n">start</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">max_idx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x1</span><span class="o">&lt;=</span><span class="n">stop</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">max_idx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x2</span><span class="o">&lt;=</span><span class="n">stop</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">xi1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">min_idx1</span><span class="p">:</span><span class="n">max_idx1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">xi2</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="n">min_idx2</span><span class="p">:</span><span class="n">max_idx2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">interp_values1</span> <span class="o">=</span> <span class="n">y1</span><span class="p">[</span><span class="n">min_idx1</span><span class="p">:</span><span class="n">max_idx1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">interp_values2</span> <span class="o">=</span> <span class="n">y2</span><span class="p">[</span><span class="n">min_idx2</span><span class="p">:</span><span class="n">max_idx2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Not a valid interpolation method&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xi1</span><span class="p">,</span> <span class="n">xi2</span><span class="p">,</span> <span class="n">interp_values1</span><span class="p">,</span> <span class="n">interp_values2</span></div>


<div class="viewcode-block" id="standardize"><a class="viewcode-back" href="../../../utils/tsutils/standardize.html#pyleoclim.utils.tsutils.standardize">[docs]</a><span class="k">def</span> <span class="nf">standardize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Centers and normalizes a given time series. Constant or nearly constant time series not rescaled.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    x : array</span>
<span class="sd">        vector of (real) numbers as a time series, NaNs allowed</span>
<span class="sd">    scale : real</span>
<span class="sd">        A scale factor used to scale a record to a match a given variance</span>
<span class="sd">    axis : int or None</span>
<span class="sd">        axis along which to operate, if None, compute over the whole array</span>
<span class="sd">    ddof : int</span>
<span class="sd">        degress of freedom correction in the calculation of the standard deviation</span>
<span class="sd">    eps : real</span>
<span class="sd">        a threshold to determine if the standard deviation is too close to zero</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    z : array</span>
<span class="sd">       The standardized time series (z-score), Z = (X - E[X])/std(X)*scale, NaNs allowed</span>
<span class="sd">    mu : real</span>
<span class="sd">        The mean of the original time series, E[X]</span>
<span class="sd">    sig : real</span>
<span class="sd">         The standard deviation of the original time series, std[X]</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    1. Tapio Schneider&#39;s MATLAB code: http://www.clidyn.ethz.ch/imputation/standardize.m</span>
<span class="sd">    2. The zscore function in SciPy: https://github.com/scipy/scipy/blob/master/scipy/stats/stats.py</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>

<span class="sd">    pyleoclim.utils.tsutils.preprocess : pre-processes a times series using standardization and detrending.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;The time series x should be a vector or 2-D array!&#39;</span>

    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>  <span class="c1"># the mean of the original time series</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">)</span>  <span class="c1"># the standard deviation of the original time series</span>

    <span class="n">mu2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>  <span class="c1"># the mean used in the calculation of zscore</span>
    <span class="n">sig2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span><span class="p">)</span>  <span class="c1"># the standard deviation used in the calculation of zscore</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">):</span>  <span class="c1"># check if x contains (nearly) constant time series</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Constant or nearly constant time series not rescaled.&#39;</span><span class="p">)</span>
        <span class="n">where_const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span>  <span class="c1"># find out where we have (nearly) constant time series</span>

        <span class="c1"># if a vector is (nearly) constant, keep it the same as original, i.e., substract by 0 and divide by 1.</span>
        <span class="n">mu2</span><span class="p">[</span><span class="n">where_const</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sig2</span><span class="p">[</span><span class="n">where_const</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">and</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">mu2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">sig2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">mu2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig2</span>

    <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sig</span></div>


<div class="viewcode-block" id="ts2segments"><a class="viewcode-back" href="../../../utils/tsutils/ts2segments.html#pyleoclim.utils.tsutils.ts2segments">[docs]</a><span class="k">def</span> <span class="nf">ts2segments</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Chop a time series into several segments based on gap detection.</span>

<span class="sd">    The rule of gap detection is very simple:</span>
<span class="sd">        we define the intervals between time points as dts, then if dts[i] is larger than factor * dts[i-1],</span>
<span class="sd">        we think that the change of dts (or the gradient) is too large, and we regard it as a breaking point</span>
<span class="sd">        and chop the time series into two segments here</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        A time series, NaNs allowed</span>
<span class="sd">    ts : array</span>
<span class="sd">        The time points</span>
<span class="sd">    factor : float</span>
<span class="sd">        the factor that adjusts the threshold for gap detection</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    seg_ys : list</span>
<span class="sd">        a list of several segments with potentially different lengths</span>
<span class="sd">    seg_ts : list</span>
<span class="sd">        a list of the time axis of the several segments</span>
<span class="sd">    n_segs : int</span>
<span class="sd">        the number of segments</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">ys</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">clean_ts</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span>

    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>

    <span class="n">seg_ys</span><span class="p">,</span> <span class="n">seg_ts</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>  <span class="c1"># store the segments with lists</span>

    <span class="n">n_segs</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">i_start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nt</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">factor</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dts</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">i_end</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">seg_ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ys</span><span class="p">[</span><span class="n">i_start</span><span class="p">:</span><span class="n">i_end</span><span class="p">])</span>
            <span class="n">seg_ts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">i_start</span><span class="p">:</span><span class="n">i_end</span><span class="p">])</span>
            <span class="n">i_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">i_end</span><span class="p">)</span>
            <span class="n">n_segs</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">seg_ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ys</span><span class="p">[</span><span class="n">i_start</span><span class="p">:</span><span class="n">nt</span><span class="p">])</span>
    <span class="n">seg_ts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">i_start</span><span class="p">:</span><span class="n">nt</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">seg_ys</span><span class="p">,</span> <span class="n">seg_ts</span><span class="p">,</span> <span class="n">n_segs</span></div>

<div class="viewcode-block" id="clean_ts"><a class="viewcode-back" href="../../../utils/tsutils/clean_ts.html#pyleoclim.utils.tsutils.clean_ts">[docs]</a><span class="k">def</span> <span class="nf">clean_ts</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Cleaning the timeseries</span>

<span class="sd">    Delete the NaNs in the time series and sort it with time axis ascending,</span>
<span class="sd">    duplicate timestamps will be reduced by averaging the values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ys : array</span>
<span class="sd">        A time series, NaNs allowed</span>
<span class="sd">    ts : array</span>
<span class="sd">        The time axis of the time series, NaNs allowed</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ys : array</span>
<span class="sd">        The time series without nans</span>
<span class="sd">    ts : array</span>
<span class="sd">        The time axis of the time series without nans</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ys</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">dropna</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="n">ys</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">sort_ts</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="n">ys</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">reduce_duplicated_timestamps</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ys</span><span class="p">,</span> <span class="n">ts</span></div>


<div class="viewcode-block" id="dropna"><a class="viewcode-back" href="../../../utils/tsutils/dropna.html#pyleoclim.utils.tsutils.dropna">[docs]</a><span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Remove entries of ys or ts that bear NaNs</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ys : array</span>
<span class="sd">        A time series, NaNs allowed</span>
<span class="sd">    ts : array</span>
<span class="sd">        The time axis of the time series, NaNs allowed</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        If True, will print a warning message</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ys : array</span>
<span class="sd">        The time series without nans</span>
<span class="sd">    ts : array</span>
<span class="sd">        The time axis of the time series without nans</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">ys</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">ts</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;The size of time axis and data value should be equal!&#39;</span>

    <span class="n">ys_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ys_tmp</span><span class="p">)]</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ys_tmp</span><span class="p">)]</span>
    <span class="n">ts_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ts_tmp</span><span class="p">)]</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ts_tmp</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ys_tmp</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;NaNs have been detected and dropped.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ys</span><span class="p">,</span> <span class="n">ts</span></div>

<div class="viewcode-block" id="sort_ts"><a class="viewcode-back" href="../../../utils/tsutils/sort_ts.html#pyleoclim.utils.tsutils.sort_ts">[docs]</a><span class="k">def</span> <span class="nf">sort_ts</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Sort ts values in ascending order</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ys : array</span>
<span class="sd">        Dependent variable</span>
<span class="sd">    ts : array</span>
<span class="sd">        Independent variable</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        If True, will print a warning message</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ys : array</span>
<span class="sd">        Dependent variable</span>
<span class="sd">    ts : array</span>
<span class="sd">        Independent variable, sorted in ascending order</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">ys</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">ts</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;time and value arrays must be of equal length&#39;</span>

    <span class="c1"># sort the time series so that the time axis will be ascending</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[</span><span class="n">sort_ind</span><span class="p">]</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">sort_ind</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The time axis has been adjusted to be prograde&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ys</span><span class="p">,</span> <span class="n">ts</span></div>

<div class="viewcode-block" id="reduce_duplicated_timestamps"><a class="viewcode-back" href="../../../utils/tsutils/reduce_duplicated_timestamp.html#pyleoclim.utils.tsutils.reduce_duplicated_timestamps">[docs]</a><span class="k">def</span> <span class="nf">reduce_duplicated_timestamps</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Reduce duplicated timestamps in a timeseries by averaging the values</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ys : array</span>
<span class="sd">        Dependent variable</span>
<span class="sd">    ts : array</span>
<span class="sd">        Independent variable</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        If True, will print a warning message</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ys : array</span>
<span class="sd">        Dependent variable</span>
<span class="sd">    ts : array</span>
<span class="sd">        Independent variable, with duplicated timestamps reduced by averaging the values</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">ys</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">ts</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;The size of time axis and data value should be equal!&#39;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ts</span><span class="p">)):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">value</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Duplicate timestamps have been combined by averaging values.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ys</span><span class="p">,</span> <span class="n">ts</span></div>

<div class="viewcode-block" id="annualize"><a class="viewcode-back" href="../../../utils/tsutils/annualize.html#pyleoclim.utils.tsutils.annualize">[docs]</a><span class="k">def</span> <span class="nf">annualize</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Annualize a time series whose time resolution is finer than 1 year</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ys : array</span>
<span class="sd">        A time series, NaNs allowed</span>
<span class="sd">    ts : array</span>
<span class="sd">        The time axis of the time series, NaNs allowed</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ys_ann : array</span>
<span class="sd">            the annualized time series</span>
<span class="sd">    year_int : array</span>
<span class="sd">              The time axis of the annualized time series</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">ys</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">ts</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;The size of time axis and data value should be equal!&#39;</span>

    <span class="n">year_int</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">ts</span><span class="p">)))</span>
    <span class="n">year_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">year_int</span><span class="p">)))</span>
    <span class="n">n_year</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">year_int</span><span class="p">)</span>
    <span class="n">year_int_pad</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">year_int</span><span class="p">)</span>
    <span class="n">year_int_pad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">year_int</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ys_ann</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_year</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_year</span><span class="p">):</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="n">year_int_pad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">t_end</span> <span class="o">=</span> <span class="n">year_int_pad</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">t_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">ts</span> <span class="o">&gt;=</span> <span class="n">t_start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ts</span> <span class="o">&lt;</span> <span class="n">t_end</span><span class="p">)</span>
        <span class="n">ys_ann</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">ys</span><span class="p">[</span><span class="n">t_range</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ys_ann</span><span class="p">,</span> <span class="n">year_int</span></div>


<div class="viewcode-block" id="gaussianize"><a class="viewcode-back" href="../../../utils/tsutils/gaussianize.html#pyleoclim.utils.tsutils.gaussianize">[docs]</a><span class="k">def</span> <span class="nf">gaussianize</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Transforms a (proxy) timeseries to a Gaussian distribution.</span>

<span class="sd">    Originator: Michael Erb, Univ. of Southern California - April 2017</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    X : array</span>
<span class="sd">        Values for the timeseries.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    Xn : array</span>
<span class="sd">        Gaussianized timseries</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Give every record at least one dimensions, or else the code will crash.</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="c1"># Make a blank copy of the array, retaining the data type of the original data variable.</span>
    <span class="n">Xn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">Xn</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NAN</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">Xn</span> <span class="o">=</span> <span class="n">gaussianize_single</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">Xn</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gaussianize_single</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">Xn</span></div>


<div class="viewcode-block" id="gaussianize_single"><a class="viewcode-back" href="../../../utils/tsutils/gaussianize_single.html#pyleoclim.utils.tsutils.gaussianize_single">[docs]</a><span class="k">def</span> <span class="nf">gaussianize_single</span><span class="p">(</span><span class="n">X_single</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Transforms a single (proxy) timeseries to Gaussian distribution.</span>

<span class="sd">    Originator: Michael Erb, Univ. of Southern California - April 2017</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    X_single : 1D Array</span>
<span class="sd">        A single timeseries</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    Xn_single : Gaussianized values for a single timeseries.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Count only elements with data.</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">X_single</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">X_single</span><span class="p">)]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Create a blank copy of the array.</span>
    <span class="n">Xn_single</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">X_single</span><span class="p">)</span>
    <span class="n">Xn_single</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NAN</span>

    <span class="n">nz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">X_single</span><span class="p">))</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">X_single</span><span class="p">[</span><span class="n">nz</span><span class="p">])</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="n">CDF</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">*</span><span class="p">(</span><span class="n">rank</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
    <span class="n">Xn_single</span><span class="p">[</span><span class="n">nz</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">special</span><span class="o">.</span><span class="n">erfinv</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">CDF</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Xn_single</span></div>


<div class="viewcode-block" id="detrend"><a class="viewcode-back" href="../../../utils/tsutils/detrend.html#pyleoclim.utils.tsutils.detrend">[docs]</a><span class="k">def</span> <span class="nf">detrend</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;emd&quot;</span><span class="p">,</span> <span class="n">sg_kwargs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Detrend a timeseries according to four methods</span>

<span class="sd">    Detrending methods include, &quot;linear&quot;, &quot;constant&quot;, using a low-pass</span>
<span class="sd">        Savitzky-Golay filter, and using eigen mode decomposition (default).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    y : array</span>
<span class="sd">       The series to be detrended.</span>
<span class="sd">    x : array</span>
<span class="sd">       The time axis for the timeseries. Necessary for use with</span>
<span class="sd">       the Savitzky-Golay filters method since the series should be evenly spaced.</span>
<span class="sd">    method : str</span>
<span class="sd">        The type of detrending:</span>
<span class="sd">        - linear: the result of a linear least-squares fit to y is subtracted from y.</span>
<span class="sd">        - constant: only the mean of data is subtrated.</span>
<span class="sd">        - &quot;savitzky-golay&quot;, y is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">        - &quot;emd&quot; (default): Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series</span>
<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    ys : array</span>
<span class="sd">        The detrended timeseries.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>

<span class="sd">    pylecolim.utils.filter.savitzky_golay : Filtering using Savitzy-Golay</span>

<span class="sd">    pylecolim.utils.tsutils.preprocess : pre-processes a times series using standardization and detrending.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;constant&#39;</span><span class="p">:</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;savitzky-golay&quot;</span><span class="p">:</span>
        <span class="c1"># Check that the timeseries is uneven and interpolate if needed</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A time axis is needed for use with the Savitzky-Golay filter method&quot;</span><span class="p">)</span>
        <span class="c1"># Check whether the timeseries is unvenly-spaced and interpolate if needed</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Timeseries is not evenly-spaced, interpolating...&quot;</span><span class="p">)</span>
            <span class="n">x_interp</span><span class="p">,</span> <span class="n">y_interp</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_interp</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">y_interp</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">sg_kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">sg_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sg_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Now filter</span>
        <span class="n">y_filt</span> <span class="o">=</span> <span class="n">savitzky_golay</span><span class="p">(</span><span class="n">y_interp</span><span class="p">,</span><span class="o">**</span><span class="n">sg_kwargs</span><span class="p">)</span>
        <span class="c1"># Put it all back on the original x axis</span>
        <span class="n">y_filt_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x_interp</span><span class="p">,</span><span class="n">y_filt</span><span class="p">)</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">y</span><span class="o">-</span><span class="n">y_filt_x</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;emd&quot;</span><span class="p">:</span>
        <span class="n">imfs</span> <span class="o">=</span> <span class="n">EMD</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">imfs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trend</span> <span class="o">=</span> <span class="n">imfs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">trend</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Not a valid detrending method&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ys</span></div>


<div class="viewcode-block" id="distance_neighbors"><a class="viewcode-back" href="../../../utils/tsutils/distance_neighbors.html#pyleoclim.utils.tsutils.distance_neighbors">[docs]</a><span class="k">def</span> <span class="nf">distance_neighbors</span><span class="p">(</span><span class="n">signal</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Finds Distance of each point in the timeseries from its 4 nearest neighbors</span>

<span class="sd">       Parameters</span>
<span class="sd">       ----------</span>

<span class="sd">       signal : array</span>
<span class="sd">           The timeseries</span>

<span class="sd">       Returns</span>
<span class="sd">       -------</span>
<span class="sd">       distances : array</span>
<span class="sd">           Distance of each point from its nearest neighbors in decreasing order</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">nn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># 4 nearest neighbors</span>
    <span class="n">nbrs</span> <span class="o">=</span><span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">distances</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">distances</span></div>

<div class="viewcode-block" id="find_knee"><a class="viewcode-back" href="../../../utils/tsutils/find_knee.html#pyleoclim.utils.tsutils.find_knee">[docs]</a><span class="k">def</span> <span class="nf">find_knee</span><span class="p">(</span><span class="n">distances</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Finds knee point automatically in a given array sorted in decreasing order</span>

<span class="sd">       Parameters</span>
<span class="sd">       ----------</span>

<span class="sd">       distances : array</span>
<span class="sd">                  Distance of each point in the timeseries from it&#39;s nearest neighbors in decreasing order</span>

<span class="sd">       Returns</span>
<span class="sd">       -------</span>

<span class="sd">      knee : float</span>
<span class="sd">            knee point in the array</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">nPoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
    <span class="n">allCoord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="nb">range</span><span class="p">(</span><span class="n">nPoints</span><span class="p">),</span> <span class="n">distances</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">range</span><span class="p">(</span><span class="n">nPoints</span><span class="p">),</span> <span class="n">distances</span><span class="p">])</span>
    <span class="n">firstPoint</span> <span class="o">=</span> <span class="n">allCoord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">lineVec</span> <span class="o">=</span> <span class="n">allCoord</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">allCoord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">lineVecNorm</span> <span class="o">=</span> <span class="n">lineVec</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lineVec</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">vecFromFirst</span> <span class="o">=</span> <span class="n">allCoord</span> <span class="o">-</span> <span class="n">firstPoint</span>
    <span class="c1"># scalarProduct = np.sum(vecFromFirst * np.matlib.repmat(lineVecNorm, nPoints, 1), axis=1)</span>
    <span class="n">scalarProduct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vecFromFirst</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">lineVecNorm</span><span class="p">,</span> <span class="p">(</span><span class="n">nPoints</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">vecFromFirstParallel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">scalarProduct</span><span class="p">,</span> <span class="n">lineVecNorm</span><span class="p">)</span>
    <span class="n">vecToLine</span> <span class="o">=</span> <span class="n">vecFromFirst</span> <span class="o">-</span> <span class="n">vecFromFirstParallel</span>
    <span class="n">distToLine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vecToLine</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">idxOfBestPoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">distToLine</span><span class="p">)</span>
    <span class="n">knee</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">idxOfBestPoint</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">knee</span></div>


<div class="viewcode-block" id="detect_outliers"><a class="viewcode-back" href="../../../utils/tsutils/detect_outliers.html#pyleoclim.utils.tsutils.detect_outliers">[docs]</a><span class="k">def</span> <span class="nf">detect_outliers</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span><span class="n">auto</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_knee</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">plot_outliers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">plot_outliers_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">plot_knee_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="n">saveknee_settings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">saveoutliers_settings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">mute</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Function to detect outliers in the given timeseries</span>

<span class="sd">       for more details, see: https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html</span>


<span class="sd">       Parameters</span>
<span class="sd">       ----------</span>

<span class="sd">       ts : array</span>
<span class="sd">            time axis of time series</span>
<span class="sd">       ys : array</span>
<span class="sd">            y values of time series</span>
<span class="sd">       plot : boolean</span>
<span class="sd">             true by default, plots the outliers using a scatter plot</span>
<span class="sd">       auto : boolean</span>
<span class="sd">             true by default, if false the user manually selects the knee point</span>
<span class="sd">       mute : bool, optional</span>
<span class="sd">            if True, the plot will not show;</span>
<span class="sd">            recommend to turn on when more modifications are going to be made on ax</span>
<span class="sd">       plot_kwargs : dict</span>
<span class="sd">            keyword arguments for ax.plot()</span>

<span class="sd">       Returns</span>
<span class="sd">       -------</span>

<span class="sd">       outliers : array</span>
<span class="sd">                   a list of values consisting of outlier indices</span>

<span class="sd">       See also</span>
<span class="sd">       --------</span>

<span class="sd">       pylecolim.utils.tsutils.distance_neighbors : Finds Distance of each point in the timeseries from its 4 nearest neighbors</span>

<span class="sd">       pylecolim.utils.tsustils.find_knee : Finds knee point automatically in a given array sorted in decreasing order</span>

<span class="sd">       pylecolim.utils.tsutils.remove_outliers : Removes outliers from a timeseries</span>

<span class="sd">       &#39;&#39;&#39;</span>
    <span class="c1">#Take care of arguments for the knee plot</span>
    <span class="n">saveknee_settings</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">saveknee_settings</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">saveknee_settings</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">minpts</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">distance_neighbors</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="mf">0.0001</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">)</span>

        <span class="n">knee_point</span> <span class="o">=</span> <span class="n">find_knee</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
        <span class="n">mark</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">knee_point</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">))]</span>

        <span class="k">if</span> <span class="n">auto</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">db</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="n">knee_point</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="n">minpts</span><span class="p">)</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">ys</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">clusters</span><span class="o">.</span><span class="n">labels_</span>
            <span class="n">outliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plot_knee</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                <span class="n">fig1</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">knee_point</span> <span class="o">=</span> <span class="mf">0.1</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s2">&quot;knee=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">knee_point</span><span class="p">),</span> <span class="p">(</span><span class="n">mark</span><span class="p">,</span> <span class="n">knee_point</span><span class="p">),</span>
                        <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.05</span><span class="p">))</span>
                <span class="n">plot_xy</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span><span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;Indices&#39;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;Distances&#39;</span><span class="p">,</span><span class="n">plot_kwargs</span><span class="o">=</span><span class="n">plot_knee_kwargs</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">)</span>


        <span class="k">elif</span> <span class="n">auto</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">plot_xy</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;Indices&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;Distances&#39;</span><span class="p">,</span><span class="n">plot_kwargs</span><span class="o">=</span><span class="n">plot_knee_kwargs</span><span class="p">)</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Enter the value for knee point&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">plot_knee</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                <span class="n">fig1</span><span class="p">,</span><span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s2">&quot;knee=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">eps</span><span class="p">),</span> <span class="p">(</span><span class="n">mark</span><span class="p">,</span> <span class="n">knee_point</span><span class="p">),</span>
                        <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.05</span><span class="p">))</span>
                <span class="n">plot_xy</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;Indices&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;Distances&#39;</span><span class="p">,</span><span class="n">plot_kwargs</span><span class="o">=</span><span class="n">plot_knee_kwargs</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">)</span>

            <span class="n">db</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="n">minpts</span><span class="p">)</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">ys</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">clusters</span><span class="o">.</span><span class="n">labels_</span>
            <span class="n">outliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;fig1&#39;</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
            <span class="k">if</span> <span class="s1">&#39;path&#39;</span> <span class="ow">in</span> <span class="n">saveknee_settings</span><span class="p">:</span>
                <span class="n">savefig</span><span class="p">(</span><span class="n">fig1</span><span class="p">,</span> <span class="n">settings</span><span class="o">=</span><span class="n">saveknee_settings</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">mute</span><span class="p">:</span>
                    <span class="n">showfig</span><span class="p">(</span><span class="n">fig1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_outliers</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">outliers</span><span class="p">]</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[</span><span class="n">outliers</span><span class="p">]</span>
            <span class="n">plot_scatter_xy</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">ys</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span><span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;value&#39;</span><span class="p">,</span><span class="n">savefig_settings</span><span class="o">=</span><span class="n">saveoutliers_settings</span><span class="p">,</span><span class="n">plot_kwargs</span><span class="o">=</span><span class="n">plot_outliers_kwargs</span><span class="p">,</span> <span class="n">mute</span><span class="o">=</span><span class="n">mute</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">outliers</span>

    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">choice</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Switch to Auto Mode(y/n)?&#39;</span><span class="p">)</span>
        <span class="n">choice</span> <span class="o">=</span> <span class="n">choice</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">choice</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">detect_outliers</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">auto</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="remove_outliers"><a class="viewcode-back" href="../../../utils/tsutils/remove_outliers.html#pyleoclim.utils.tsutils.remove_outliers">[docs]</a><span class="k">def</span> <span class="nf">remove_outliers</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">ys</span><span class="p">,</span><span class="n">outlier_points</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Removes outliers from a timeseries</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ts : array</span>
<span class="sd">         x axis of timeseries</span>
<span class="sd">    ys : array</span>
<span class="sd">        y axis of timeseries</span>
<span class="sd">   outlier_points : array</span>
<span class="sd">                   indices of outlier points</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ys : array</span>
<span class="sd">        y axis of timeseries</span>
<span class="sd">    ts : array</span>
<span class="sd">          x axis of timeseries</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>

<span class="sd">    pylecolim.utils.tsutils.detect_outliers : Function to detect outliers in the given timeseries</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span><span class="n">outlier_points</span><span class="p">)</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">outlier_points</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ys</span><span class="p">,</span><span class="n">ts</span></div>

<div class="viewcode-block" id="is_evenly_spaced"><a class="viewcode-back" href="../../../utils/tsutils/is_evenly_spaced.html#pyleoclim.utils.tsutils.is_evenly_spaced">[docs]</a><span class="k">def</span> <span class="nf">is_evenly_spaced</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Check if a time axis is evenly spaced.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ts : array</span>
<span class="sd">        the time axis of a time series</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    check : bool</span>
<span class="sd">        True - evenly spaced; False - unevenly spaced.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">check</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
        <span class="n">dt_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dts</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">dt</span> <span class="o">==</span> <span class="n">dt_mean</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">)):</span>
            <span class="n">check</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">check</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">check</span></div>


<span class="c1"># alias</span>
<span class="n">std</span> <span class="o">=</span> <span class="n">standardize</span>
<span class="n">gauss</span> <span class="o">=</span> <span class="n">gaussianize</span>

<div class="viewcode-block" id="preprocess"><a class="viewcode-back" href="../../../utils/tsutils/preprocess.html#pyleoclim.utils.tsutils.preprocess">[docs]</a><span class="k">def</span> <span class="nf">preprocess</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">gaussianize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return the processed time series using detrend and standardization.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ys : array</span>
<span class="sd">        a time series</span>
<span class="sd">    ts : array</span>
<span class="sd">        The time axis for the timeseries. Necessary for use with</span>
<span class="sd">        the Savitzky-Golay filters method since the series should be evenly spaced.</span>
<span class="sd">    detrend : string</span>
<span class="sd">        &#39;none&#39;/False/None - no detrending will be applied;</span>
<span class="sd">        &#39;linear&#39; - a linear least-squares fit to `ys` is subtracted;</span>
<span class="sd">        &#39;constant&#39; - the mean of `ys` is subtracted</span>
<span class="sd">        &#39;savitzy-golay&#39; - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.</span>
<span class="sd">    sg_kwargs : dict</span>
<span class="sd">        The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.</span>
<span class="sd">    gaussianize : bool</span>
<span class="sd">        If True, gaussianizes the timeseries</span>
<span class="sd">    standardize : bool</span>
<span class="sd">        If True, standardizes the timeseries</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    res : array</span>
<span class="sd">        the processed time series</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>

<span class="sd">    pyleoclim.utils.filter.savitzy_golay : Filtering using Savitzy-Golay</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">detrend</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span> <span class="ow">or</span> <span class="n">detrend</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">detrend</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ys_d</span> <span class="o">=</span> <span class="n">ys</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ys_d</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">sg_kwargs</span><span class="o">=</span><span class="n">sg_kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">standardize</span><span class="p">:</span>
        <span class="n">res</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">std</span><span class="p">(</span><span class="n">ys_d</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">ys_d</span>

    <span class="k">if</span> <span class="n">gaussianize</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">gauss</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2017-2021, Deborah Khider, Feng Zhu, Julien Emile-Geay, Alexander James

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>